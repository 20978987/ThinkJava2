<chapter id="a0000002540">
  <title>Methods and Testing</title>
  
  
  <para>So far we’ve written programs that have only one method named <literal moreinfo="none">main</literal>. In this chapter, we’ll show you how to organize programs into multiple methods. We’ll also take a look at the <literal moreinfo="none">Math</literal> class, which provides methods for common mathematical operations. Finally, we’ll discuss strategies for incrementally developing and testing your code. </para>
<sect1 id="adding_methods" remap="section">
  <title>Defining New Methods</title><para>Some methods perform a computation and return a result. For example, <literal moreinfo="none">nextDouble</literal> reads input from the keyboard and returns it as a <literal moreinfo="none">double</literal>. Other methods, like <literal moreinfo="none">println</literal>, carry out a sequence of actions without returning a result. Java uses the keyword <literal moreinfo="none">void</literal> to define such methods. </para>
<programlisting language="java" format="linespecific">public static void newLine() {
    System.out.println();
}

public static void main(String[] args) {
    System.out.println("First line.");
    newLine();
    System.out.println("Second line.");
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>In this example, the <literal moreinfo="none">newLine</literal> and <literal moreinfo="none">main</literal> methods are both <literal moreinfo="none">public</literal>, which means they can be <emphasis role="bold">invoked</emphasis> (or “called”) from other classes. And they are both <literal moreinfo="none">void</literal>, which means that they don’t return a result (in contrast to <literal moreinfo="none">nextDouble</literal>). The output of the program is: </para><programlisting format="linespecific">First line.

Second line.</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm>Notice the extra space between the lines. If we wanted more space between them, we could invoke the same method repeatedly. Or we could write yet another method (named <literal moreinfo="none">threeLine</literal>) that displays three blank lines. </para>
<programlisting language="java" format="linespecific">public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>In this example, the name of the class is <literal moreinfo="none">NewLine</literal>. By convention, class names begin with a capital letter. <literal moreinfo="none">NewLine</literal> contains three methods, <literal moreinfo="none">newLine</literal>, <literal moreinfo="none">threeLine</literal>, and <literal moreinfo="none">main</literal>. Remember that Java is case-sensitive, so <literal moreinfo="none">NewLine</literal> and <literal moreinfo="none">newLine</literal> are not the same. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>By convention, method names begin with a lowercase letter and use “camel case”, which is a cute name for <literal moreinfo="none">jammingWordsTogetherLikeThis</literal>. You can use any name you want for methods, except <literal moreinfo="none">main</literal> or any of the Java keywords. </para>

</sect1><sect1 id="a0000002611" remap="section">
  <title>Flow of Execution</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>When you look at a class definition that contains several methods, it is tempting to read it from top to bottom. But that is <emphasis>not</emphasis> the <emphasis role="bold">flow of execution</emphasis>, or the order the program actually runs. The <literal moreinfo="none">NewLine</literal> program runs methods in the opposite order than they are listed. </para>

  
  <para>Programs always begin at the first statement of <literal moreinfo="none">main</literal>, regardless of where it is in the source file. Statements are executed one at a time, in order, until you reach a method invocation, which you can think of as a detour. Instead of going to the next statement, you jump to the first line of the invoked method, execute all the statements there, and then come back and pick up exactly where you left off. </para>

  
  <para>That sounds simple enough, but remember that one method can invoke another one. In the middle of <literal moreinfo="none">main</literal>, the previous example goes off to execute the statements in <literal moreinfo="none">threeLine</literal>. While in <literal moreinfo="none">threeLine</literal>, it goes off to execute <literal moreinfo="none">newLine</literal>. Then <literal moreinfo="none">newLine</literal> invokes <literal moreinfo="none">println</literal>, which causes yet another detour. </para>

  
  <para>Fortunately, Java is good at keeping track of which methods are running. So when <literal moreinfo="none">println</literal> completes, it picks up where it left off in <literal moreinfo="none">newLine</literal>; when <literal moreinfo="none">newLine</literal> completes, it goes back to <literal moreinfo="none">threeLine</literal>; and when <literal moreinfo="none">threeLine</literal> completes, it gets back to <literal moreinfo="none">main</literal>. </para>

  
  <para>Beginners often wonder why it’s worth the trouble to write other methods, when they could just do everything in <literal moreinfo="none">main</literal>. The <literal moreinfo="none">NewLine</literal> example demonstrates a few reasons: </para>
<itemizedlist>
  
    <listitem>
  
  <para>Creating a new method allows you to <emphasis>name a block of statements</emphasis>, which makes the code easier to read and understand. </para>
</listitem>
  
    <listitem>
  
  <para>Introducing new methods can <emphasis>make the program shorter</emphasis> by eliminating repetitive code. For example, to display nine consecutive newlines, you could invoke <literal moreinfo="none">threeLine</literal> three times. </para>
</listitem>
  
    <listitem>
  
  <para>A common problem-solving technique is to <emphasis>break problems down</emphasis> into sub-problems. Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution. </para>
</listitem>
  
</itemizedlist>
  
  <para>Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately. It’s easier to get a complex program working if you know that each method works correctly. </para>

</sect1><sect1 id="a0000002672" remap="section">
  <title>Parameters and Arguments</title>
    
  
  <para>Some of the methods we have used require <emphasis role="bold">arguments</emphasis>, which are the values you provide in parentheses when you invoke the method. </para>

  
  <para>For example, the <literal moreinfo="none">println</literal> method takes a <literal moreinfo="none">String</literal> argument. To display a message, you have to provide the message: <literal moreinfo="none">System.out.println("Hello")</literal>. Similarly, the <literal moreinfo="none">printf</literal> method can take multiple arguments. The statement <literal moreinfo="none">System.out.printf("%d in = %f cmn", inch, cm)</literal> has three arguments: the format string, the <literal moreinfo="none">inch</literal> value, and the <literal moreinfo="none">cm</literal> value. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>When you invoke a method, you provide the arguments. When you define a method, you name the <emphasis role="bold">parameters</emphasis>, which are variables that indicate what arguments are required. The following class shows an example: </para>
<programlisting language="java" format="linespecific">public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        printTwice("Don't make me say this twice!");
    }
}</programlisting><para>The <literal moreinfo="none">printTwice</literal> method has a parameter named <literal moreinfo="none">s</literal> with type <literal moreinfo="none">String</literal>. When you invoke <literal moreinfo="none">printTwice</literal>, you have to provide an argument with type <literal moreinfo="none">String</literal>. </para>

  
  <para>Before the method executes, the argument gets assigned to the parameter. In the <literal moreinfo="none">printTwice</literal> example, the argument <literal moreinfo="none">"Don’t make me say this twice!"</literal> gets assigned to the parameter <literal moreinfo="none">s</literal>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>This process is called <emphasis role="bold">parameter passing</emphasis>, because the value gets passed from outside the method to the inside. An argument can be any kind of expression, so if you have a <literal moreinfo="none">String</literal> variable, you can use its value as an argument: </para>
<programlisting language="java" format="linespecific">String message = "Never say never.";
printTwice(message);</programlisting><para>The value you provide as an argument must have the same (or compatible) type as the parameter. For example, if you try: </para>
<programlisting language="java" format="linespecific">printTwice(17);  // syntax error</programlisting><para>You will get an error message like this: </para><programlisting format="linespecific">File: Test.java  [line: 10]
Error: method printTwice in class Test cannot be applied
       to given types;
  required: java.lang.String
  found: int
  reason: actual argument int cannot be converted to
          java.lang.String by method invocation conversion</programlisting><para>This error message says that it found an <literal moreinfo="none">int</literal> argument, but the required parameter should be a <literal moreinfo="none">String</literal>. In the case of <literal moreinfo="none">printTwice</literal>, Java won’t convert the integer <literal moreinfo="none">17</literal> to the string <literal moreinfo="none">"17"</literal> automatically. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Sometimes Java can convert an argument from one type to another automatically. For example, <literal moreinfo="none">Math.sqrt</literal> requires a <literal moreinfo="none">double</literal>, but if you invoke <literal moreinfo="none">Math.sqrt(25)</literal>, the integer value <literal moreinfo="none">25</literal> is automatically converted to the floating-point value <literal moreinfo="none">25.0</literal>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Parameters and other variables only exist inside their own methods. In the <literal moreinfo="none">printTwice</literal> example, there is no such thing as <literal moreinfo="none">s</literal> in the <literal moreinfo="none">main</literal> method. If you try to use it there, you’ll get a compiler error. </para>

  
  <para>Similarly, inside <literal moreinfo="none">printTwice</literal> there is no such thing as <literal moreinfo="none">message</literal>. That variable belongs to <literal moreinfo="none">main</literal>. Because variables only exist inside the methods where they are defined, they are often called <emphasis role="bold">local variables</emphasis>. </para>

</sect1><sect1 id="multparam" remap="section">
  <title>Multiple Parameters</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Here is an example of a method that takes two parameters: </para>
<programlisting language="java" format="linespecific">public static void printTime(int hour, int minute) {
    System.out.print(hour);
    System.out.print(":");
    System.out.println(minute);
}</programlisting><para>To invoke this method, we have to provide two integers as arguments: </para>
<programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(hour, minute);</programlisting><para>Beginners sometimes make the mistake of “declaring” the arguments: </para>
<programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(int hour, int minute);  // syntax error</programlisting><para>That’s a syntax error, because the compiler sees <literal moreinfo="none">int hour</literal> and <literal moreinfo="none">int minute</literal> as variable declarations, not expressions that represent values. You wouldn’t declare the types of the arguments if they were simply integers: </para>
<programlisting language="java" format="linespecific">printTime(int 11, int 59);  // syntax error</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm>Pulling together the code fragments, here is the complete program: </para>
<programlisting language="java" format="linespecific">public class PrintTime {

    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }

    public static void main(String[] args) {
        int hour = 11;
        int minute = 59;
        printTime(hour, minute);
    }
}</programlisting><para><literal moreinfo="none">printTime</literal> has two parameters, named <literal moreinfo="none">hour</literal> and <literal moreinfo="none">minute</literal>. And <literal moreinfo="none">main</literal> has two variables, also named <literal moreinfo="none">hour</literal> and <literal moreinfo="none">minute</literal>. Although they have the same names, these variables are <emphasis>not</emphasis> the same. The <literal moreinfo="none">hour</literal> in <literal moreinfo="none">printTime</literal> and the <literal moreinfo="none">hour</literal> in <literal moreinfo="none">main</literal> refer to different memory locations, and they can have different values. For example, you could invoke <literal moreinfo="none">printTime</literal> like this: </para>
<programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(hour + 1, 0);</programlisting><para>Before the method is invoked, Java evaluates the arguments; in this example, the results are <literal moreinfo="none">12</literal> and <literal moreinfo="none">0</literal>. Then it assigns those values to the parameters. Inside <literal moreinfo="none">printTime</literal>, the value of <literal moreinfo="none">hour</literal> is <literal moreinfo="none">12</literal>, not <literal moreinfo="none">11</literal>, and the value of <literal moreinfo="none">minute</literal> is <literal moreinfo="none">0</literal>, not <literal moreinfo="none">59</literal>. Furthermore, if <literal moreinfo="none">printTime</literal> modifies one of its parameters, that change has no effect on the variables in <literal moreinfo="none">main</literal>. </para>

</sect1><sect1 id="stack" remap="section">
  <title>Stack Diagrams</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>One way to keep track of variables is to draw a <emphasis role="bold">stack diagram</emphasis>, which is a memory diagram (see <xref linkend="state"/>) that shows currently running methods. For each method there is a box, called a <emphasis role="bold">frame</emphasis>, that contains the method’s parameters and local variables. The name of the method appears outside the frame; the variables and parameters appear inside. </para>

  
  <figure id="fig.stack" float="False">
    <title>Stack diagram for <literal moreinfo="none">printTime(hour + 1, 0)</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack1.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

  
  <para>As with memory diagrams, stack diagrams show variables and methods at a particular point in time. <xref linkend="fig.stack"/> is a stack diagram at the beginning of the <literal moreinfo="none">printTime</literal> method. Notice that <literal moreinfo="none">main</literal> is on top, because it executed first. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Stack diagrams help you to visualize the <emphasis role="bold">scope</emphasis> of a variable, which is the area of a program where a variable can be used. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Stack diagrams are a good mental model for how variables and methods work at run-time. Learning to trace the execution of a program on paper (or on a whiteboard) is a useful skill for communicating with other programmers. </para>

  
  <para>There are educational tools that automatically draw stack diagrams for you. For example, Java Tutor (<ulink url="https://thinkjava.org/javatutor"/>) allows you to step through an entire program, both forwards and backwards, and see the stack frames and variables at each step. If you haven’t already, you should check out the Java examples on that website. </para>

</sect1><sect1 id="mathmeth" remap="section">
  <title>Math Methods</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>You don’t always have to write new methods to get work done. As a reminder, the Java library contains thousands of classes you can use. For example, the <literal moreinfo="none">Math</literal> class provides common mathematical operations. </para>
<programlisting language="java" format="linespecific">double root = Math.sqrt(17.0);
double angle = 1.5;
double height = Math.sin(angle);</programlisting><para>The first line sets <literal moreinfo="none">root</literal> to the square root of 17. The third line finds the sine of 1.5 (the value of <literal moreinfo="none">angle</literal>). <literal moreinfo="none">Math</literal> is in the <literal moreinfo="none">java.lang</literal> package, so you don’t have to import it. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Values for the trigonometric functions—<literal moreinfo="none">sin</literal>, <literal moreinfo="none">cos</literal>, and <literal moreinfo="none">tan</literal>—must be in <emphasis>radians</emphasis>. To convert from degrees to radians, you can divide by 180 and multiply by <emphasis role="math">π</emphasis>. Conveniently, the <literal moreinfo="none">Math</literal> class provides a constant named <literal moreinfo="none">PI</literal> that contains an approximation of <emphasis role="math">π</emphasis>: </para>
<programlisting language="java" format="linespecific">double degrees = 90;
double angle = degrees / 180.0 * Math.PI;</programlisting><para>Notice that <literal moreinfo="none">PI</literal> is in capital letters. Java does not recognize <literal moreinfo="none">Pi</literal>, <literal moreinfo="none">pi</literal>, or <literal moreinfo="none">pie</literal>. Also, <literal moreinfo="none">PI</literal> is the name of a constant, not a method, so it doesn’t have parentheses. The same is true for the constant <literal moreinfo="none">Math.E</literal>, which approximates Euler’s number. </para>

  
  <para>Converting to and from radians is a common operation, so the <literal moreinfo="none">Math</literal> class provides methods that do that for you. </para>
<programlisting language="java" format="linespecific">double radians = Math.toRadians(180.0);
double degrees = Math.toDegrees(Math.PI);</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Another useful method is <literal moreinfo="none">round</literal>, which rounds a floating-point value to the nearest integer and returns a <literal moreinfo="none">long</literal>. The following result is 63 (rounded up from 62.8319). </para>
<programlisting language="java" format="linespecific">long x = Math.round(Math.PI * 20.0);</programlisting><para>A <literal moreinfo="none">long</literal> is like an <literal moreinfo="none">int</literal>, but bigger. More specifically, an <literal moreinfo="none">int</literal> uses 32 bits of memory; the largest value it can hold is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>31</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 2 billion. A <literal moreinfo="none">long</literal> uses 64 bits, so the largest value is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>63</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 9 quintillion. </para>

  
  <para>Take a minute to read the documentation for these and other methods in the <literal moreinfo="none">Math</literal> class. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>

</sect1><sect1 id="a0000002981" remap="section">
  <title>Composition</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>You have probably learned how to evaluate simple expressions like <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First, you evaluate the expression in parentheses, which is the argument of the function. Then you can evaluate the function itself, either by hand or by punching it into a calculator. </para>

  
  <para>This process can be applied repeatedly to evaluate more complex expressions like <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First we evaluate the argument of the innermost function (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn></mml:mrow></mml:math></inlineequation>), then evaluate the function itself (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inlineequation>), and so on. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Just as with mathematical functions, Java methods can be <emphasis role="bold">composed</emphasis> to solve complex problems. That means you can use one method as part of another. In fact, you can use any expression as an argument to a method, as long as the resulting value has the correct type: </para>
<programlisting language="java" format="linespecific">double x = Math.cos(angle + Math.PI / 2.0);</programlisting><para>This statement divides <literal moreinfo="none">Math.PI</literal> by two, adds the result to <literal moreinfo="none">angle</literal>, and computes the cosine of the sum. You can also take the result of one method and pass it as an argument to another: </para>
<programlisting language="java" format="linespecific">double x = Math.exp(Math.log(10.0));</programlisting><para>In Java, the <literal moreinfo="none">log</literal> method always uses base <emphasis role="math">e</emphasis>. So this statement finds the log base <emphasis role="math">e</emphasis> of 10, and then raises <emphasis role="math">e</emphasis> to that power. The result gets assigned to <literal moreinfo="none">x</literal>. </para>

  
  <para>Some math methods take more than one argument. For example, <literal moreinfo="none">Math.pow</literal> takes two arguments and raises the first to the power of the second. This line computes <emphasis role="math">2<superscript>10</superscript></emphasis> and assigns the value <literal moreinfo="none">1024.0</literal> to the variable <literal moreinfo="none">x</literal>: </para>
<programlisting language="java" format="linespecific">double x = Math.pow(2.0, 10.0);</programlisting><para>When using <literal moreinfo="none">Math</literal> methods, beginners often forget the word <literal moreinfo="none">Math</literal>. For example, if you just write <literal moreinfo="none">x = pow(2.0, 10.0)</literal>, you will get a compiler error: </para><programlisting format="linespecific">File: Test.java  [line: 5]
Error: cannot find symbol
  symbol:   method pow(double,double)
  location: class Test</programlisting><para>The message “cannot find symbol” is confusing, but the last two lines provide a useful hint. The compiler is looking for a method named <literal moreinfo="none">pow</literal> in the file <literal moreinfo="none">Test.java</literal> (the file for this example). If you don’t specify a class name when referring to a method, the compiler looks in the current class by default. </para>

</sect1><sect1 id="a0000003048" remap="section">
  <title>Return Values</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>When you invoke a <literal moreinfo="none">void</literal> method, the invocation is usually on a line all by itself. For example: </para>
<programlisting language="java" format="linespecific">printTime(hour + 1, 0);</programlisting><para>On the other hand, when you invoke a value-returning method, you have to do something with the return value. We usually assign it to a variable or use it as part of an expression, like this: </para>
<programlisting language="java" format="linespecific">double error = Math.abs(expect - actual);
double height = radius * Math.sin(angle);</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Compared to <literal moreinfo="none">void</literal> methods, value-returning methods differ in two ways: </para>
<itemizedlist>
  
    <listitem>
  
  <para>They declare the type of the return value (the <emphasis role="bold">return type</emphasis>); </para>
</listitem>
  
    <listitem>
  
  <para>They use at least one <literal moreinfo="none">return</literal> statement to provide a <emphasis role="bold">return value</emphasis>. </para>
</listitem>
  
</itemizedlist>
  
  <para>Here’s an example from a program named <literal moreinfo="none">Circle.java</literal>. The <literal moreinfo="none">calculateArea</literal> method takes a <literal moreinfo="none">double</literal> as a parameter and returns the area of a circle with that radius (i.e., <emphasis role="math">πr<superscript>2</superscript></emphasis>). </para>
<programlisting language="java" format="linespecific">public static double calculateArea(double radius) {
    double result = Math.PI * radius * radius;
    return result;
}</programlisting><para>As usual, this method is <literal moreinfo="none">public</literal> and <literal moreinfo="none">static</literal>. But in the place where we are used to seeing <literal moreinfo="none">void</literal>, we see <literal moreinfo="none">double</literal>, which means that the return value from this method is a <literal moreinfo="none">double</literal>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>The last line is a new form of the <literal moreinfo="none">return</literal> statement that means, “return immediately from this method, and use the following expression as the return value.” The expression you provide can be arbitrarily complex, so we could have written this method more concisely: </para>
<programlisting language="java" format="linespecific">public static double calculateArea(double radius) {
    return Math.PI * radius * radius;
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>On the other hand, <emphasis role="bold">temporary variables</emphasis> like <literal moreinfo="none">result</literal> often make debugging easier, especially when you are stepping through code using an interactive debugger (see <xref linkend="debugger"/>). </para>

  
  <para><xref linkend="fig.param"/> illustrates how data values flows through the program. When the <literal moreinfo="none">main</literal> method invokes <literal moreinfo="none">calculateArea</literal>, the value <literal moreinfo="none">5.0</literal> is assigned to the parameter <literal moreinfo="none">radius</literal>. <literal moreinfo="none">calculateArea</literal> then returns the value <literal moreinfo="none">78.54</literal>, which is assigned to the variable <literal moreinfo="none">area</literal>. </para>

  
  <figure id="fig.param" float="False">
    <title>Passing a parameter and saving the return value.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/param.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

  
  <para>The type of the expression in the <literal moreinfo="none">return</literal> statement must match the return type of the method itself. When you declare that the return type is <literal moreinfo="none">double</literal>, you are making a promise that this method will eventually produce a <literal moreinfo="none">double</literal> value. If you try to <literal moreinfo="none">return</literal> with no expression, or <literal moreinfo="none">return</literal> an expression with the wrong type, the compiler will give an error. </para>

</sect1><sect1 id="distance" remap="section">
  <title>Incremental Development</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>People often make the mistake of writing a lot of code before they try to compile and run it. Then they spend way too much time debugging. A better approach is what we call <emphasis role="bold">incremental development</emphasis>. The key aspects of incremental development are: </para>
<itemizedlist>
  
    <listitem>
  
  <para>Start with a working program and make small, incremental changes. At any point, if there is an error, you will know where to look. </para>
</listitem>
  
    <listitem>
  
  <para>Use variables to hold intermediate values so you can check them, either with print statements or by using a debugger. </para>
</listitem>
  
    <listitem>
  
  <para>Once the program is working, you can consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read). </para>
</listitem>
  
</itemizedlist>
  
  <para>As an example, suppose you want to find the distance between two points, given by the coordinates <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. By the usual definition: </para>

  
  <para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></informalequation></para>

  
  <para>The first step is to consider what a <literal moreinfo="none">distance</literal> method should look like in Java. In other words, what are the inputs (parameters) and what is the output (return value)? For this method, the parameters are the two points, and it is natural to represent them using four <literal moreinfo="none">double</literal> values. The return value is the distance, which should also have type <literal moreinfo="none">double</literal>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Already we can write an outline for the method, which is sometimes called a <emphasis role="bold">stub</emphasis>. The stub includes the method declaration and a <literal moreinfo="none">return</literal> statement: </para>
<programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    return 0.0;  // stub
}</programlisting><para>The return statement is a placeholder that is only necessary for the program to compile. At this stage the program doesn’t do anything useful, but it is good to compile it so we can find any syntax errors before we add more code. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>It’s usually a good idea to think about testing <emphasis>before</emphasis> you develop new methods; doing so can help you figure out how to implement them. To test the method, we can invoke it from <literal moreinfo="none">main</literal> using the sample values: </para>
<programlisting language="java" format="linespecific">double dist = distance(1.0, 2.0, 4.0, 6.0);</programlisting><para>With these values, the horizontal distance is 3.0 and the vertical distance is 4.0. So the result should be 5.0, the hypotenuse of a 3-4-5 triangle. When you are testing a method, it is necessary to know the right answer. </para>

  
  <para>Once we have compiled the stub, we can start adding code one line at a time. After each incremental change, we recompile and run the program. If there is an error, we have a good idea where to look: the lines we just added. </para>

  
  <para>The next step is to find the differences <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation>. We store those values in temporary variables named <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal>, so that we can examine them with print statements before proceeding. They should be 3.0 and 4.0. </para>
<programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    System.out.println("dx is " + dx);
    System.out.println("dy is " + dy);
    return 0.0;  // stub
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm>We will remove the print statements when the method is finished. Code like that is called <emphasis role="bold">scaffolding</emphasis>, because it is helpful for building the program, but it is not part of the final product. </para>

  
  <para>The next step is to square <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal>. We could use the <literal moreinfo="none">Math.pow</literal> method, but it is simpler (and more efficient) to multiply each term by itself. </para>

  
  <para>Then we add the squares and print the result so far. </para>
<programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    System.out.println("dsquared is " + dsquared);
    return 0.0;  // stub
}</programlisting><para>Again, you should compile and run the program at this stage and check the intermediate value, which should be 25.0. Finally, we can use <literal moreinfo="none">Math.sqrt</literal> to compute and return the result. </para>
<programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    double result = Math.sqrt(dsquared);
    return result;
}</programlisting><para>As you gain more experience programming, you might write and debug more than one line at a time. But if you find yourself spending a lot of time debugging, consider taking smaller steps. </para>

</sect1><sect1 id="a0000003250" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>void:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A special return type indicating the method does not return a value. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>invoke:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>To cause a method to execute. Also known as “calling” a method. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>flow of execution:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The order in which Java executes methods and statements. It may not necessarily be from top to bottom in the source file. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>argument:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A value that you provide when you call a method. This value must have the type that the method expects. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>parameter:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A piece of information that a method requires before it can run. Parameters are variables: they contain values and have types. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>parameter passing:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The process of assigning an argument value to a parameter variable. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>local variable:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A variable declared inside a method. Local variables cannot be accessed from outside their method. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>stack diagram:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A graphical representation of the variables belonging to each method. The method calls are “stacked” from top to bottom, in the flow of execution. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>frame:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>In a stack diagram, a representation of the variables and parameters for a method, along with their current values. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>scope:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The area of a program where a variable can be used. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>composition:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The ability to combine simple expressions and statements into compound expressions and statements. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>return type:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The type of value a method returns. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>return value:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The value provided as the result of a method invocation. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>temporary variable:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A short-lived variable, often used for debugging. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>incremental development:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A process for creating programs by writing a few lines at a time, compiling, and testing. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>stub:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A placeholder for an incomplete method so that the class will compile. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>scaffolding:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Code that is used during program development but is not part of the final version. </para>
</listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000003304" remap="section">
  <title>Exercises</title>
    
  
  <para>The code for this chapter is in the <literal moreinfo="none">ch04</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para>

  
  <para>If you have not already read <xref linkend="cltesting"/>, now might be a good time. It describes an efficient way to test programs that take input from the user and display specific output. </para>

  
  <para><example id="a0000003316" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>The purpose of this exercise is to take code from a previous exercise and redesign it as a method that takes parameters. You should start with a working solution to <xref linkend="ex..date"/>. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Write a method called <literal moreinfo="none">printAmerican</literal> that takes the day, date, month and year as parameters and that displays them in American format. </para>
</listitem>
  
  <listitem>
  
  <para>Test your method by invoking it from <literal moreinfo="none">main</literal> and passing appropriate arguments. The output should look something like this (except that the date might be different): </para><programlisting format="linespecific">Saturday, July 22, 2015</programlisting></listitem>
  
  <listitem>
  
  <para>Once you have debugged <literal moreinfo="none">printAmerican</literal>, write another method called <literal moreinfo="none">printEuropean</literal> that displays the date in European format. </para>
</listitem>
  
</orderedlist><para><example id="a0000003343" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000003345" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>This exercise reviews the flow of execution through a program with multiple methods. Read the following code and answer the questions. </para>
<programlisting language="java" format="linespecific">public static void main(String[] args) {
    zippo("rattle", 13);
}</programlisting><programlisting language="java" format="linespecific">public static void baffle(String blimp) {
    System.out.println(blimp);
    zippo("ping", -5);
}</programlisting><programlisting language="java" format="linespecific">public static void zippo(String quince, int flag) {
    if (flag &lt; 0) {
        System.out.println(quince + " zoop");
    } else {
        System.out.println("ik");
        baffle(quince);
        System.out.println("boo-wa-ha-ha");
    }
}</programlisting><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Write the number <literal moreinfo="none">1</literal> next to the first line of code in this program that will execute. </para>
</listitem>
  
  <listitem>
  
  <para>Write the number <literal moreinfo="none">2</literal> next to the second line of code, and so on until the end of the program. If a line is executed more than once, it might end up with more than one number next to it. </para>
</listitem>
  
  <listitem>
  
  <para>What is the value of the parameter <literal moreinfo="none">blimp</literal> when <literal moreinfo="none">baffle</literal> gets invoked? </para>
</listitem>
  
  <listitem>
  
  <para>What is the output of this program? </para>
</listitem>
  
</orderedlist>
  
  <para><example id="a0000003372" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000003374" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>Answer the following questions without running the program on a computer. </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Draw a stack diagram that shows the state of the program the first time <literal moreinfo="none">ping</literal> is invoked. </para>
</listitem>
  
  <listitem>
  
  <para>What is output by the following program? Be precise about where there are spaces and where there are newlines. </para>
</listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static void zoop() {
    baffle();
    System.out.print("You wugga ");
    baffle();
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    System.out.print("No, I ");
    zoop();
    System.out.print("I ");
    baffle();
}</programlisting><programlisting language="java" format="linespecific">public static void baffle() {
    System.out.print("wug");
    ping();
}</programlisting><programlisting language="java" format="linespecific">public static void ping() {
    System.out.println(".");
}</programlisting><para><example id="a0000003393" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000003395" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>If you have a question about whether something is legal, and what happens if it is not, a good way to find out is to ask the compiler. Answer the following questions by trying them out. </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>What happens if you invoke a value method and don’t do anything with the result; that is, if you don’t assign it to a variable or use it as part of a larger expression? </para>
</listitem>
  
  <listitem>
  
  <para>What happens if you use a void method as part of an expression? For example, try <literal moreinfo="none">System.out.println("boo!") + 7;</literal> </para>
</listitem>
  
</orderedlist>
  
  <para><example id="a0000003406" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000003408" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>Draw a stack diagram that shows the state of the program the <emphasis>second</emphasis> time <literal moreinfo="none">zoop</literal> is invoked. What is the complete output? </para>
<programlisting language="java" format="linespecific">public static void zoop(String fred, int bob) {
    System.out.println(fred);
    if (bob == 5) {
        ping("not ");
    } else {
        System.out.println("!");
    }
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    int bizz = 5;
    int buzz = 2;
    zoop("just for", bizz);
    clink(2 * buzz);
}</programlisting><programlisting language="java" format="linespecific">public static void clink(int fork) {
    System.out.print("It's ");
    zoop("breakfast ", fork);
}</programlisting><programlisting language="java" format="linespecific">public static void ping(String strangStrung) {
    System.out.println("any " + strangStrung + "more ");
}</programlisting><para><example id="a0000003423" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000003425" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>Many computations can be expressed more concisely using the “multadd” operation, which takes three operands and computes <literal moreinfo="none">a * b + c</literal>. Some processors even provide a hardware implementation of this operation for floating-point numbers. </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Create a new program called <literal moreinfo="none">Multadd.java</literal>. </para>
</listitem>
  
  <listitem>
  
  <para>Write a method called <literal moreinfo="none">multadd</literal> that takes three <literal moreinfo="none">doubles</literal> as parameters and that returns <literal moreinfo="none">a * b + c</literal>. </para>
</listitem>
  
  <listitem>
  
  <para>Write a <literal moreinfo="none">main</literal> method that tests <literal moreinfo="none">multadd</literal> by invoking it with a few simple parameters, like <literal moreinfo="none">1.0, 2.0, 3.0</literal>. </para>
</listitem>
  
  <listitem>
  
  <para>Also in <literal moreinfo="none">main</literal>, use <literal moreinfo="none">multadd</literal> to compute the following values: </para>

  
  <para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo form="prefix">cos</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:mtd><mml:mtd></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mn>10</mml:mn><mml:mo>+</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation></para>
</listitem>
  
  <listitem>
  
  <para>Write a method called <literal moreinfo="none">expSum</literal> that takes a double as a parameter and that uses <literal moreinfo="none">multadd</literal> to calculate: </para>

  
  <para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>x</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation></para>

  
  <para> <emphasis>Hint:</emphasis> The method for raising <emphasis role="math">e</emphasis> to a power is <literal moreinfo="none">Math.exp</literal>. </para>
</listitem>
  
</orderedlist>
  
  <para>In the last part of this exercise, you need to write a method that invokes another method you wrote. Whenever you do that, it is a good idea to test the first method carefully before working on the second. Otherwise, you might find yourself debugging two methods at the same time, which can be difficult. </para>

  
  <para>One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems. </para>

  
  <para><example id="a0000003502" role="exercise">
  <title/>
  <div></div>
</example> </para>

</sect1>
</chapter>
