<chapter id="a0000001914">
  <title>Methods and Testing</title>
  <para>So far we’ve written programs that have only one method named <literal remap="verb" moreinfo="none">main</literal>. In this chapter, we’ll show you how to organize programs into multiple methods. We’ll also take a look at the <literal remap="verb" moreinfo="none">Math</literal> class, which provides methods for common mathematical operations. Finally, we’ll discuss strategies for incrementally developing and testing your code. </para><sect1 id="adding_methods" remap="section">
  <title>Defining New Methods</title><para>Some methods perform a computation and return a result. For example, <literal remap="verb" moreinfo="none">nextDouble</literal> reads input from the keyboard and returns it as a <literal remap="verb" moreinfo="none">double</literal>. Other methods, like <literal remap="verb" moreinfo="none">println</literal>, carry out a sequence of actions without returning a result. Java uses the keyword <literal remap="verb" moreinfo="none">void</literal> to define such methods. </para><programlisting language="java" format="linespecific">public static void newLine() {
    System.out.println();
}

public static void main(String[] args) {
    System.out.println("First line.");
    newLine();
    System.out.println("Second line.");
}</programlisting><para><indexterm significance="normal">
  <primary>public</primary>

</indexterm><indexterm significance="normal">
  <primary>invoke</primary>

</indexterm><indexterm significance="normal">
  <primary>void</primary>

</indexterm><indexterm significance="normal">
  <primary>type</primary>
<secondary>void</secondary>
</indexterm>In this example, the <literal remap="verb" moreinfo="none">newLine</literal> and <literal remap="verb" moreinfo="none">main</literal> methods are both <literal remap="verb" moreinfo="none">public</literal>, which means they can be <emphasis role="bold">invoked</emphasis> (or called) from other classes. And they are both <literal remap="verb" moreinfo="none">void</literal>, which means that they don’t return a result (in contrast to <literal remap="verb" moreinfo="none">nextDouble</literal>). The output of the program is: </para><programlisting format="linespecific">First line.

Second line.</programlisting><para><indexterm significance="normal">
  <primary>NewLine.java</primary>

</indexterm>Notice the extra space between the lines. If we wanted more space between them, we could invoke the same method repeatedly. Or we could write yet another method (named <literal remap="verb" moreinfo="none">threeLine</literal>) that displays three blank lines. </para><programlisting language="java" format="linespecific">public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}</programlisting><para><indexterm significance="normal">
  <primary>main</primary>

</indexterm><indexterm significance="normal">
  <primary>case-sensitive</primary>

</indexterm>In this example, the name of the class is <literal remap="verb" moreinfo="none">NewLine</literal>. By convention, class names begin with a capital letter. <literal remap="verb" moreinfo="none">NewLine</literal> contains three methods, <literal remap="verb" moreinfo="none">newLine</literal>, <literal remap="verb" moreinfo="none">threeLine</literal>, and <literal remap="verb" moreinfo="none">main</literal>. Remember that Java is case-sensitive, so <literal remap="verb" moreinfo="none">NewLine</literal> and <literal remap="verb" moreinfo="none">newLine</literal> are not the same. </para><para><indexterm significance="normal">
  <primary>camel case</primary>

</indexterm>By convention, method names begin with a lowercase letter and use “camel case”, which is a cute name for <literal remap="verb" moreinfo="none">jammingWordsTogetherLikeThis</literal>. You can use any name you want for methods, except <literal remap="verb" moreinfo="none">main</literal> or any of the Java keywords. </para>
</sect1><sect1 id="a0000001956" remap="section">
  <title>Flow of Execution</title>
    <para><indexterm significance="normal">
  <primary>flow of execution</primary>

</indexterm>When you look at a class definition that contains several methods, it is tempting to read it from top to bottom. But that is <emphasis>not</emphasis> the <emphasis role="bold">flow of execution</emphasis>, or the order the program actually runs. The <literal remap="verb" moreinfo="none">NewLine</literal> program runs methods in the opposite order than they are listed. </para><para>Programs always begin at the first statement of <literal remap="verb" moreinfo="none">main</literal>, regardless of where it is in the source file. Statements are executed one at a time, in order, until you reach a method invocation, which you can think of as a detour. Instead of going to the next statement, you jump to the first line of the invoked method, execute all the statements there, and then come back and pick up exactly where you left off. </para><para>That sounds simple enough, but remember that one method can invoke another one. In the middle of <literal remap="verb" moreinfo="none">main</literal>, the previous example goes off to execute the statements in <literal remap="verb" moreinfo="none">threeLine</literal>. While in <literal remap="verb" moreinfo="none">threeLine</literal>, it goes off to execute <literal remap="verb" moreinfo="none">newLine</literal>. Then <literal remap="verb" moreinfo="none">newLine</literal> invokes <literal remap="verb" moreinfo="none">println</literal>, which causes yet another detour. </para><para>Fortunately, Java is good at keeping track of which methods are running. So when <literal remap="verb" moreinfo="none">println</literal> completes, it picks up where it left off in <literal remap="verb" moreinfo="none">newLine</literal>; when <literal remap="verb" moreinfo="none">newLine</literal> completes, it goes back to <literal remap="verb" moreinfo="none">threeLine</literal>; and when <literal remap="verb" moreinfo="none">threeLine</literal> completes, it gets back to <literal remap="verb" moreinfo="none">main</literal>. </para><para>Beginners often wonder why it’s worth the trouble to write other methods, when they could just do everything in <literal remap="verb" moreinfo="none">main</literal>. The <literal remap="verb" moreinfo="none">NewLine</literal> example demonstrates a few reasons: </para><itemizedlist>
  
    <listitem><para>Creating a new method allows you to <emphasis>name a block of statements</emphasis>, which makes the code easier to read and understand. </para></listitem>
  
    <listitem><para>Introducing new methods can <emphasis>make the program shorter</emphasis> by eliminating repetitive code. For example, to display nine consecutive newlines, you could invoke <literal remap="verb" moreinfo="none">threeLine</literal> three times. </para></listitem>
  
    <listitem><para>A common problem-solving technique is to <emphasis>break problems down</emphasis> into sub-problems. Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution. </para></listitem>
  
</itemizedlist><para>Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately. It’s easier to get a complex program working if you know that each method works correctly. </para>
</sect1><sect1 id="a0000001999" remap="section">
  <title>Parameters and Arguments</title>
    <para>Some of the methods we have used require <emphasis role="bold">arguments</emphasis>, which are the values you provide in parentheses when you invoke the method. </para><para>For example, the <literal remap="verb" moreinfo="none">println</literal> method takes a <literal remap="verb" moreinfo="none">String</literal> argument. To display a message, you have to provide the message: <literal remap="verb" moreinfo="none">System.out.println("Hello")</literal>. Similarly, the <literal remap="verb" moreinfo="none">printf</literal> method can take multiple arguments. The statement <literal remap="verb" moreinfo="none">System.out.printf("\%d in = \%f cm\\n", inch, cm)</literal> has three arguments: the format string, the <literal remap="verb" moreinfo="none">inch</literal> value, and the <literal remap="verb" moreinfo="none">cm</literal> value. </para><para><indexterm significance="normal">
  <primary>PrintTwice.java</primary>

</indexterm><indexterm significance="normal">
  <primary>parameter</primary>

</indexterm><indexterm significance="normal">
  <primary>argument</primary>

</indexterm>When you invoke a method, you provide the arguments. When you define a method, you name the <emphasis role="bold">parameters</emphasis>, which are variables that indicate what arguments are required. The following class shows an example: </para><programlisting language="java" format="linespecific">public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        printTwice("Don't make me say this twice!");
    }
}</programlisting><para>The <literal remap="verb" moreinfo="none">printTwice</literal> method has a parameter named <literal remap="verb" moreinfo="none">s</literal> with type <literal remap="verb" moreinfo="none">String</literal>. When you invoke <literal remap="verb" moreinfo="none">printTwice</literal>, you have to provide an argument with type <literal remap="verb" moreinfo="none">String</literal>. </para><para>Before the method executes, the argument gets assigned to the parameter. In the <literal remap="verb" moreinfo="none">printTwice</literal> example, the argument <literal remap="verb" moreinfo="none">"Don't make me say this twice!"</literal> gets assigned to the parameter <literal remap="verb" moreinfo="none">s</literal>. </para><para><indexterm significance="normal">
  <primary>parameter passing</primary>

</indexterm>This process is called <emphasis role="bold">parameter passing</emphasis>, because the value gets passed from outside the method to the inside. An argument can be any kind of expression, so if you have a <literal remap="verb" moreinfo="none">String</literal> variable, you can use its value as an argument: </para><programlisting language="java" format="linespecific">String message = "Never say never.";
printTwice(message);</programlisting><para>The value you provide as an argument must have the same (or compatible) type as the parameter. For example, if you try: </para><programlisting language="java" format="linespecific">printTwice(17);  // syntax error</programlisting><para>You will get an error message like this: </para><programlisting format="linespecific">File: Test.java  [line: 10]
Error: method printTwice in class Test cannot be applied
       to given types;
  required: java.lang.String
  found: int
  reason: actual argument int cannot be converted to
          java.lang.String by method invocation conversion</programlisting><para>This error message says that it found an <literal remap="verb" moreinfo="none">int</literal> argument, but the required parameter should be a <literal remap="verb" moreinfo="none">String</literal>. In the case of <literal remap="verb" moreinfo="none">printTwice</literal>, Java won’t convert the integer <literal remap="verb" moreinfo="none">17</literal> to the string <literal remap="verb" moreinfo="none">"17"</literal> automatically. </para><para><indexterm significance="normal">
  <primary>automatic conversion</primary>

</indexterm>Sometimes Java can convert an argument from one type to another automatically. For example, <literal remap="verb" moreinfo="none">Math.sqrt</literal> requires a <literal remap="verb" moreinfo="none">double</literal>, but if you invoke <literal remap="verb" moreinfo="none">Math.sqrt(25)</literal>, the integer value <literal remap="verb" moreinfo="none">25</literal> is automatically converted to the floating-point value <literal remap="verb" moreinfo="none">25.0</literal>. </para><para><indexterm significance="normal">
  <primary>local variable</primary>

</indexterm><indexterm significance="normal">
  <primary>variable</primary>
<secondary>local</secondary>
</indexterm>Parameters and other variables only exist inside their own methods. In the <literal remap="verb" moreinfo="none">printTwice</literal> example, there is no such thing as <literal remap="verb" moreinfo="none">s</literal> in the <literal remap="verb" moreinfo="none">main</literal> method. If you try to use it there, you’ll get a compiler error. </para><para>Similarly, inside <literal remap="verb" moreinfo="none">printTwice</literal> there is no such thing as <literal remap="verb" moreinfo="none">message</literal>. That variable belongs to <literal remap="verb" moreinfo="none">main</literal>. Because variables only exist inside the methods where they are defined, they are often called <emphasis role="bold">local variables</emphasis>. </para>
</sect1><sect1 id="multparam" remap="section">
  <title>Multiple Parameters</title><para><indexterm significance="normal">
  <primary>parameter</primary>
<secondary>multiple</secondary>
</indexterm><indexterm significance="normal">
  <primary>method</primary>
<secondary>parameters</secondary>
</indexterm>Here is an example of a method that takes two parameters: </para><programlisting language="java" format="linespecific">public static void printTime(int hour, int minute) {
    System.out.print(hour);
    System.out.print(":");
    System.out.println(minute);
}</programlisting><para>To invoke this method, we have to provide two integers as arguments: </para><programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(hour, minute);</programlisting><para>Beginners sometimes make the mistake of “declaring” the arguments: </para><programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(int hour, int minute);  // syntax error</programlisting><para>That’s a syntax error, because the compiler sees <literal remap="verb" moreinfo="none">int hour</literal> and <literal remap="verb" moreinfo="none">int minute</literal> as variable declarations, not expressions that represent values. You wouldn’t declare the types of the arguments if they were simply integers: </para><programlisting language="java" format="linespecific">printTime(int 11, int 59);  // syntax error</programlisting><para><indexterm significance="normal">
  <primary>PrintTime.java</primary>

</indexterm>Pulling together the code fragments, here is the complete program: </para><programlisting language="java" format="linespecific">public class PrintTime {

    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }

    public static void main(String[] args) {
        int hour = 11;
        int minute = 59;
        printTime(hour, minute);
    }
}</programlisting><para><literal remap="verb" moreinfo="none">printTime</literal> has two parameters, named <literal remap="verb" moreinfo="none">hour</literal> and <literal remap="verb" moreinfo="none">minute</literal>. And <literal remap="verb" moreinfo="none">main</literal> has two variables, also named <literal remap="verb" moreinfo="none">hour</literal> and <literal remap="verb" moreinfo="none">minute</literal>. Although they have the same names, these variables are <emphasis>not</emphasis> the same. The <literal remap="verb" moreinfo="none">hour</literal> in <literal remap="verb" moreinfo="none">printTime</literal> and the <literal remap="verb" moreinfo="none">hour</literal> in <literal remap="verb" moreinfo="none">main</literal> refer to different memory locations, and they can have different values. For example, you could invoke <literal remap="verb" moreinfo="none">printTime</literal> like this: </para><programlisting language="java" format="linespecific">int hour = 11;
int minute = 59;
printTime(hour + 1, 0);</programlisting><para>Before the method is invoked, Java evaluates the arguments; in this example, the results are <literal remap="verb" moreinfo="none">12</literal> and <literal remap="verb" moreinfo="none">0</literal>. Then it assigns those values to the parameters. Inside <literal remap="verb" moreinfo="none">printTime</literal>, the value of <literal remap="verb" moreinfo="none">hour</literal> is <literal remap="verb" moreinfo="none">12</literal>, not <literal remap="verb" moreinfo="none">11</literal>, and the value of <literal remap="verb" moreinfo="none">minute</literal> is <literal remap="verb" moreinfo="none">0</literal>, not <literal remap="verb" moreinfo="none">59</literal>. Furthermore, if <literal remap="verb" moreinfo="none">printTime</literal> modifies one of its parameters, that change has no effect on the variables in <literal remap="verb" moreinfo="none">main</literal>. </para>
</sect1><sect1 id="stack" remap="section">
  <title>Stack Diagrams</title><para><indexterm significance="normal">
  <primary>stack diagram</primary>

</indexterm><indexterm significance="normal">
  <primary>diagram</primary>
<secondary>stack</secondary>
</indexterm><indexterm significance="normal">
  <primary>frame</primary>

</indexterm>One way to keep track of variables is to draw a <emphasis role="bold">stack diagram</emphasis>, which is a memory diagram (see <xref linkend="state"/>) that shows currently running methods. For each method there is a box, called a <emphasis role="bold">frame</emphasis>, that contains the method’s parameters and local variables. The name of the method appears outside the frame; the variables and parameters appear inside. </para>
  
  <figure id="fig.stack" float="False">
    <title>Stack diagram for <literal remap="verb" moreinfo="none">printTime(hour + 1, 0).</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack1.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>As with memory diagrams, stack diagrams show variables and methods at a particular point in time. <xref linkend="fig.stack"/> is a stack diagram at the beginning of the <literal remap="verb" moreinfo="none">printTime</literal> method. Notice that <literal remap="verb" moreinfo="none">main</literal> is on top, because it executed first. </para><para><indexterm significance="normal">
  <primary>scope</primary>

</indexterm>Stack diagrams help you to visualize the <emphasis role="bold">scope</emphasis> of a variable, which is the area of a program where a variable can be used. </para><para><indexterm significance="normal">
  <primary>Java Tutor</primary>

</indexterm><indexterm significance="normal">
  <primary>tracing</primary>

</indexterm>Stack diagrams are a good mental model for how variables and methods work at run-time. Learning to trace the execution of a program on paper (or on a whiteboard) is a useful skill for communicating with other programmers. </para><para>There are educational tools that automatically draw stack diagrams for you. For example, Java Tutor (<ulink url="https://thinkjava.org/javatutor"/>) allows you to step through an entire program, both forwards and backwards, and see the stack frames and variables at each step. If you haven’t already, you should check out the Java examples on that website. </para>
</sect1><sect1 id="a0000002145" remap="section">
  <title>Math Methods</title>
    <para><indexterm significance="normal">
  <primary>Math class</primary>

</indexterm><indexterm significance="normal">
  <primary>class</primary>
<secondary>Math</secondary>
</indexterm>You don’t always have to write new methods to get work done. As a reminder, the Java library contains thousands of classes you can use. For example, the <literal remap="verb" moreinfo="none">Math</literal> class provides common mathematical operations. </para><programlisting language="java" format="linespecific">double root = Math.sqrt(17.0);
double angle = 1.5;
double height = Math.sin(angle);</programlisting><para>The first line sets <literal remap="verb" moreinfo="none">root</literal> to the square root of 17. The third line finds the sine of 1.5 (the value of <literal remap="verb" moreinfo="none">angle</literal>). <literal remap="verb" moreinfo="none">Math</literal> is in the <literal remap="verb" moreinfo="none">java.lang</literal> package, so you don’t have to import it. </para><para><indexterm significance="normal">
  <primary>degrees</primary>

</indexterm><indexterm significance="normal">
  <primary>radians</primary>

</indexterm><indexterm significance="normal">
  <primary>pi</primary>

</indexterm>Values for the trigonometric functions – <literal remap="verb" moreinfo="none">sin</literal>, <literal remap="verb" moreinfo="none">cos</literal>, and <literal remap="verb" moreinfo="none">tan</literal> – must be in <emphasis>radians</emphasis>. To convert from degrees to radians, you can divide by 180 and multiply by <emphasis role="math">π</emphasis>. Conveniently, the <literal remap="verb" moreinfo="none">Math</literal> class provides a constant named <literal remap="verb" moreinfo="none">PI</literal> that contains an approximation of <emphasis role="math">π</emphasis>: </para><programlisting language="java" format="linespecific">double degrees = 90;
double angle = degrees / 180.0 * Math.PI;</programlisting><para>Notice that <literal remap="verb" moreinfo="none">PI</literal> is in capital letters. Java does not recognize <literal remap="verb" moreinfo="none">Pi</literal>, <literal remap="verb" moreinfo="none">pi</literal>, or <literal remap="verb" moreinfo="none">pie</literal>. Also, <literal remap="verb" moreinfo="none">PI</literal> is the name of a variable, not a method, so it doesn’t have parentheses. The same is true for the constant <literal remap="verb" moreinfo="none">Math.E</literal>, which approximates Euler’s number. </para><para>Converting to and from radians is a common operation, so the <literal remap="verb" moreinfo="none">Math</literal> class provides methods that do that for you. </para><programlisting language="java" format="linespecific">double radians = Math.toRadians(180.0);
double degrees = Math.toDegrees(Math.PI);</programlisting><para><indexterm significance="normal">
  <primary>long</primary>

</indexterm><indexterm significance="normal">
  <primary>type</primary>
<secondary>long</secondary>
</indexterm>Another useful method is <literal remap="verb" moreinfo="none">round</literal>, which rounds a floating-point value to the nearest integer and returns a <literal remap="verb" moreinfo="none">long</literal>. The following result is 63 (rounded up from 62.8319). </para><programlisting language="java" format="linespecific">long x = Math.round(Math.PI * 20.0);</programlisting><para>A <literal remap="verb" moreinfo="none">long</literal> is like an <literal remap="verb" moreinfo="none">int</literal>, but bigger. More specifically, an <literal remap="verb" moreinfo="none">int</literal> uses 32 bits of memory; the largest value it can hold is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>31</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 2 billion. A <literal remap="verb" moreinfo="none">long</literal> uses 64 bits, so the largest value is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>63</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 9 quintillion. </para><para>Take a minute to read the documentation for these and other methods in the <literal remap="verb" moreinfo="none">Math</literal> class. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>
</sect1><sect1 id="a0000002199" remap="section">
  <title>Composition</title>
    <para><indexterm significance="normal">
  <primary>expression</primary>

</indexterm><indexterm significance="normal">
  <primary>argument</primary>

</indexterm>You have probably learned how to evaluate simple expressions like <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First, you evaluate the expression in parentheses, which is the argument of the function. Then you can evaluate the function itself, either by hand or by punching it into a calculator. </para><para>This process can be applied repeatedly to evaluate more complex expressions like <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First we evaluate the argument of the innermost function (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn></mml:mrow></mml:math></inlineequation>), then evaluate the function itself (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inlineequation>), and so on. </para><para><indexterm significance="normal">
  <primary>composition</primary>

</indexterm><indexterm significance="normal">
  <primary>expression</primary>

</indexterm>Just as with mathematical functions, Java methods can be <emphasis role="bold">composed</emphasis> to solve complex problems. That means you can use one method as part of another. In fact, you can use any expression as an argument to a method, as long as the resulting value has the correct type: </para><programlisting language="java" format="linespecific">double x = Math.cos(angle + Math.PI / 2.0);</programlisting><para>This statement divides <literal remap="verb" moreinfo="none">Math.PI</literal> by two, adds the result to <literal remap="verb" moreinfo="none">angle</literal>, and computes the cosine of the sum. You can also take the result of one method and pass it as an argument to another: </para><programlisting language="java" format="linespecific">double x = Math.exp(Math.log(10.0));</programlisting><para>In Java, the <literal remap="verb" moreinfo="none">log</literal> method always uses base <emphasis role="math">e</emphasis>. So this statement finds the log base <emphasis role="math">e</emphasis> of 10, and then raises <emphasis role="math">e</emphasis> to that power. The result gets assigned to <literal remap="verb" moreinfo="none">x</literal>. </para><para>Some math methods take more than one argument. For example, <literal remap="verb" moreinfo="none">Math.pow</literal> takes two arguments and raises the first to the power of the second. This line computes <emphasis role="math">2<superscript>10</superscript></emphasis> and assigns the value <literal remap="verb" moreinfo="none">1024.0</literal> to the variable <literal remap="verb" moreinfo="none">x</literal>: </para><programlisting language="java" format="linespecific">double x = Math.pow(2.0, 10.0);</programlisting><para>When using <literal remap="verb" moreinfo="none">Math</literal> methods, beginners often forget the word <literal remap="verb" moreinfo="none">Math</literal>. For example, if you just write <literal remap="verb" moreinfo="none">x = pow(2.0, 10.0)</literal>, you will get a compiler error: </para><programlisting format="linespecific">File: Test.java  [line: 5]
Error: cannot find symbol
  symbol:   method pow(double,double)
  location: class Test</programlisting><para>The message “cannot find symbol” is confusing, but the last two lines provide a useful hint. The compiler is looking for a method named <literal remap="verb" moreinfo="none">pow</literal> in the file <literal remap="verb" moreinfo="none">Test.java</literal> (the file for this example). If you don’t specify a class name when referring to a method, the compiler looks in the current class by default. </para>
</sect1><sect1 id="a0000002250" remap="section">
  <title>Return Values</title>
    <para><indexterm significance="normal">
  <primary>void</primary>

</indexterm>When you invoke a <literal remap="verb" moreinfo="none">void</literal> method, the invocation is usually on a line all by itself. For example: </para><programlisting language="java" format="linespecific">printTime(hour + 1, 0);</programlisting><para>On the other hand, when you invoke a value-returning method, you have to do something with the return value. We usually assign it to a variable or use it as part of an expression, like this: </para><programlisting language="java" format="linespecific">double error = Math.abs(expect - actual);
double height = radius * Math.sin(angle);</programlisting><para><indexterm significance="normal">
  <primary>return type</primary>

</indexterm><indexterm significance="normal">
  <primary>return value</primary>

</indexterm><indexterm significance="normal">
  <primary>value method</primary>

</indexterm><indexterm significance="normal">
  <primary>method</primary>
<secondary>value</secondary>
</indexterm>Compared to <literal remap="verb" moreinfo="none">void</literal> methods, value-returning methods differ in two ways: </para><itemizedlist>
  
    <listitem><para>They declare the type of the return value (the <emphasis role="bold">return type</emphasis>); </para></listitem>
  
    <listitem><para>They use at least one <literal remap="verb" moreinfo="none">return</literal> statement to provide a <emphasis role="bold">return value</emphasis>. </para></listitem>
  
</itemizedlist><para>Here’s an example from a program named <literal moreinfo="none">Circle.java</literal>. The <literal remap="verb" moreinfo="none">calculateArea</literal> method takes a <literal remap="verb" moreinfo="none">double</literal> as a parameter and returns the area of a circle with that radius (i.e., <emphasis role="math">πr<superscript>2</superscript></emphasis>). </para><programlisting language="java" format="linespecific">public static double calculateArea(double radius) {
    double result = Math.PI * radius * radius;
    return result;
}</programlisting><para>As usual, this method is <literal remap="verb" moreinfo="none">public</literal> and <literal remap="verb" moreinfo="none">static</literal>. But in the place where we are used to seeing <literal remap="verb" moreinfo="none">void</literal>, we see <literal remap="verb" moreinfo="none">double</literal>, which means that the return value from this method is a <literal remap="verb" moreinfo="none">double</literal>. </para><para><indexterm significance="normal">
  <primary>return</primary>

</indexterm><indexterm significance="normal">
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>The last line is a new form of the <literal remap="verb" moreinfo="none">return</literal> statement that means, “return immediately from this method, and use the following expression as the return value.” The expression you provide can be arbitrarily complex, so we could have written this method more concisely: </para><programlisting language="java" format="linespecific">public static double calculateArea(double radius) {
    return Math.PI * radius * radius;
}</programlisting><para><indexterm significance="normal">
  <primary>temporary variable</primary>

</indexterm><indexterm significance="normal">
  <primary>variable</primary>
<secondary>temporary</secondary>
</indexterm>On the other hand, <emphasis role="bold">temporary variables</emphasis> like <literal remap="verb" moreinfo="none">result</literal> often make debugging easier, especially when you are stepping through code using an interactive debugger (see <xref linkend="debugger"/>). </para><para><xref linkend="fig.param"/> illustrates how data values flows through the program. When the <literal remap="verb" moreinfo="none">main</literal> method invokes <literal remap="verb" moreinfo="none">calculateArea</literal>, the value <literal remap="verb" moreinfo="none">5.0</literal> is assigned to the parameter <literal remap="verb" moreinfo="none">radius</literal>. <literal remap="verb" moreinfo="none">calculateArea</literal> then returns the value <literal remap="verb" moreinfo="none">78.54</literal>, which is assigned to the variable <literal remap="verb" moreinfo="none">area</literal>. </para>
  
  <figure id="fig.param" float="False">
    <title>Passing a parameter and saving the return value.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/param.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The type of the expression in the <literal remap="verb" moreinfo="none">return</literal> statement must match the return type of the method itself. When you declare that the return type is <literal remap="verb" moreinfo="none">double</literal>, you are making a promise that this method will eventually produce a <literal remap="verb" moreinfo="none">double</literal> value. If you try to <literal remap="verb" moreinfo="none">return</literal> with no expression, or <literal remap="verb" moreinfo="none">return</literal> an expression with the wrong type, the compiler will give an error. </para>
</sect1><sect1 id="distance" remap="section">
  <title>Incremental Development</title><para><indexterm significance="normal">
  <primary>incremental development</primary>

</indexterm><indexterm significance="normal">
  <primary>design process</primary>

</indexterm>People often make the mistake of writing a lot of code before they try to compile and run it. Then they spend way too much time debugging. A better approach is what we call <emphasis role="bold">incremental development</emphasis>. The key aspects of incremental development are: </para><itemizedlist>
  
    <listitem><para>Start with a working program and make small, incremental changes. At any point, if there is an error, you will know where to look. </para></listitem>
  
    <listitem><para>Use variables to hold intermediate values so you can check them, either with print statements or by using a debugger. </para></listitem>
  
    <listitem><para>Once the program is working, you can consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read). </para></listitem>
  
</itemizedlist><para>As an example, suppose you want to find the distance between two points, given by the coordinates <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. By the usual definition: </para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></informalequation><para>The first step is to consider what a <literal remap="verb" moreinfo="none">distance</literal> method should look like in Java. In other words, what are the inputs (parameters) and what is the output (return value)? For this method, the parameters are the two points, and it is natural to represent them using four <literal remap="verb" moreinfo="none">double</literal> values. The return value is the distance, which should also have type <literal remap="verb" moreinfo="none">double</literal>. </para><para><indexterm significance="normal">
  <primary>stub</primary>

</indexterm>Already we can write an outline for the method, which is sometimes called a <emphasis role="bold">stub</emphasis>. The stub includes the method declaration and a <literal remap="verb" moreinfo="none">return</literal> statement: </para><programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    return 0.0;  // stub
}</programlisting><para>The return statement is a placeholder that is only necessary for the program to compile. At this stage the program doesn’t do anything useful, but it is good to compile it so we can find any syntax errors before we add more code. </para><para><indexterm significance="normal">
  <primary>testing</primary>

</indexterm>It’s usually a good idea to think about testing <emphasis>before</emphasis> you develop new methods; doing so can help you figure out how to implement them. To test the method, we can invoke it from <literal remap="verb" moreinfo="none">main</literal> using the sample values: </para><programlisting language="java" format="linespecific">double dist = distance(1.0, 2.0, 4.0, 6.0);</programlisting><para>With these values, the horizontal distance is 3.0 and the vertical distance is 4.0. So the result should be 5.0, the hypotenuse of a 3-4-5 triangle. When you are testing a method, it is necessary to know the right answer. </para><para>Once we have compiled the stub, we can start adding code one line at a time. After each incremental change, we recompile and run the program. If there is an error, we have a good idea where to look: the lines we just added. </para><para>The next step is to find the differences <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation>. We store those values in temporary variables named <literal remap="verb" moreinfo="none">dx</literal> and <literal remap="verb" moreinfo="none">dy</literal>, so that we can examine them with print statements before proceeding. They should be 3.0 and 4.0. </para><programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    System.out.println("dx is " + dx);
    System.out.println("dy is " + dy);
    return 0.0;  // stub
}</programlisting><para><indexterm significance="normal">
  <primary>scaffolding</primary>

</indexterm>We will remove the print statements when the method is finished. Code like that is called <emphasis role="bold">scaffolding</emphasis>, because it is helpful for building the program, but it is not part of the final product. </para><para>The next step is to square <literal remap="verb" moreinfo="none">dx</literal> and <literal remap="verb" moreinfo="none">dy</literal>. We could use the <literal remap="verb" moreinfo="none">Math.pow</literal> method, but it is simpler (and more efficient) to multiply each term by itself. </para><para>Then we add the squares and print the result so far. </para><programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    System.out.println("dsquared is " + dsquared);
    return 0.0;  // stub
}</programlisting><para>Again, you should compile and run the program at this stage and check the intermediate value, which should be 25.0. Finally, we can use <literal remap="verb" moreinfo="none">Math.sqrt</literal> to compute and return the result. </para><programlisting language="java" format="linespecific">public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    double result = Math.sqrt(dsquared);
    return result;
}</programlisting><para>As you gain more experience programming, you might write and debug more than one line at a time. But if you find yourself spending a lot of time debugging, consider taking smaller steps. </para>
</sect1><sect1 id="a0000002403" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>void:</term>
      <listitem><para><indexterm significance="normal">
  <primary>void</primary>

</indexterm>A special return type indicating the method does not return a value. </para></listitem>
  </varlistentry><varlistentry>
    <term>invoke:</term>
      <listitem><para><indexterm significance="normal">
  <primary>invoke</primary>

</indexterm>To cause a method to execute. Also known as “calling” a method. </para></listitem>
  </varlistentry><varlistentry>
    <term>flow of execution:</term>
      <listitem><para><indexterm significance="normal">
  <primary>flow of execution</primary>

</indexterm>The order in which Java executes methods and statements. It may not necessarily be from top to bottom in the source file. </para></listitem>
  </varlistentry><varlistentry>
    <term>argument:</term>
      <listitem><para><indexterm significance="normal">
  <primary>argument</primary>

</indexterm>A value that you provide when you call a method. This value must have the type that the method expects. </para></listitem>
  </varlistentry><varlistentry>
    <term>parameter:</term>
      <listitem><para><indexterm significance="normal">
  <primary>parameter</primary>

</indexterm>A piece of information that a method requires before it can run. Parameters are variables: they contain values and have types. </para></listitem>
  </varlistentry><varlistentry>
    <term>parameter passing:</term>
      <listitem><para><indexterm significance="normal">
  <primary>parameter passing</primary>

</indexterm>The process of assigning an argument value to a parameter variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>local variable:</term>
      <listitem><para><indexterm significance="normal">
  <primary>local variable</primary>

</indexterm>A variable declared inside a method. Local variables cannot be accessed from outside their method. </para></listitem>
  </varlistentry><varlistentry>
    <term>stack diagram:</term>
      <listitem><para><indexterm significance="normal">
  <primary>stack diagram</primary>

</indexterm>A graphical representation of the variables belonging to each method. The method calls are “stacked” from top to bottom, in the flow of execution. </para></listitem>
  </varlistentry><varlistentry>
    <term>frame:</term>
      <listitem><para><indexterm significance="normal">
  <primary>frame</primary>

</indexterm>In a stack diagram, a representation of the variables and parameters for a method, along with their current values. </para></listitem>
  </varlistentry><varlistentry>
    <term>scope:</term>
      <listitem><para><indexterm significance="normal">
  <primary>scope</primary>

</indexterm>The area of a program where a variable can be used. </para></listitem>
  </varlistentry><varlistentry>
    <term>composition:</term>
      <listitem><para><indexterm significance="normal">
  <primary>composition</primary>

</indexterm>The ability to combine simple expressions and statements into compound expressions and statements. </para></listitem>
  </varlistentry><varlistentry>
    <term>return type:</term>
      <listitem><para><indexterm significance="normal">
  <primary>return type</primary>

</indexterm>The type of value a method returns. </para></listitem>
  </varlistentry><varlistentry>
    <term>return value:</term>
      <listitem><para><indexterm significance="normal">
  <primary>return value</primary>

</indexterm>The value provided as the result of a method invocation. </para></listitem>
  </varlistentry><varlistentry>
    <term>temporary variable:</term>
      <listitem><para><indexterm significance="normal">
  <primary>temporary variable</primary>

</indexterm>A short-lived variable, often used for debugging. </para></listitem>
  </varlistentry><varlistentry>
    <term>incremental development:</term>
      <listitem><para><indexterm significance="normal">
  <primary>incremental development</primary>

</indexterm>A process for creating programs by writing a few lines at a time, compiling, and testing. </para></listitem>
  </varlistentry><varlistentry>
    <term>stub:</term>
      <listitem><para><indexterm significance="normal">
  <primary>stub</primary>

</indexterm>A placeholder for an incomplete method so that the class will compile. </para></listitem>
  </varlistentry><varlistentry>
    <term>scaffolding:</term>
      <listitem><para><indexterm significance="normal">
  <primary>scaffolding</primary>

</indexterm>Code that is used during program development but is not part of the final version. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000002440" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal moreinfo="none">ch04</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="cltesting"/>, now might be a good time. It describes an efficient way to test programs that take input from the user and display specific output. </para><para><example id="a0000002452" role="exercise">
  <title/>
  <para>The purpose of this exercise is to take code from a previous exercise and redesign it as a method that takes parameters. You should start with a working solution to <xref linkend="ex..date"/>. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Write a method called <literal remap="verb" moreinfo="none">printAmerican</literal> that takes the day, date, month and year as parameters and that displays them in American format. </para></listitem>
  
  <listitem><para>Test your method by invoking it from <literal remap="verb" moreinfo="none">main</literal> and passing appropriate arguments. The output should look something like this (except that the date might be different): </para><programlisting format="linespecific">Saturday, July 22, 2015</programlisting></listitem>
  
  <listitem><para>Once you have debugged <literal remap="verb" moreinfo="none">printAmerican</literal>, write another method called <literal remap="verb" moreinfo="none">printEuropean</literal> that displays the date in European format. </para></listitem>
  
</orderedlist></example> </para><para><example id="a0000002475" role="exercise">
  <title/>
  <para>This exercise reviews the flow of execution through a program with multiple methods. Read the following code and answer the questions. </para><programlisting language="java" format="linespecific">public static void main(String[] args) {
    zippo("rattle", 13);
}</programlisting><programlisting language="java" format="linespecific">public static void baffle(String blimp) {
    System.out.println(blimp);
    zippo("ping", -5);
}</programlisting><programlisting language="java" format="linespecific">public static void zippo(String quince, int flag) {
    if (flag &lt; 0) {
        System.out.println(quince + " zoop");
    } else {
        System.out.println("ik");
        baffle(quince);
        System.out.println("boo-wa-ha-ha");
    }
}</programlisting><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Write the number <literal moreinfo="none">1</literal> next to the first line of code in this program that will execute. </para></listitem>
  
  <listitem><para>Write the number <literal moreinfo="none">2</literal> next to the second line of code, and so on until the end of the program. If a line is executed more than once, it might end up with more than one number next to it. </para></listitem>
  
  <listitem><para>What is the value of the parameter <literal remap="verb" moreinfo="none">blimp</literal> when <literal remap="verb" moreinfo="none">baffle</literal> gets invoked? </para></listitem>
  
  <listitem><para>What is the output of this program? </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000002500" role="exercise">
  <title/>
  <para>Answer the following questions without running the program on a computer. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Draw a stack diagram that shows the state of the program the first time <literal remap="verb" moreinfo="none">ping</literal> is invoked. </para></listitem>
  
  <listitem><para>What is output by the following program? Be precise about where there are spaces and where there are newlines. </para></listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static void zoop() {
    baffle();
    System.out.print("You wugga ");
    baffle();
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    System.out.print("No, I ");
    zoop();
    System.out.print("I ");
    baffle();
}</programlisting><programlisting language="java" format="linespecific">public static void baffle() {
    System.out.print("wug");
    ping();
}</programlisting><programlisting language="java" format="linespecific">public static void ping() {
    System.out.println(".");
}</programlisting></example> </para><para><example id="a0000002518" role="exercise">
  <title/>
  <para>If you have a question about whether something is legal, and what happens if it is not, a good way to find out is to ask the compiler. Answer the following questions by trying them out. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>What happens if you invoke a value method and don’t do anything with the result; that is, if you don’t assign it to a variable or use it as part of a larger expression? </para></listitem>
  
  <listitem><para>What happens if you use a void method as part of an expression? For example, try <literal remap="verb" moreinfo="none">System.out.println("boo!") + 7;</literal> </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000002528" role="exercise">
  <title/>
  <para>Draw a stack diagram that shows the state of the program the <emphasis>second</emphasis> time <literal remap="verb" moreinfo="none">zoop</literal> is invoked. What is the complete output? </para><programlisting language="java" format="linespecific">public static void zoop(String fred, int bob) {
    System.out.println(fred);
    if (bob == 5) {
        ping("not ");
    } else {
        System.out.println("!");
    }
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    int bizz = 5;
    int buzz = 2;
    zoop("just for", bizz);
    clink(2 * buzz);
}</programlisting><programlisting language="java" format="linespecific">public static void clink(int fork) {
    System.out.print("It's ");
    zoop("breakfast ", fork);
}</programlisting><programlisting language="java" format="linespecific">public static void ping(String strangStrung) {
    System.out.println("any " + strangStrung + "more ");
}</programlisting></example> </para><para><example id="a0000002542" role="exercise">
  <title/>
  <para>Many computations can be expressed more concisely using the “multadd” operation, which takes three operands and computes <literal remap="verb" moreinfo="none">a * b + c</literal>. Some processors even provide a hardware implementation of this operation for floating-point numbers. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Create a new program called <literal moreinfo="none">Multadd.java</literal>. </para></listitem>
  
  <listitem><para>Write a method called <literal remap="verb" moreinfo="none">multadd</literal> that takes three <literal remap="verb" moreinfo="none">doubles</literal> as parameters and that returns <literal remap="verb" moreinfo="none">a * b + c</literal>. </para></listitem>
  
  <listitem><para>Write a <literal remap="verb" moreinfo="none">main</literal> method that tests <literal remap="verb" moreinfo="none">multadd</literal> by invoking it with a few simple parameters, like <literal remap="verb" moreinfo="none">1.0, 2.0, 3.0</literal>. </para></listitem>
  
  <listitem><para>Also in <literal remap="verb" moreinfo="none">main</literal>, use <literal remap="verb" moreinfo="none">multadd</literal> to compute the following values: </para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo form="prefix">cos</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:mtd><mml:mtd></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mn>10</mml:mn><mml:mo>+</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation></listitem>
  
  <listitem><para>Write a method called <literal remap="verb" moreinfo="none">expSum</literal> that takes a double as a parameter and that uses <literal remap="verb" moreinfo="none">multadd</literal> to calculate: </para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>x</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para> <emphasis>Hint:</emphasis> The method for raising <emphasis role="math">e</emphasis> to a power is <literal remap="verb" moreinfo="none">Math.exp</literal>. </para></listitem>
  
</orderedlist><para>In the last part of this exercise, you need to write a method that invokes another method you wrote. Whenever you do that, it is a good idea to test the first method carefully before working on the second. Otherwise, you might find yourself debugging two methods at the same time, which can be difficult. </para><para>One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems. </para>
</example> </para>
</sect1>
</chapter>
