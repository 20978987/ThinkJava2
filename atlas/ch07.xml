<chapter id="a0000003846">
  <title>Arrays and References</title>
  <para>Up to this point, the only variables we have used were for individual values such as numbers or strings. In this chapter, we’ll learn how to store multiple values of the same type using a single variable. This language feature will enable you to write programs that manipulate larger amounts of data. </para><para>For example, <xref linkend="doubloon"/> asked you to check whether every letter in a string appears exactly twice. One algorithm (which hopefully you already discovered) is to loop through the string 26 times, once for each lowercase letter: </para><programlisting language="java" format="linespecific">// outer loop: for each lowercase letter
for (char c = 'a'; c &lt;= 'z'; c++) {
    // inner loop: count how many times the letter appears
    for (int i = 0; i &lt; str.length(); i++) {
        ...
    // if the count is not 0 or 2, return false</programlisting><para>This “nested loops” approach is inefficient, especially when the string is long. For example, there are more than 3 million characters in <emphasis>War and Peace</emphasis>; to process the whole book, the nested loop would run about 80 million times. </para><para>Another algorithm would initialize 26 variables to zero, loop through the string <emphasis>one time</emphasis>, and use a giant <literal remap="verb" moreinfo="none">if</literal> statement to update the variable for each letter. But who wants to declare 26 variables? </para><para>That’s where arrays come in. We can use a single variable to store 26 integers. Rather than use an <literal remap="verb" moreinfo="none">if</literal> statement to update each value, we can use arithmetic to update the <emphasis role="math">n</emphasis>th value directly. We will present this algorithm at the end of the chapter. </para><sect1 id="a0000003863" remap="section">
  <title>Creating Arrays</title>
    <para><indexterm significance="normal">
  <primary>array</primary>

</indexterm><indexterm significance="normal">
  <primary>element</primary>

</indexterm>An <emphasis role="bold">array</emphasis> is a sequence of values; the values in the array are called <emphasis role="bold">elements</emphasis>. You can make an array of <literal remap="verb" moreinfo="none">int</literal>s, <literal remap="verb" moreinfo="none">double</literal>s, <literal remap="verb" moreinfo="none">String</literal>s, or any other type, but all the values in an array must have the same type. </para><para><indexterm significance="normal">
  <primary>type</primary>
<secondary>array</secondary>
</indexterm><indexterm significance="normal">
  <primary>[ ] square brackets</primary>

</indexterm><indexterm significance="normal">
  <primary>brackets</primary>
<secondary>square</secondary>
</indexterm>To create an array, you have to declare a variable with an <emphasis>array type</emphasis> and then create the array itself. Array types look like other Java types, except they are followed by square brackets (<literal remap="verb" moreinfo="none">[]</literal>). For example, the following lines declare that <literal remap="verb" moreinfo="none">counts</literal> is an “integer array” and <literal remap="verb" moreinfo="none">values</literal> is a “double array”: </para><programlisting language="java" format="linespecific">int[] counts;
double[] values;</programlisting><para><indexterm significance="normal">
  <primary>new</primary>

</indexterm><indexterm significance="normal">
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm><indexterm significance="normal">
  <primary>allocate</primary>

</indexterm>To create the array itself, you have to use the <literal remap="verb" moreinfo="none">new</literal> operator, which we first saw in <xref linkend="scanner"/>. The <literal remap="verb" moreinfo="none">new</literal> operator <emphasis role="bold">allocates</emphasis> memory for the array and automatically initializes all of its elements to zero. </para><programlisting language="java" format="linespecific">counts = new int[4];
values = new double[size];</programlisting><para>The first assignment makes <literal remap="verb" moreinfo="none">counts</literal> refer to an array of four integers. The second makes <literal remap="verb" moreinfo="none">values</literal> refer to an array of <literal remap="verb" moreinfo="none">double</literal>s, but the number of elements depends on the value of <literal remap="verb" moreinfo="none">size</literal> (at the time the array is created). </para><para>Of course, you can also declare the variable and create the array with a single line of code: </para><programlisting language="java" format="linespecific">int[] counts = new int[4];
double[] values = new double[size];</programlisting><para><indexterm significance="normal">
  <primary>NegativeArraySizeException</primary>

</indexterm><indexterm significance="normal">
  <primary>exception</primary>
<secondary>NegativeArraySize</secondary>
</indexterm>You can use any integer expression for the size of an array, as long as the value is nonnegative. If you try to create an array with <literal remap="verb" moreinfo="none">-4</literal> elements, for example, you will get a <literal remap="verb" moreinfo="none">NegativeArraySizeException</literal>. An array with zero elements is allowed, and there are special uses for such arrays that we’ll see later on. </para><para>You can initialize an array with an <emphasis role="bold">array literal</emphasis>, which is a comma-separated sequence of elements enclosed in braces, like this: </para><programlisting language="java" format="linespecific">int[] a = {1, 2, 3, 4};</programlisting><para>This statement creates an array variable, <literal remap="verb" moreinfo="none">a</literal>, and makes it refer to an array with four elements. </para>
</sect1><sect1 id="elements" remap="section">
  <title>Accessing Elements</title><para>When you create an array with the <literal remap="verb" moreinfo="none">new</literal> operator, the elements are initialized to zero. <xref linkend="fig.array"/> shows a memory diagram of the <literal remap="verb" moreinfo="none">counts</literal> array so far. </para>
  
  <figure id="fig.array" float="False">
    <title>Memory diagram of an <literal remap="verb" moreinfo="none">int array.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>reference</primary>

</indexterm>The arrow indicates that the value of <literal remap="verb" moreinfo="none">counts</literal> is a <emphasis role="bold">reference</emphasis> to the array. You should think of <emphasis>the array</emphasis> and <emphasis>the variable</emphasis> that refers to it as two different things. As we’ll soon see, we can assign a different variable to refer to the same array, and we can change the value of <literal remap="verb" moreinfo="none">counts</literal> to refer to a different array. </para><para><indexterm significance="normal">
  <primary>element</primary>

</indexterm><indexterm significance="normal">
  <primary>index</primary>

</indexterm><indexterm significance="normal">
  <primary>array</primary>
<secondary>element</secondary>
</indexterm><indexterm significance="normal">
  <primary>array</primary>
<secondary>index</secondary>
</indexterm>The boldface numbers inside the boxes are the elements of the array. The lighter numbers outside the boxes are the <emphasis role="bold">indexes</emphasis> used to identify each location in the array. As with strings, the index of the first element is 0, not 1. For this reason, we sometimes refer to the first element as the “zeroth” element. </para><para>The <literal remap="verb" moreinfo="none">[]</literal> operator selects elements from an array: </para><programlisting language="java" format="linespecific">System.out.println("The zeroth element is " + counts[0]);</programlisting><para>You can use the <literal remap="verb" moreinfo="none">[]</literal> operator anywhere in an expression: </para><programlisting language="java" format="linespecific">counts[0] = 7;
counts[1] = counts[0] * 2;
counts[2]++;
counts[3] -= 60;</programlisting><para><xref linkend="fig.array2"/> shows the result of these statements. </para>
  
  <figure id="fig.array2" float="False">
    <title>Memory diagram after several assignment statements.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>You can use any expression as an index, as long as it has type <literal remap="verb" moreinfo="none">int</literal>. One of the most common ways to index an array is with a loop variable. For example: </para><programlisting language="java" format="linespecific">int i = 0;
while (i &lt; 4) {
    System.out.println(counts[i]);
    i++;
}</programlisting><para>This <literal remap="verb" moreinfo="none">while</literal> loop counts up from 0 to 4. When <literal remap="verb" moreinfo="none">i</literal> is 4, the condition fails and the loop terminates. So the body of the loop is only executed when <literal remap="verb" moreinfo="none">i</literal> is 0, 1, 2, and 3. In this context, the variable name <literal remap="verb" moreinfo="none">i</literal> is short for “index”. </para><para><indexterm significance="normal">
  <primary>loop variable</primary>

</indexterm><indexterm significance="normal">
  <primary>variable</primary>
<secondary>loop</secondary>
</indexterm>Each time through the loop we use <literal remap="verb" moreinfo="none">i</literal> as an index into the array, displaying the <literal remap="verb" moreinfo="none">i</literal>th element. This type of array processing is usually written as a <literal remap="verb" moreinfo="none">for</literal> loop. </para><programlisting language="java" format="linespecific">for (int i = 0; i &lt; 4; i++) {
    System.out.println(counts[i]);
}</programlisting><para><indexterm significance="normal">
  <primary>ArrayIndexOutOfBoundsException</primary>

</indexterm><indexterm significance="normal">
  <primary>exception</primary>
<secondary>ArrayIndexOutOfBounds</secondary>
</indexterm>For the <literal remap="verb" moreinfo="none">counts</literal> array, the only legal indexes are 0, 1, 2, and 3. If the index is negative or greater than 3, the result is an <literal remap="verb" moreinfo="none">ArrayIndexOutOfBoundsException</literal>. </para>
</sect1><sect1 id="printarray" remap="section">
  <title>Displaying Arrays</title><para><indexterm significance="normal">
  <primary>array</primary>
<secondary>printing</secondary>
</indexterm>You can use <literal remap="verb" moreinfo="none">println</literal> to display an array, but it probably doesn’t do what you would like. For example, if you print an array like this: </para><programlisting language="java" format="linespecific">int[] a = {1, 2, 3, 4};
System.out.println(a);</programlisting><para>The output is something like: </para><programlisting format="linespecific">[I@bf3f7e0</programlisting><para>The bracket indicates that the value is an array, <literal remap="verb" moreinfo="none">I</literal> stands for “integer”, and the rest represents the address of the array in memory. </para><para>If we want to display the elements of the array, we can do it ourselves: </para><programlisting language="java" format="linespecific">public static void printArray(int[] a) {
    System.out.print("{" + a[0]);
    for (int i = 1; i &lt; a.length; i++) {
        System.out.print(", " + a[i]);
    }
    System.out.println("}");
}</programlisting><para>Given the previous array, the output of <literal remap="verb" moreinfo="none">printArray</literal> is: </para><programlisting format="linespecific">{1, 2, 3, 4}</programlisting><para><indexterm significance="normal">
  <primary>utility class</primary>

</indexterm><indexterm significance="normal">
  <primary>Arrays class</primary>

</indexterm>The Java library includes a class, <literal remap="verb" moreinfo="none">java.util.Arrays</literal>, that provides methods for working with arrays. One of them, <literal remap="verb" moreinfo="none">toString</literal>, returns a string representation of an array. We can invoke it like this: </para><programlisting language="java" format="linespecific">import java.utils.Arrays

System.out.println(Arrays.toString(a));</programlisting><para>We have to <literal remap="verb" moreinfo="none">Arrays</literal> before we can use it. And the output is: </para><programlisting format="linespecific">[1, 2, 3, 4]</programlisting><para>Notice that <literal remap="verb" moreinfo="none">Arrays.toString</literal> uses square brackets instead of curly braces. But it beats writing your own <literal remap="verb" moreinfo="none">printArray</literal> method. </para>
</sect1><sect1 id="a0000004009" remap="section">
  <title>Copying Arrays</title>
    <para><indexterm significance="normal">
  <primary>array</primary>
<secondary>copying</secondary>
</indexterm>As explained in <xref linkend="elements"/>, array variables contain <emphasis>references</emphasis> to arrays. When you make an assignment to an array variable, it simply copies the reference. But it doesn’t copy the array itself. For example: </para><programlisting language="java" format="linespecific">double[] a = new double[3];
double[] b = a;</programlisting><para><indexterm significance="normal">
  <primary>memory diagram</primary>

</indexterm><indexterm significance="normal">
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>These statements create an array of three <literal remap="verb" moreinfo="none">double</literal>s and make two different variables refer to it, as shown in <xref linkend="fig.array3"/>. </para>
  
  <figure id="fig.array3" float="False">
    <title>Memory diagram of two variables referring to the same array.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>alias</primary>

</indexterm>Any changes made through either variable will be seen by the other. For example, if we set <literal remap="verb" moreinfo="none">a[0] = 17.0</literal>, and then display <literal remap="verb" moreinfo="none">b[0]</literal>, the result is <literal moreinfo="none">17.0</literal>. Because <literal remap="verb" moreinfo="none">a</literal> and <literal remap="verb" moreinfo="none">b</literal> are different names for the same thing, they are sometimes called <emphasis role="bold">aliases</emphasis>. </para><para>If you actually want to copy the array, not just the reference, you have to create a new array and copy the elements from one to the other, like this: </para><programlisting language="java" format="linespecific">double[] b = new double[3];
for (int i = 0; i &lt; 3; i++) {
    b[i] = a[i];
}</programlisting><para><indexterm significance="normal">
  <primary>Arrays class</primary>

</indexterm><literal remap="verb" moreinfo="none">java.util.Arrays</literal> provides a method named <literal remap="verb" moreinfo="none">copyOf</literal> that performs this task for you. So you can replace the previous code with one line: </para><programlisting language="java" format="linespecific">double[] b = Arrays.copyOf(a, 3);</programlisting><para>The second parameter is the number of elements you want to copy, so <literal remap="verb" moreinfo="none">copyOf</literal> can also be used to copy part of an array. <xref linkend="fig.array4"/> shows the state of the array variables after invoking <literal remap="verb" moreinfo="none">Arrays.copyOf</literal>. </para>
  
  <figure id="fig.array4" float="False">
    <title>Memory diagram of two variables referring to different arrays.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array4.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>length</primary>
<secondary>array</secondary>
</indexterm><indexterm significance="normal">
  <primary>array</primary>
<secondary>length</secondary>
</indexterm>The examples so far only work if the array has three elements. It is better to generalize the code to work with arrays of any size. We can do that by replacing the magic number, <literal remap="verb" moreinfo="none">3</literal>, with <literal remap="verb" moreinfo="none">a.length</literal>: </para><programlisting language="java" format="linespecific">double[] b = new double[a.length];
for (int i = 0; i &lt; a.length; i++) {
    b[i] = a[i];
}</programlisting><para>All arrays have a built-in constant, <literal remap="verb" moreinfo="none">length</literal>, that stores the number of elements. In contrast to <literal remap="verb" moreinfo="none">String.length()</literal>, which is a method, <literal remap="verb" moreinfo="none">a.length</literal> is a constant. The expression <literal remap="verb" moreinfo="none">a.length</literal> may look like a method invocation, but there are no parentheses and no arguments. </para><para>The last time the loop gets executed, <literal remap="verb" moreinfo="none">i</literal> is <literal remap="verb" moreinfo="none">a.length - 1</literal>, which is the index of the last element. When <literal remap="verb" moreinfo="none">i</literal> is equal to <literal remap="verb" moreinfo="none">a.length</literal>, the condition fails and the body is not executed – which is a good thing, because trying to access <literal remap="verb" moreinfo="none">a[a.length]</literal> would throw an exception. </para><para>Of course we can replace the loop altogether by using <literal remap="verb" moreinfo="none">Arrays.copyOf</literal> and <literal remap="verb" moreinfo="none">a.length</literal> for the second argument. The following line produces the same result shown in <xref linkend="fig.array4"/>. </para><programlisting language="java" format="linespecific">double[] b = Arrays.copyOf(a, a.length);</programlisting><para>The <literal remap="verb" moreinfo="none">Arrays</literal> class provides many other useful methods like <literal remap="verb" moreinfo="none">Arrays.compare</literal>, <literal remap="verb" moreinfo="none">Arrays.equals</literal>, <literal remap="verb" moreinfo="none">Arrays.fill</literal>, and <literal remap="verb" moreinfo="none">Arrays.sort</literal>. Take a moment to read the documentation by searching the web for <literal remap="verb" moreinfo="none">java.util.Arrays</literal>. </para>
</sect1><sect1 id="traversal" remap="section">
  <title>Array Traversal</title><para><indexterm significance="normal">
  <primary>traversal</primary>

</indexterm>Many computations can be implemented by looping through the elements of an array and performing an operation on each element. Looping through the elements of an array is called a <emphasis role="bold">traversal</emphasis>. </para><programlisting language="java" format="linespecific">int[] a = {1, 2, 3, 4, 5};
for (int i = 0; i &lt; a.length; i++) {
    a[i] *= a[i];
}</programlisting><para>This example traverses an array and squares each element. At the end of the loop, the array has the values <literal remap="verb" moreinfo="none">{1, 4, 9, 16, 25}</literal>. </para><para><indexterm significance="normal">
  <primary>search</primary>

</indexterm>Another common pattern is a <emphasis role="bold">search</emphasis>, which involves traversing an array and “searching” for a particular element. For example, the following method takes an array and a value, and it returns the index where the value appears: </para><programlisting language="java" format="linespecific">public static int search(double[] array, double target) {
    for (int i = 0; i &lt; array.length; i++) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;  // not found
}</programlisting><para>If we find the target value in the array, we return its index immediately. If the loop exits without finding the target, it returns <literal remap="verb" moreinfo="none">-1</literal>, a special value chosen to indicate a failed search. (This code is essentially what the <literal remap="verb" moreinfo="none">String.indexOf</literal> method does.) </para><para>The following code searches an array for the value <literal remap="verb" moreinfo="none">1.23</literal>, which is the third element. Because array indexes start at zero, the output is <literal remap="verb" moreinfo="none">2</literal>. </para><programlisting language="java" format="linespecific">double[] array = {3.14, -55.0, 1.23, -0.8};
int index = search(array, 1.23);
System.out.println(index);</programlisting><para><indexterm significance="normal">
  <primary>reduce</primary>

</indexterm>Another common traversal is a <emphasis role="bold">reduce</emphasis> operation, which “reduces” an array of values down to a single value. Examples include the sum or product of the elements, the minimum, and the maximum. The following method takes an array and returns the sum of its elements: </para><programlisting language="java" format="linespecific">public static double sum(double[] array) {
    double total = 0.0;
    for (int i = 0; i &lt; array.length; i++) {
        total += array[i];
    }
    return total;
}</programlisting><para><indexterm significance="normal">
  <primary>accumulator</primary>

</indexterm>Before the loop, we initialize <literal remap="verb" moreinfo="none">total</literal> to zero. Each time through the loop, we update <literal remap="verb" moreinfo="none">total</literal> by adding one element from the array. At the end of the loop, <literal remap="verb" moreinfo="none">total</literal> contains the sum of the elements. A variable used this way is sometimes called an <emphasis role="bold">accumulator</emphasis>, because it “accumulates” the running total. </para>
</sect1><sect1 id="random" remap="section">
  <title>Random Numbers</title><para><indexterm significance="normal">
  <primary>deterministic</primary>

</indexterm>Most computer programs do the same thing every time they run; programs like that are called <emphasis role="bold">deterministic</emphasis>. Usually determinism is a good thing, since we expect the same calculation to yield the same result. But for some applications, we want the computer to be unpredictable. Games are an obvious example, but there are many others, like scientific simulations. </para><para><indexterm significance="normal">
  <primary>nondeterministic</primary>

</indexterm><indexterm significance="normal">
  <primary>pseudorandom</primary>

</indexterm>Making a program <emphasis role="bold">nondeterministic</emphasis> turns out to be hard, because it’s impossible for a computer to generate truly random numbers. But there are algorithms that generate unpredictable sequences called <emphasis role="bold">pseudorandom</emphasis> numbers. For most applications, they are as good as random. </para><para><indexterm significance="normal">
  <primary>Random</primary>

</indexterm><indexterm significance="normal">
  <primary>nextInt</primary>
<secondary>Random</secondary>
</indexterm>If you did <xref linkend="guess"/>, you have already seen <literal remap="verb" moreinfo="none">java.util.Random</literal>, which generates pseudorandom numbers. The method <literal remap="verb" moreinfo="none">nextInt</literal> takes an integer argument, <literal remap="verb" moreinfo="none">n</literal>, and returns a random integer between <literal remap="verb" moreinfo="none">0</literal> and <literal remap="verb" moreinfo="none">n - 1</literal> (inclusive). </para><para>If you generate a long series of random numbers, every value should appear, at least approximately, the same number of times. One way to test this behavior of <literal remap="verb" moreinfo="none">nextInt</literal> is to generate a large number of values, store them in an array, and count the number of times each value occurs. </para><para>The following method creates an <literal remap="verb" moreinfo="none">int</literal> array and fills it with random numbers between 0 and 99. The argument specifies the desired size of the array, and the return value is a reference to the new array. </para><programlisting language="java" format="linespecific">public static int[] randomArray(int size) {
    Random random = new Random();
    int[] a = new int[size];
    for (int i = 0; i &lt; a.length; i++) {
        a[i] = random.nextInt(100);
    }
    return a;
}</programlisting><para>The following <literal remap="verb" moreinfo="none">main</literal> method generates an array and displays it using <literal remap="verb" moreinfo="none">printArray</literal> from <xref linkend="printarray"/>. We could have used <literal remap="verb" moreinfo="none">Arrays.toString</literal>, but we like seeing curly braces instead of square brackets. </para><programlisting language="java" format="linespecific">public static void main(String[] args) {
    int[] array = randomArray(8);
    printArray(array);
}</programlisting><para>Each time you run the program, you should get different values. The output will look something like this: </para><programlisting format="linespecific">{15, 62, 46, 74, 67, 52, 51, 10}</programlisting></sect1><sect1 id="singlepass" remap="section">
  <title>Building a Histogram</title><para><indexterm significance="normal">
  <primary>histogram</primary>

</indexterm><indexterm significance="normal">
  <primary>counter</primary>

</indexterm>If these values were exam scores – and they would be pretty bad exam scores in that case – the teacher might present them to the class in the form of a <emphasis role="bold">histogram</emphasis>. In statistics, a histogram is a set of counters that keeps track of the number of times each value appears. </para><para>For exam scores, we might have ten counters to keep track of how many students scored in the 90s, the 80s, etc. To do that, we can traverse the array and count the number of elements that fall in a given range. </para><para>The following method takes an array and two integers. It returns the number of elements that fall in the range from <literal remap="verb" moreinfo="none">low</literal> to <literal remap="verb" moreinfo="none">high - 1</literal>. </para><programlisting language="java" format="linespecific">public static int inRange(int[] a, int low, int high) {
    int count = 0;
    for (int i = 0; i &lt; a.length; i++) {
        if (a[i] &gt;= low &amp;&amp; a[i] &lt; high) {
            count++;
        }
    }
    return count;
}</programlisting><para><indexterm significance="normal">
  <primary>reduce</primary>

</indexterm>This pattern should look familiar: it is another reduce operation. Notice that <literal remap="verb" moreinfo="none">low</literal> is included in the range (<literal remap="verb" moreinfo="none">&gt;=</literal>), but <literal remap="verb" moreinfo="none">high</literal> is excluded (<literal remap="verb" moreinfo="none">&lt;</literal>). This design keeps us from counting any scores twice. </para><para>Now we can count the number of scores in each grade range. We add the following code to our <literal remap="verb" moreinfo="none">main</literal> method: </para><programlisting language="java" format="linespecific">int[] scores = randomArray(30);
int a = inRange(scores, 90, 100);
int b = inRange(scores, 80, 90);
int c = inRange(scores, 70, 80);
int d = inRange(scores, 60, 70);
int f = inRange(scores, 0, 60);</programlisting><para>This code is repetitive, but it is acceptable as long as the number of ranges is small. Suppose we wanted to keep track of the number of times each individual score appears. Then we would have to write 100 lines of code: </para><programlisting language="java" format="linespecific">int count0 = inRange(scores, 0, 1);
int count1 = inRange(scores, 1, 2);
int count2 = inRange(scores, 2, 3);
...
int count99 = inRange(scores, 99, 100);</programlisting><para>What we need is a way to store 100 counters, preferably so we can use an index to access them. Wait a minute, that’s exactly what an array does. </para><para>The following fragment creates an array of 100 counters, one for each possible score. It loops through the scores and uses <literal remap="verb" moreinfo="none">inRange</literal> to count how many times each score appears. Then it stores the results in the <literal remap="verb" moreinfo="none">counts</literal> array: </para><programlisting language="java" format="linespecific">int[] counts = new int[100];
for (int i = 0; i &lt; counts.length; i++) {
    counts[i] = inRange(scores, i, i + 1);
}</programlisting><para>Notice that we are using the loop variable <literal remap="verb" moreinfo="none">i</literal> three times: as an index into the <literal remap="verb" moreinfo="none">counts</literal> array, and in the last two arguments of <literal remap="verb" moreinfo="none">inRange</literal>. </para><para><indexterm significance="normal">
  <primary>efficiency</primary>

</indexterm>The code works, but it is not as efficient as it could be. Every time the loop invokes <literal remap="verb" moreinfo="none">inRange</literal>, it traverses the entire array. It would be better to make a single pass through the <literal remap="verb" moreinfo="none">scores</literal> array. </para><para>For each score, we already know which range it falls in – the score itself. We can use that value to increment the corresponding counter. This code traverses the array of scores <emphasis>only once</emphasis> to generate the histogram: </para><programlisting language="java" format="linespecific">int[] counts = new int[100];
for (int i = 0; i &lt; scores.length; i++) {
    int index = scores[i];
    counts[index]++;
}</programlisting><para>Each time through the loop, it selects one element from <literal remap="verb" moreinfo="none">scores</literal> and uses it as an index to increment the corresponding element of <literal remap="verb" moreinfo="none">counts</literal>. Because this code traverses the array of scores only once, it is much more efficient. </para>
</sect1><sect1 id="enhanced" remap="section">
  <title>The Enhanced for Loop</title><para>Since traversing arrays is so common, Java provides an alternative syntax that makes the code more compact. Consider a <literal remap="verb" moreinfo="none">for</literal> loop that displays the elements of an array on separate lines: </para><programlisting language="java" format="linespecific">for (int i = 0; i &lt; values.length; i++) {
    int value = values[i];
    System.out.println(value);
}</programlisting><para>We could rewrite the loop like this: </para><programlisting language="java" format="linespecific">for (int value : values) {
    System.out.println(value);
}</programlisting><para><indexterm significance="normal">
  <primary>enhanced for loop</primary>

</indexterm><indexterm significance="normal">
  <primary>for</primary>
<secondary>enhanced</secondary>
</indexterm>This statement is called an <emphasis role="bold">enhanced for loop</emphasis>, also known as the “for each” loop. You can read the code as, “for each <literal remap="verb" moreinfo="none">value</literal> in <literal remap="verb" moreinfo="none">values</literal>”. It’s conventional to use plural nouns for array variables and singular nouns for element variables. </para><para>Notice how the single line <literal remap="verb" moreinfo="none">for (int value : values)</literal> replaces the first two lines of the standard <literal remap="verb" moreinfo="none">for</literal> loop. It hides the details of iterating each index of the array, and instead, focuses on the values themselves. </para><para>Using the enhanced <literal remap="verb" moreinfo="none">for</literal> loop, and removing the temporary variable, we can write the histogram code from the previous section more concisely: </para><programlisting language="java" format="linespecific">int[] counts = new int[100];
for (int score : scores) {
    counts[score]++;
}</programlisting><para>Enhanced <literal remap="verb" moreinfo="none">for</literal> loops often make the code more readable, especially for accumulating values. But they are not helpful when you need to refer to the index, as in search operations. </para><programlisting language="java" format="linespecific">for (double d : array) {
    if (d == target) {
        // array contains d, but we don't know where
    }
}</programlisting></sect1><sect1 id="a0000004238" remap="section">
  <title>Counting Characters</title>
    <para>We now return to the example from the beginning of the chapter and present a solution to <xref linkend="doubloon"/> using arrays. Here is the problem again: </para><blockquote remap="quote"><para> A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Write a method called <literal remap="verb" moreinfo="none">isDoubloon</literal> that takes a string and checks whether it is a doubloon. To ignore case, invoke the <literal remap="verb" moreinfo="none">toLowerCase</literal> method before checking. </para></blockquote><para>Based on the approach from <xref linkend="singlepass"/>, we will create an array of 26 integers to count how many times each letter appears. We convert the string to lowercase, so that we can treat <literal remap="verb" moreinfo="none">'A'</literal> and <literal remap="verb" moreinfo="none">'a'</literal> (for example) as the same latter. </para><programlisting language="java" format="linespecific">int[] counts = new int[26];
String lower = s.toLowerCase();</programlisting><para>We can use a <literal remap="verb" moreinfo="none">for</literal> loop to iterate each character in the string. To update the <literal remap="verb" moreinfo="none">counts</literal> array, we need to compute the index that corresponds to each character. Fortunately, Java allows you to perform arithmetic on characters. </para><programlisting language="java" format="linespecific">for (int i = 0; i &lt; lower.length(); i++) {
    char letter = lower.charAt(i);
    int index = letter - 'a';
    counts[index]++;
}</programlisting><para>If <literal remap="verb" moreinfo="none">letter</literal> is <literal remap="verb" moreinfo="none">'a'</literal>, the value of <literal remap="verb" moreinfo="none">index</literal> is <literal remap="verb" moreinfo="none">0</literal>; if <literal remap="verb" moreinfo="none">letter</literal> is <literal remap="verb" moreinfo="none">'b'</literal>, the value of <literal remap="verb" moreinfo="none">index</literal> is <literal remap="verb" moreinfo="none">1</literal>, and so on. </para><para>Then we use <literal remap="verb" moreinfo="none">index</literal> to increment the corresponding element of <literal remap="verb" moreinfo="none">counts</literal>. At the end of the loop, <literal remap="verb" moreinfo="none">count</literal> contains a histogram of the letters in <literal remap="verb" moreinfo="none">lower</literal>. </para><para><indexterm significance="normal">
  <primary>toCharArray</primary>

</indexterm>We can simplify this code with an enhanced <literal remap="verb" moreinfo="none">for</literal> loop, but it doesn’t work with strings; we have to convert <literal remap="verb" moreinfo="none">lower</literal> to an array of characters, like this: </para><programlisting language="java" format="linespecific">for (char letter : lower.toCharArray()) {
    int index = letter - 'a';
    counts[index]++;
}</programlisting><para>Once we have the counts, we can use a second <literal remap="verb" moreinfo="none">for</literal> loop to check whether each letter appears 0 or 2 times. </para><programlisting language="java" format="linespecific">for (int count : counts) {
    if (count != 0 &amp;&amp; count != 2) {
        return false;  // not a doubloon
    }
}
return true;  // is a doubloon</programlisting><para>If we find a count that is neither 0 or 2, we know the word is not a doubloon and we can return immediately. </para><para>If we make it all the way through the <literal remap="verb" moreinfo="none">for</literal> loop, we know that all counts are 0 or 2, which means the word is a doubloon. </para><para><indexterm significance="normal">
  <primary>Doubloon.java</primary>

</indexterm>Pulling together the code fragments, and adding some comments and test cases, here’s the entire program. </para><programlisting language="java" format="linespecific">public class Doubloon {

    public static boolean isDoubloon(String s) {
        // count the number of times each letter appears
        int[] counts = new int[26];
        String lower = s.toLowerCase();
        for (char letter : lower.toCharArray()) {
            int index = letter - 'a';
            counts[index]++;
        }
        // determine whether the given word is a doubloon
        for (int count : counts) {
            if (count != 0 &amp;&amp; count != 2) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(isDoubloon("Mama"));  // true
        System.out.println(isDoubloon("Lama"));  // false
    }
}</programlisting><para>This example uses methods, <literal remap="verb" moreinfo="none">if</literal> statements, <literal remap="verb" moreinfo="none">for</literal> loops, arithmetic and logical operators, integers, characters, strings, booleans, and arrays. We hope you’ll take a second to appreciate how much you’ve learned! </para>
</sect1><sect1 id="a0000004292" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>array:</term>
      <listitem><para><indexterm significance="normal">
  <primary>array</primary>

</indexterm>A collection of values, where all the values have the same type, and each value is identified by an index. </para></listitem>
  </varlistentry><varlistentry>
    <term>element:</term>
      <listitem><para><indexterm significance="normal">
  <primary>element</primary>

</indexterm>One of the values in an array. The <literal remap="verb" moreinfo="none">[]</literal> operator selects elements. </para></listitem>
  </varlistentry><varlistentry>
    <term>index:</term>
      <listitem><para><indexterm significance="normal">
  <primary>index</primary>

</indexterm>An integer variable or value used to indicate an element of an array. </para></listitem>
  </varlistentry><varlistentry>
    <term>allocate:</term>
      <listitem><para><indexterm significance="normal">
  <primary>allocate</primary>

</indexterm>To reserve memory for an array or other object. In Java, the <literal remap="verb" moreinfo="none">new</literal> operator allocates memory. </para></listitem>
  </varlistentry><varlistentry>
    <term>reference:</term>
      <listitem><para><indexterm significance="normal">
  <primary>reference</primary>

</indexterm>A value that indicates a storage location. In a memory diagram, a reference appears as an arrow. </para></listitem>
  </varlistentry><varlistentry>
    <term>alias:</term>
      <listitem><para><indexterm significance="normal">
  <primary>alias</primary>

</indexterm>A variable that refers to the same object as another variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>traversal:</term>
      <listitem><para><indexterm significance="normal">
  <primary>traversal</primary>

</indexterm>Looping through the elements of an array (or other collection). </para></listitem>
  </varlistentry><varlistentry>
    <term>search:</term>
      <listitem><para><indexterm significance="normal">
  <primary>search</primary>

</indexterm>A traversal pattern used to find a particular element of an array. </para></listitem>
  </varlistentry><varlistentry>
    <term>reduce:</term>
      <listitem><para><indexterm significance="normal">
  <primary>reduce</primary>

</indexterm>A traversal pattern that combines the elements of an array into a single value. </para></listitem>
  </varlistentry><varlistentry>
    <term>accumulator:</term>
      <listitem><para><indexterm significance="normal">
  <primary>accumulator</primary>

</indexterm>A variable used to accumulate results during a traversal. </para></listitem>
  </varlistentry><varlistentry>
    <term>deterministic:</term>
      <listitem><para><indexterm significance="normal">
  <primary>deterministic</primary>

</indexterm>A program that does the same thing every time it is run. </para></listitem>
  </varlistentry><varlistentry>
    <term>nondeterministic:</term>
      <listitem><para><indexterm significance="normal">
  <primary>nondeterministic</primary>

</indexterm>A program that always behaves differently, even when run multiple times with the same input. </para></listitem>
  </varlistentry><varlistentry>
    <term>pseudorandom:</term>
      <listitem><para><indexterm significance="normal">
  <primary>pseudorandom</primary>

</indexterm>A sequence of numbers that appear to be random, but which are actually the product of a deterministic computation. </para></listitem>
  </varlistentry><varlistentry>
    <term>histogram:</term>
      <listitem><para><indexterm significance="normal">
  <primary>histogram</primary>

</indexterm>An array of integers where each integer counts the number of values that fall into a certain range. </para></listitem>
  </varlistentry><varlistentry>
    <term>enhanced for loop:</term>
      <listitem><para><indexterm significance="normal">
  <primary>enhanced for loop</primary>

</indexterm>An alternative syntax for traversing the elements of an array (or other collection). </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000004327" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal moreinfo="none">ch07</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you haven’t already, take a look at <xref linkend="debugging"/> where we’ve collected some of our favorite debugging advice. It refers to language features we haven’t yet covered, but it’s good for you to know what’s available when you need it. </para><para><example id="a0000004339" role="exercise">
  <title/>
  <para>The purpose of this exercise is to practice reading code and recognizing the traversal patterns in this chapter. The following methods are hard to read, because instead of using meaningful names for the variables and methods, they use names of fruit. </para><para>For each method, write one sentence that describes what the method does, without getting into the details of how it works. And for each variable, identify the role it plays. </para><programlisting language="java" format="linespecific">public static int banana(int[] a) {
    int kiwi = 1;
    int i = 0;
    while (i &lt; a.length) {
        kiwi = kiwi * a[i];
        i++;
    }
    return kiwi;
}</programlisting><programlisting language="java" format="linespecific">public static int grapefruit(int[] a, int grape) {
    for (int i = 0; i &lt; a.length; i++) {
        if (a[i] == grape) {
            return i;
        }
    }
    return -1;
}</programlisting><programlisting language="java" format="linespecific">public static int pineapple(int[] a, int apple) {
    int pear = 0;
    for (int pine: a) {
        if (pine == apple) {
            pear++;
        }
    }
    return pear;
}</programlisting></example> </para><para><example id="a0000004349" role="exercise">
  <title/>
  <para>What is the output of the following program? Describe in a few words what <literal remap="verb" moreinfo="none">mus</literal> does. Draw a stack diagram just before <literal remap="verb" moreinfo="none">mus</literal> returns. </para><programlisting language="java" format="linespecific">public static int[] make(int n) {
    int[] a = new int[n];
    for (int i = 0; i &lt; n; i++) {
        a[i] = i + 1;
    }
    return a;
}</programlisting><programlisting language="java" format="linespecific">public static void dub(int[] jub) {
    for (int i = 0; i &lt; jub.length; i++) {
        jub[i] *= 2;
    }
}</programlisting><programlisting language="java" format="linespecific">public static int mus(int[] zoo) {
    int fus = 0;
    for (int i = 0; i &lt; zoo.length; i++) {
        fus += zoo[i];
    }
    return fus;
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    int[] bob = make(5);
    dub(bob);
    System.out.println(mus(bob));
}</programlisting></example> </para><para><example id="a0000004362" role="exercise">
  <title/>
  <para>Write a method called <literal remap="verb" moreinfo="none">indexOfMax</literal> that takes an array of integers and returns the index of the largest element. Can you write this method using an enhanced <literal remap="verb" moreinfo="none">for</literal> loop? Why or why not? </para>
</example> </para><para><example id="a0000004367" role="exercise">
  <title/>
  <para>The Sieve of Eratosthenes is “a simple, ancient algorithm for finding all prime numbers up to any given limit,” which you can read about at <ulink url="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"/>. </para><para>Write a method called <literal remap="verb" moreinfo="none">sieve</literal> that takes an integer parameter, <literal remap="verb" moreinfo="none">n</literal>, and returns a <literal remap="verb" moreinfo="none">boolean</literal> array that indicates, for each number from <literal remap="verb" moreinfo="none">0</literal> to <literal remap="verb" moreinfo="none">n - 1</literal>, whether the number is prime. </para>
</example> </para><para><example id="a0000004377" role="exercise">
  <title/>
  <para>Write a method named <literal remap="verb" moreinfo="none">areFactors</literal> that takes an integer <literal remap="verb" moreinfo="none">n</literal> and an array of integers, and that returns <literal remap="verb" moreinfo="none">true</literal> if the numbers in the array are all factors of <literal remap="verb" moreinfo="none">n</literal> (which is to say that <literal remap="verb" moreinfo="none">n</literal> is divisible by all of them). </para>
</example> </para><para><example id="a0000004385" role="exercise">
  <title/>
  <para>Write a method named <literal remap="verb" moreinfo="none">arePrimeFactors</literal> that takes an integer <literal remap="verb" moreinfo="none">n</literal> and an array of integers, and that returns <literal remap="verb" moreinfo="none">true</literal> if the numbers in the array are all prime <emphasis>and</emphasis> their product is <literal remap="verb" moreinfo="none">n</literal>. </para>
</example> </para><para><example id="a0000004394" role="exercise">
  <title/>
  <para>Write a method called <literal remap="verb" moreinfo="none">letterHist</literal> that takes a string as a parameter and returns a histogram of the letters in the string. The zeroth element of the histogram should contain the number of a’s in the string (upper- and lowercase); the 25th element should contain the number of z’s. Your solution should only traverse the string once. </para>
</example> </para><para><example id="a0000004398" role="exercise">
  <title/>
  <para><indexterm significance="normal">
  <primary>anagram</primary>

</indexterm>Two words are anagrams if they contain the same letters and the same number of each letter. For example, “stop” is an anagram of “pots”, “allen downey” is an anagram of “well annoyed”, and “christopher mayfield” is an anagram of “hi prof the camel is dry”. Write a method that takes two strings and checks whether they are anagrams of each other. </para>
</example> </para>
</sect1>
</chapter>
