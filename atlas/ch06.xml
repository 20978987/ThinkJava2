<chapter id="a0000003211">
  <title>Loops and Strings</title>
  <para>Computers are often used to automate repetitive tasks, such as searching for text in documents. Repeating tasks without making errors is something that computers do well and people do poorly. </para><para>In this chapter, we’ll learn how to use <literal remap="verb" moreinfo="none">while</literal> and <literal remap="verb" moreinfo="none">for</literal> loops to add repetition to your code. We’ll also take a first look at <literal remap="verb" moreinfo="none">String</literal> methods and solve some interesting problems. </para><sect1 id="a0000003217" remap="section">
  <title>The while Statement</title>
    <para><indexterm significance="normal">
  <primary>while</primary>

</indexterm><indexterm significance="normal">
  <primary>loop</primary>
<secondary>while</secondary>
</indexterm><indexterm significance="normal">
  <primary>statement</primary>
<secondary>while</secondary>
</indexterm>Using a <literal remap="verb" moreinfo="none">while</literal> statement, we can repeat the same code multiple times: </para><programlisting language="java" format="linespecific">int n = 3;
while (n &gt; 0) {
    System.out.println(n);
    n = n - 1;
}
System.out.println("Blastoff!");</programlisting><para>Reading the code in English sounds like: “Start with <literal remap="verb" moreinfo="none">n</literal> set to 3. While <literal remap="verb" moreinfo="none">n</literal> is greater than zero, print the value of <literal remap="verb" moreinfo="none">n</literal>, and reduce the value of <literal remap="verb" moreinfo="none">n</literal> by 1. When you get to zero, print Blastoff!” So the output is: </para><programlisting format="linespecific">3
2
1
Blastoff!</programlisting><para>The flow of execution for a <literal remap="verb" moreinfo="none">while</literal> statement is: </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Evaluate the condition in parentheses, yielding <literal remap="verb" moreinfo="none">true</literal> or <literal remap="verb" moreinfo="none">false</literal>. </para></listitem>
  
  <listitem><para>If the condition is <literal remap="verb" moreinfo="none">false</literal>, skip the following statements in braces. </para></listitem>
  
  <listitem><para>If the condition is <literal remap="verb" moreinfo="none">true</literal>, execute the statements and go back to step 1. </para></listitem>
  
</orderedlist><para><indexterm significance="normal">
  <primary>loop</primary>

</indexterm>This type of flow is called a <emphasis role="bold">loop</emphasis>, because the last step “loops back around” to the first. <xref linkend="fig.while"/> shows this idea using a flowchart. </para>
  
  <figure id="fig.while" float="False">
    <title>Flow of execution for a <literal remap="verb" moreinfo="none">while loop.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/while.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>loop body</primary>

</indexterm><indexterm significance="normal">
  <primary>infinite loop</primary>

</indexterm><indexterm significance="normal">
  <primary>loop</primary>
<secondary>infinite</secondary>
</indexterm>The <emphasis role="bold">body</emphasis> of the loop should change the value of one or more variables so that, eventually, the condition becomes <literal remap="verb" moreinfo="none">false</literal> and the loop terminates. Otherwise the loop will repeat forever, which is called an <emphasis role="bold">infinite loop</emphasis>. </para><programlisting language="java" format="linespecific">int n = 3;
while (n &gt; 0) {
    System.out.println(n);
    // n never changes
}</programlisting><para>This example will print the number <literal remap="verb" moreinfo="none">3</literal> forever, or at least until you terminate the program. An endless source of amusement for computer scientists is the observation that the directions on shampoo, “Lather, rinse, repeat,” are an infinite loop. </para><para>In the first example, we can prove that the loop terminates when <literal remap="verb" moreinfo="none">n</literal> is positive. But in general, it is not so easy to tell whether a loop terminates. For example, this loop continues until <literal remap="verb" moreinfo="none">n</literal> is 1 (which makes the condition <literal remap="verb" moreinfo="none">false</literal>): </para><programlisting language="java" format="linespecific">while (n != 1) {
    System.out.println(n);
    if (n % 2 == 0) {         // n is even
        n = n / 2;
    } else {                  // n is odd
        n = 3 * n + 1;
    }
}</programlisting><para>Each time through the loop, the program displays the value of <literal remap="verb" moreinfo="none">n</literal> and then checks whether it is even or odd. If it is even, the value of <literal remap="verb" moreinfo="none">n</literal> is divided by two. If it is odd, the value is replaced by <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>3</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>. For example, if the starting value is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1. </para><para>Since <literal remap="verb" moreinfo="none">n</literal> sometimes increases and sometimes decreases, there is no obvious proof that <literal remap="verb" moreinfo="none">n</literal> will ever reach 1 and that the program will ever terminate. For some values of <literal remap="verb" moreinfo="none">n</literal>, such as the powers of two, we can prove that it terminates. The previous example ends with such a sequence, starting when <literal remap="verb" moreinfo="none">n</literal> is 16 (or <emphasis role="math">2<superscript>4</superscript></emphasis>). </para><para>The hard question is whether this program terminates for <emphasis>all</emphasis> values of n. So far, no one has been able to prove it <emphasis>or</emphasis> disprove it! For more information, see <ulink url="https://en.wikipedia.org/wiki/Collatz_conjecture"/>. </para>
</sect1><sect1 id="a0000003292" remap="section">
  <title>Increment and Decrement</title>
    <para>Here is another <literal remap="verb" moreinfo="none">while</literal> loop example; this one displays the numbers 1 to 5. </para><programlisting language="java" format="linespecific">int i = 1;
while (i &lt;= 5) {
    System.out.println(i);
    i++;  // add 1 to i
}</programlisting><para><indexterm significance="normal">
  <primary>increment</primary>

</indexterm><indexterm significance="normal">
  <primary>decrement</primary>

</indexterm>Assignments like <literal remap="verb" moreinfo="none">i = i + 1</literal> don’t often appear in loops, because Java provides a more concise way to add and subtract by one. Specifically, <literal remap="verb" moreinfo="none">++</literal> is the <emphasis role="bold">increment</emphasis> operator; it has the same effect as <literal remap="verb" moreinfo="none">i = i + 1</literal>. And <literal remap="verb" moreinfo="none">--</literal> is the <emphasis role="bold">decrement</emphasis> operator; it has the same effect as <literal remap="verb" moreinfo="none">i = i - 1</literal>. </para><para>If you want to increment or decrement a variable by an amount other than <literal remap="verb" moreinfo="none">1</literal>, you can use <literal remap="verb" moreinfo="none">+=</literal> and <literal remap="verb" moreinfo="none">-=</literal>. For example, <literal remap="verb" moreinfo="none">i += 2</literal> increments <literal remap="verb" moreinfo="none">i</literal> by <literal remap="verb" moreinfo="none">2</literal>. </para><programlisting language="java" format="linespecific">int i = 2;
while (i &lt;= 8) {
    System.out.print(i + ", ");
    i += 2;  // add 2 to i
}
System.out.println("Who do we appreciate?");</programlisting><para>And the output is: </para><programlisting format="linespecific">2, 4, 6, 8, Who do we appreciate?</programlisting></sect1><sect1 id="a0000003320" remap="section">
  <title>The for Statement</title>
    <para><indexterm significance="normal">
  <primary>for</primary>

</indexterm><indexterm significance="normal">
  <primary>loop</primary>
<secondary>for</secondary>
</indexterm><indexterm significance="normal">
  <primary>statement</primary>
<secondary>for</secondary>
</indexterm>The loops we have written so far have three parts in common. They start by initializing a variable, they have a condition that depends on that variable, and they do something inside the loop to update that variable. </para><para><indexterm significance="normal">
  <primary>iteration</primary>

</indexterm>Running the same code multiple times is called <emphasis role="bold">iteration</emphasis>. It’s so common that there is another statement, the <literal remap="verb" moreinfo="none">for</literal> loop, that expresses it more concisely. For example, we can rewrite the 2-4-6-8 loop this way: </para><programlisting language="java" format="linespecific">for (int i = 2; i &lt;= 8; i += 2) {
    System.out.print(i + ", ");
}
System.out.println("Who do we appreciate?");</programlisting><para><literal remap="verb" moreinfo="none">for</literal> loops have three components in parentheses, separated by semicolons: the initializer, the condition, and the update. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>The <emphasis>initializer</emphasis> runs once at the very beginning of the loop. It is equivalent to the line before the <literal remap="verb" moreinfo="none">while</literal> statement. </para></listitem>
  
  <listitem><para>The <emphasis>condition</emphasis> is checked each time through the loop. If it is <literal remap="verb" moreinfo="none">false</literal>, the loop ends. Otherwise, the body of the loop is executed (again). </para></listitem>
  
  <listitem><para>At the end of each iteration, the <emphasis>update</emphasis> runs, and we go back to step 2. </para></listitem>
  
</orderedlist><para>The <literal remap="verb" moreinfo="none">for</literal> loop is often easier to read because it puts all the loop-related statements at the top of the loop. Doing so allows you to focus on the statements inside the loop body. <xref linkend="fig.for"/> illustrates <literal remap="verb" moreinfo="none">for</literal> loops with a flowchart. </para>
  
  <figure id="fig.for" float="False">
    <title>Flow of execution for a <literal remap="verb" moreinfo="none">for loop.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/for.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>There is another difference between <literal remap="verb" moreinfo="none">for</literal> loops and <literal remap="verb" moreinfo="none">while</literal> loops: if you declare a variable in the initializer, it only exists <emphasis>inside</emphasis> the <literal remap="verb" moreinfo="none">for</literal> loop. For example: </para><programlisting language="java" format="linespecific">for (int n = 3; n &gt; 0; n--) {
    System.out.println(n);
}
System.out.println("n is now " + n);  // compiler error</programlisting><para>The last line tries to display <literal remap="verb" moreinfo="none">n</literal> (for no reason other than demonstration), but it won’t work. If you need to use a loop variable outside the loop, you have to declare it <emphasis>outside</emphasis> the loop, like this: </para><programlisting language="java" format="linespecific">int n;
for (n = 3; n &gt; 0; n--) {
    System.out.println(n);
}
System.out.println("n is now " + n);</programlisting><para>Notice that the <literal remap="verb" moreinfo="none">for</literal> statement does not say <literal remap="verb" moreinfo="none">int n = 3</literal>. Rather, it simply initializes the existing variable <literal remap="verb" moreinfo="none">n</literal>. </para>
</sect1><sect1 id="nested" remap="section">
  <title>Nested Loops</title><para><indexterm significance="normal">
  <primary>loop</primary>
<secondary>nested</secondary>
</indexterm><indexterm significance="normal">
  <primary>nested</primary>
<secondary>loops</secondary>
</indexterm>Like conditional statements, loops can be nested one inside the other. Nested loops allow you to iterate over two variables. For example, we can generate a “multiplication table” like this: </para><programlisting language="java" format="linespecific">for (int x = 1; x &lt;= 10; x++) {
    for (int y = 1; y &lt;= 10; y++) {
        System.out.printf("%4d", x * y);
    }
    System.out.println();
}</programlisting><para><indexterm significance="normal">
  <primary>loop variable</primary>

</indexterm><indexterm significance="normal">
  <primary>variable</primary>
<secondary>loop</secondary>
</indexterm><indexterm significance="normal">
  <primary>inner loop</primary>

</indexterm><indexterm significance="normal">
  <primary>outer loop</primary>

</indexterm>Variables like <literal remap="verb" moreinfo="none">x</literal> and <literal remap="verb" moreinfo="none">y</literal> are called <emphasis role="bold">loop variables</emphasis>, because they control the execution of a loop. In this example, the first loop (<literal remap="verb" moreinfo="none">for x</literal>) is known as the “outer loop”, and the second loop (<literal remap="verb" moreinfo="none">for y</literal>) is known as the “inner loop”. </para><para>Each loop repeats their corresponding statements 10 times. The outer loop iterates from 1 to 10 only once, but the inner loop iterates from 1 to 10 each of those 10 times. As a result, the <literal remap="verb" moreinfo="none">printf</literal> method is invoked 100 times. </para><para><indexterm significance="normal">
  <primary>format specifier</primary>

</indexterm>The format specifier <literal remap="verb" moreinfo="none">%4d</literal> displays the value of <literal remap="verb" moreinfo="none">x * y</literal> padded with spaces so it’s four characters wide. Doing so causes the output to align vertically, regardless of how many digits the numbers have: </para><programlisting format="linespecific">   1   2   3   4   5   6   7   8   9  10
   2   4   6   8  10  12  14  16  18  20
   3   6   9  12  15  18  21  24  27  30
   4   8  12  16  20  24  28  32  36  40
   5  10  15  20  25  30  35  40  45  50
   6  12  18  24  30  36  42  48  54  60
   7  14  21  28  35  42  49  56  63  70
   8  16  24  32  40  48  56  64  72  80
   9  18  27  36  45  54  63  72  81  90
  10  20  30  40  50  60  70  80  90 100</programlisting><para>It’s important to realize that the output is displayed row by row. The inner loop displays a single row of output, followed by a newline. The outer loop iterates over the rows themselves. Another way to read nested loops, like the ones in this example, is “for each row <literal remap="verb" moreinfo="none">x</literal>, and for each column <literal remap="verb" moreinfo="none">y</literal>, …” </para>
</sect1><sect1 id="a0000003406" remap="section">
  <title>Characters</title>
    <para>Some of the most interesting problems in computer science involve searching and manipulating text. In the next few sections, we’ll discuss how to apply loops to strings. Although the examples are short, the techniques work the same whether you have one word or one million words. </para><para><indexterm significance="normal">
  <primary>charAt</primary>

</indexterm><indexterm significance="normal">
  <primary>char</primary>

</indexterm><indexterm significance="normal">
  <primary>type</primary>
<secondary>char</secondary>
</indexterm>Strings provide a method named <literal remap="verb" moreinfo="none">charAt</literal>. It returns a <literal remap="verb" moreinfo="none">char</literal>, a data type that stores an individual character (as opposed to strings of them). </para><programlisting language="java" format="linespecific">String fruit = "banana";
char letter = fruit.charAt(0);</programlisting><para>The argument <literal remap="verb" moreinfo="none">0</literal> means that we want the character at <emphasis role="bold">index</emphasis> 0. String indexes range from 0 to <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, where <emphasis role="math">n</emphasis> is the length of the string. So the character assigned to <literal remap="verb" moreinfo="none">letter</literal> is <literal remap="verb" moreinfo="none">b</literal>. </para> 
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="6">
     
       <colspec colname="c1"/>
     
       <colspec colname="c2"/>
     
       <colspec colname="c3"/>
     
       <colspec colname="c4"/>
     
       <colspec colname="c5"/>
     
       <colspec colname="c6"/>
     
     <tbody>
     <row>
     
       
       <entry><para> b </para/>
     
       
       <entry><para> a </para/>
     
       
       <entry><para> n </para/>
     
       
       <entry><para> a </para/>
     
       
       <entry><para> n </para/>
     
       
       <entry><para> a </para/>
     
     </row><row>
     
       
       <entry><para>0 </para/>
     
       
       <entry><para> 1 </para/>
     
       
       <entry><para> 2 </para/>
     
       
       <entry><para> 3 </para/>
     
       
       <entry><para> 4 </para/>
     
       
       <entry><para> 5 </para/>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 <para>Characters work like the other data types we have seen. You can compare them using relational operators: </para><programlisting language="java" format="linespecific">if (letter == 'A') {
    System.out.println("It's an A!");
}</programlisting><para><indexterm significance="normal">
  <primary>quote mark</primary>

</indexterm><indexterm significance="normal">
  <primary>escape sequence</primary>

</indexterm>Character literals, like <literal remap="verb" moreinfo="none">'A'</literal>, appear in single quotes. Unlike string literals, which appear in double quotes, character literals can only contain a single character. Escape sequences, like <literal remap="verb" moreinfo="none">'\\t'</literal>, are legal because they represent a single character. </para><para>The increment and decrement operators also work with characters. So this loop displays the letters of the alphabet: </para><programlisting language="java" format="linespecific">System.out.print("Roman alphabet: ");
for (char c = 'A'; c &lt;= 'Z'; c++) {
    System.out.print(c);
}
System.out.println();</programlisting><para>The output is: </para><programlisting format="linespecific">ABCDEFGHIJKLMNOPQRSTUVWXYZ</programlisting><para><indexterm significance="normal">
  <primary>Unicode</primary>

</indexterm>Java uses <emphasis role="bold">Unicode</emphasis> to represent characters, so strings can store text in other alphabets like Cyrillic and Greek, and non-alphabetic languages like Chinese. You can read more about it at <ulink url="https://unicode.org/"/>. </para><para>In Unicode, each character is represented by a “code point”, which you can think of as an integer. The code points for uppercase Greek letters run from 913 to 937, so we can display the Greek alphabet like this: </para><programlisting language="java" format="linespecific">System.out.print("Greek alphabet: ");
for (int i = 913; i &lt;= 937; i++) {
    System.out.print((char) i);
}
System.out.println();</programlisting><para>This example uses a type cast to convert each integer (in the range) to the corresponding character. Try running the code and see what happens. </para>
</sect1><sect1 id="a0000003482" remap="section">
  <title>Which Loop to Use</title>
    <para><literal remap="verb" moreinfo="none">for</literal> and <literal remap="verb" moreinfo="none">while</literal> loops have the same capabilities; any <literal remap="verb" moreinfo="none">for</literal> loop can be rewritten as a <literal remap="verb" moreinfo="none">while</literal> loop, and vice versa. For example, we could have printed letters of the alphabet using a <literal remap="verb" moreinfo="none">while</literal> loop: </para><programlisting language="java" format="linespecific">System.out.print("Roman alphabet: ");
char c = 'A';
while (c &lt;= 'Z') {
    System.out.print(c);
    c++;
}
System.out.println();</programlisting><para>You might wonder when to use one or the other. It depends on whether you know how many times the loop will repeat. </para><para>A <literal remap="verb" moreinfo="none">for</literal> loop is “definite”, which means we know, at the beginning of the loop, how many times it will repeat. In the alphabet example, we know it will run 26 times. In that case, it’s better to use a <literal remap="verb" moreinfo="none">for</literal> loop, which puts all of the loop control code on one line. </para><para>A <literal remap="verb" moreinfo="none">while</literal> loop is “indefinite”, which means we don’t know how many times it will repeat. For example, when validating user input as in <xref linkend="validate"/>, it’s impossible to know how many times the user will enter a wrong value. In this case, a <literal remap="verb" moreinfo="none">while</literal> loop is more appropriate. </para><programlisting language="java" format="linespecific">System.out.print("Enter a number: ");
while (!in.hasNextDouble()) {
    String word = in.next();
    System.err.println(word + " is not a number");
    System.out.print("Enter a number: ");
}
double number = in.nextDouble();</programlisting><para>It’s easier to read the <literal remap="verb" moreinfo="none">Scanner</literal> method calls when they’re not all on one line of code. </para>
</sect1><sect1 id="a0000003504" remap="section">
  <title>String Iteration</title>
    <para><indexterm significance="normal">
  <primary>iteration</primary>

</indexterm>Strings provide a method called <literal remap="verb" moreinfo="none">length</literal> that returns the number of characters in the string. The following loop iterates the characters in <literal remap="verb" moreinfo="none">fruit</literal> and displays them, one on each line: </para><programlisting language="java" format="linespecific">for (int i = 0; i &lt; fruit.length(); i++) {
    char letter = fruit.charAt(i);
    System.out.println(letter);
}</programlisting><para><indexterm significance="normal">
  <primary>string</primary>
<secondary>length</secondary>
</indexterm><indexterm significance="normal">
  <primary>length</primary>
<secondary>string</secondary>
</indexterm>Because <literal remap="verb" moreinfo="none">length</literal> is a method, you have to invoke it with parentheses (there are no arguments). When <literal remap="verb" moreinfo="none">i</literal> is equal to the length of the string, the condition becomes <literal remap="verb" moreinfo="none">false</literal> and the loop terminates. </para><para>To find the last letter of a string, you might be tempted to do something like: </para><programlisting language="java" format="linespecific">int length = fruit.length();
char last = fruit.charAt(length);      // wrong!</programlisting><para><indexterm significance="normal">
  <primary>StringIndexOutOfBoundsException</primary>

</indexterm><indexterm significance="normal">
  <primary>exception</primary>
<secondary>StringIndexOutOfBounds</secondary>
</indexterm>This code compiles and runs, but invoking the <literal remap="verb" moreinfo="none">charAt</literal> method throws a <literal remap="verb" moreinfo="none">StringIndexOutOfBoundsException</literal>. The problem is that there is no sixth letter in <literal remap="verb" moreinfo="none">"banana"</literal>. Since we started counting at 0, the 6 letters are indexed from 0 to 5. To get the last character, you have to subtract 1 from <literal remap="verb" moreinfo="none">length</literal>. </para><programlisting language="java" format="linespecific">int length = fruit.length();
char last = fruit.charAt(length - 1);  // correct</programlisting><para>Many string algorithms involve reading one string and building another. For example, to reverse a string, we can concatenate one character at a time: </para><programlisting language="java" format="linespecific">public static String reverse(String s) {
    String r = "";
    for (int i = s.length() - 1; i &gt;= 0; i--) {
        r += s.charAt(i);
    }
    return r;
}</programlisting><para><indexterm significance="normal">
  <primary>empty string</primary>

</indexterm>The initial value of <literal remap="verb" moreinfo="none">r</literal> is <literal remap="verb" moreinfo="none">""</literal>, which is the <emphasis role="bold">empty string</emphasis>. The loop iterates the letters of <literal remap="verb" moreinfo="none">s</literal> in reverse order. Each time through the loop, it creates a new string and assigns it to <literal remap="verb" moreinfo="none">r</literal>. When the loop exits, <literal remap="verb" moreinfo="none">r</literal> contains the letters from <literal remap="verb" moreinfo="none">s</literal> in reverse order. So the result of <literal remap="verb" moreinfo="none">reverse("banana")</literal> is <literal remap="verb" moreinfo="none">"ananab"</literal>. </para>
</sect1><sect1 id="a0000003542" remap="section">
  <title>The indexOf Method</title>
    <para><indexterm significance="normal">
  <primary>indexOf</primary>

</indexterm>To search for a specific character in a string, you could write a <literal remap="verb" moreinfo="none">for</literal> loop and use <literal remap="verb" moreinfo="none">charAt</literal> like in the previous section. However, the <literal remap="verb" moreinfo="none">String</literal> class already provides a method for doing just that. </para><programlisting language="java" format="linespecific">String fruit = "banana";
int index = fruit.indexOf('a');     // returns 1</programlisting><para>This example finds the index of <literal remap="verb" moreinfo="none">'a'</literal> in the string. But the letter appears three times, so it’s not obvious what <literal remap="verb" moreinfo="none">indexOf</literal> might do. According to the documentation, it returns the index of the <emphasis>first</emphasis> appearance. </para><para>To find subsequent appearances, you can use another version of <literal remap="verb" moreinfo="none">indexOf</literal>, which takes a second argument that indicates where in the string to start looking. </para><programlisting language="java" format="linespecific">int index = fruit.indexOf('a', 2);  // returns 3</programlisting><para><indexterm significance="normal">
  <primary>memory diagram</primary>

</indexterm><indexterm significance="normal">
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>To visualize how <literal remap="verb" moreinfo="none">indexOf</literal> and other <literal remap="verb" moreinfo="none">String</literal> methods work, it helps to draw a picture like <xref linkend="fig.banana"/>. The previous code starts at index 2 (the first <literal remap="verb" moreinfo="none">'n'</literal>) and finds the next <literal remap="verb" moreinfo="none">'a'</literal>, which is at index 3. </para>
  
  <figure id="fig.banana" float="False">
    <title>Memory diagram for a <literal remap="verb" moreinfo="none">String of six characters.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/banana.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If the character happens to appear at the starting index, the starting index is the answer. So <literal remap="verb" moreinfo="none">fruit.indexOf('a', 5)</literal> returns <literal remap="verb" moreinfo="none">5</literal>. If the character does not appear in the string, <literal remap="verb" moreinfo="none">indexOf</literal> returns <literal remap="verb" moreinfo="none">-1</literal>. Since indexes cannot be negative, this value indicates the character was not found. </para><para>You can also use <literal remap="verb" moreinfo="none">indexOf</literal> to search for an entire string, not just a single character. For example, the expression <literal remap="verb" moreinfo="none">fruit.indexOf("nan")</literal> returns <literal remap="verb" moreinfo="none">2</literal>. </para>
</sect1><sect1 id="a0000003584" remap="section">
  <title>Substrings</title>
    <para><indexterm significance="normal">
  <primary>substring</primary>

</indexterm>In addition to searching strings, we often need to extract parts of strings. The <literal remap="verb" moreinfo="none">substring</literal> method returns a new string that copies letters from an existing string, given a pair of indexes. </para><itemizedlist>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(0, 3)</literal> returns <literal remap="verb" moreinfo="none">"ban"</literal> </para></listitem>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(2, 5)</literal> returns <literal remap="verb" moreinfo="none">"nan"</literal> </para></listitem>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(6, 6)</literal> returns <literal remap="verb" moreinfo="none">""</literal> </para></listitem>
  
</itemizedlist><para>Notice that the character indicated by the second index is <emphasis>not</emphasis> included. Defining <literal remap="verb" moreinfo="none">substring</literal> this way simplifies some common operations. For example, to select a substring with length <literal remap="verb" moreinfo="none">len</literal>, starting at index <literal remap="verb" moreinfo="none">i</literal>, you could write <literal remap="verb" moreinfo="none">fruit.substring(i, i + len)</literal>. </para><para><indexterm significance="normal">
  <primary>overloaded</primary>

</indexterm>Like most string methods, <literal remap="verb" moreinfo="none">substring</literal> is <emphasis role="bold">overloaded</emphasis>. That is, there are other versions of <literal remap="verb" moreinfo="none">substring</literal> that have different parameters. If it’s invoked with one argument, it returns the letters from that index to the end. </para><itemizedlist>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(0)</literal> returns <literal remap="verb" moreinfo="none">"banana"</literal> </para></listitem>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(2)</literal> returns <literal remap="verb" moreinfo="none">"nana"</literal> </para></listitem>
  
    <listitem><para><literal remap="verb" moreinfo="none">fruit.substring(6)</literal> returns <literal remap="verb" moreinfo="none">""</literal> </para></listitem>
  
</itemizedlist><para>The first example returns a copy of the entire string. The second example returns all but the first two characters. As the last example shows, <literal remap="verb" moreinfo="none">substring</literal> returns the empty string if the argument is the length of the string. </para><para>We could also use <literal remap="verb" moreinfo="none">fruit.substring(2, fruit.length() - 1)</literal> to get the result <literal remap="verb" moreinfo="none">"nana"</literal>. But calling <literal remap="verb" moreinfo="none">substring</literal> with one argument is more convenient when you want the end of the string. </para>
</sect1><sect1 id="strcmp" remap="section">
  <title>String Comparison</title><para><indexterm significance="normal">
  <primary>equals</primary>

</indexterm><indexterm significance="normal">
  <primary>string</primary>
<secondary>comparing</secondary>
</indexterm>When comparing strings, it might be tempting to use the <literal remap="verb" moreinfo="none">==</literal> and <literal remap="verb" moreinfo="none">!=</literal> operators. But that will almost never work. The following code compiles and runs, but it always prints <literal remap="verb" moreinfo="none">"Goodbye!"</literal> regardless what the user types. </para><programlisting language="java" format="linespecific">System.out.print("Play again? ");
String answer = in.nextLine();
if (answer == "yes") {                 // wrong!
    System.out.println("Let's go!");
} else {
    System.out.println("Goodbye!");
}</programlisting><para>The problem is that the <literal remap="verb" moreinfo="none">==</literal> operator checks whether the two operands refer to the <emphasis>same object</emphasis>. Even if answer is <literal remap="verb" moreinfo="none">"yes"</literal>, it will refer to a different object in memory than the literal string <literal remap="verb" moreinfo="none">"yes"</literal> in the code. We’ll learn more about objects and references in the next chapter. </para><para>The correct way to compare strings is with the <literal remap="verb" moreinfo="none">equals</literal> method, like this: </para><programlisting language="java" format="linespecific">if (answer.equals("yes")) {
    System.out.println("Let's go!");
}</programlisting><para>This example invokes <literal remap="verb" moreinfo="none">equals</literal> on <literal remap="verb" moreinfo="none">answer</literal> and passes <literal remap="verb" moreinfo="none">"yes"</literal> as an argument. The <literal remap="verb" moreinfo="none">equals</literal> method returns <literal remap="verb" moreinfo="none">true</literal> if the strings contain the same characters; otherwise it returns <literal remap="verb" moreinfo="none">false</literal>. </para><para><indexterm significance="normal">
  <primary>compareTo</primary>

</indexterm>If two strings differ, we can use <literal remap="verb" moreinfo="none">compareTo</literal> to see which comes first in alphabetical order: </para><programlisting language="java" format="linespecific">String name1 = "Alan Turing";
String name2 = "Ada Lovelace";
int diff = name1.compareTo(name2);
if (diff &lt; 0) {
    System.out.println("name1 comes before name2.");
} else if (diff &gt; 0) {
    System.out.println("name2 comes before name1.");
} else {
    System.out.println("The names are the same.");
}</programlisting><para>The return value from <literal remap="verb" moreinfo="none">compareTo</literal> is the difference between the first characters in the strings that are not the same. In the preceding code, <literal remap="verb" moreinfo="none">compareTo</literal> returns positive 8, because the second letter of <literal remap="verb" moreinfo="none">"Ada"</literal> comes before the second letter of <literal remap="verb" moreinfo="none">"Alan"</literal> by 8 letters. </para><para>If the first string (the one on which the method is invoked) comes earlier in the alphabet, the difference is negative. If it comes later in the alphabet, the difference is positive. If the strings are equal, their difference is zero. </para><para><indexterm significance="normal">
  <primary>case-sensitive</primary>

</indexterm>Both <literal remap="verb" moreinfo="none">equals</literal> and <literal remap="verb" moreinfo="none">compareTo</literal> are case-sensitive. In Unicode, uppercase letters come before lowercase letters. So <literal remap="verb" moreinfo="none">"Ada"</literal> comes before <literal remap="verb" moreinfo="none">"ada"</literal>. </para>
</sect1><sect1 id="a0000003678" remap="section">
  <title>String Formatting</title>
    <para><indexterm significance="normal">
  <primary>printf</primary>

</indexterm>In <xref linkend="printf"/>, we learned how to use <literal remap="verb" moreinfo="none">System.out.printf</literal> to display formatted output. Sometimes programs need to create strings that are formatted a certain way, but not display them immediately (or ever). For example, the following method returns a time string in 12-hour format: </para><programlisting language="java" format="linespecific">public static String timeString(int hour, int minute) {
    String ampm;
    if (hour &lt; 12) {
        ampm = "AM";
        if (hour == 0) {
            hour = 12;  // midnight
        }
    } else {
        ampm = "PM";
        hour = hour - 12;
    }
    return String.format("%02d:%02d %s", hour, minute, ampm);
}</programlisting><para><indexterm significance="normal">
  <primary>string</primary>
<secondary>format</secondary>
</indexterm><literal remap="verb" moreinfo="none">String.format</literal> takes the same arguments as <literal remap="verb" moreinfo="none">System.out.printf</literal>: a format specifier followed by a sequence of values. The main difference is that <literal remap="verb" moreinfo="none">System.out.printf</literal> displays the result on the screen. <literal remap="verb" moreinfo="none">String.format</literal> creates a new string, but does not display anything. </para><para>In this example, the format specifier <literal remap="verb" moreinfo="none">%02d</literal> means “two digit integer padded with zeros”, so <literal remap="verb" moreinfo="none">timeString(19, 5)</literal> returns the string <literal remap="verb" moreinfo="none">"07:05 PM"</literal>. As an exercise, try writing two nested <literal remap="verb" moreinfo="none">for</literal> loops (in <literal remap="verb" moreinfo="none">main</literal>) that invoke <literal remap="verb" moreinfo="none">timeString</literal> and display all possible times over a 24-hour period. </para><para>Be sure to skim through the documentation for <literal remap="verb" moreinfo="none">String</literal>. Knowing what other methods are there will help you avoid reinventing the wheel. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>
</sect1><sect1 id="a0000003701" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>loop:</term>
      <listitem><para><indexterm significance="normal">
  <primary>loop</primary>

</indexterm>A statement that executes a sequence of statements repeatedly. </para></listitem>
  </varlistentry><varlistentry>
    <term>loop body:</term>
      <listitem><para><indexterm significance="normal">
  <primary>loop body</primary>

</indexterm>The statements inside the loop. </para></listitem>
  </varlistentry><varlistentry>
    <term>infinite loop:</term>
      <listitem><para><indexterm significance="normal">
  <primary>infinite loop</primary>

</indexterm>A loop whose condition is always true. </para></listitem>
  </varlistentry><varlistentry>
    <term>increment:</term>
      <listitem><para><indexterm significance="normal">
  <primary>increment</primary>

</indexterm>Increase the value of a variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>decrement:</term>
      <listitem><para><indexterm significance="normal">
  <primary>decrement</primary>

</indexterm>Decrease the value of a variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>iteration:</term>
      <listitem><para><indexterm significance="normal">
  <primary>iteration</primary>

</indexterm>Executing a sequence of statements repeatedly. </para></listitem>
  </varlistentry><varlistentry>
    <term>loop variable:</term>
      <listitem><para><indexterm significance="normal">
  <primary>loop variable</primary>

</indexterm>A variable that is initialized, tested, and updated in order to control a loop. </para></listitem>
  </varlistentry><varlistentry>
    <term>index:</term>
      <listitem><para><indexterm significance="normal">
  <primary>index</primary>

</indexterm>An integer variable or value used to indicate a character in a string. </para></listitem>
  </varlistentry><varlistentry>
    <term>Unicode:</term>
      <listitem><para><indexterm significance="normal">
  <primary>Unicode</primary>

</indexterm>An international standard for representing characters in most of the world’s languages. </para></listitem>
  </varlistentry><varlistentry>
    <term>empty string:</term>
      <listitem><para><indexterm significance="normal">
  <primary>empty string</primary>

</indexterm>The string <literal remap="verb" moreinfo="none">""</literal>, which contains no characters and has a length of zero. </para></listitem>
  </varlistentry><varlistentry>
    <term>overloading:</term>
      <listitem><para><indexterm significance="normal">
  <primary>overloading</primary>

</indexterm>Defining two or more methods with the same name but different parameters. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000003727" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal moreinfo="none">ch06</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="debugger"/>, now might be a good time. It describes the DrJava debugger, which is a useful tool for visualizing the flow of execution through loops. </para><para><example id="a0000003739" role="exercise">
  <title/>
  <para>Consider the following methods (<literal remap="verb" moreinfo="none">main</literal> and <literal remap="verb" moreinfo="none">loop</literal>). </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Draw a table that shows the value of the variables <literal remap="verb" moreinfo="none">i</literal> and <literal remap="verb" moreinfo="none">n</literal> during the execution of <literal remap="verb" moreinfo="none">loop</literal>. The table should contain one column for each variable and one line for each iteration. </para></listitem>
  
  <listitem><para>What is the output of this program? </para></listitem>
  
  <listitem><para>Can you prove that this loop terminates for any positive value of <literal remap="verb" moreinfo="none">n</literal>? </para></listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static void main(String[] args) {
    loop(10);
}

public static void loop(int n) {
    int i = n;
    while (i &gt; 1) {
        System.out.println(i);
        if (i % 2 == 0) {
            i = i / 2;
        } else {
            i = i + 1;
        }
    }
}</programlisting></example> </para><para><example id="a0000003758" role="exercise">
  <title/>
  <para>Let’s say you are given a number, <emphasis role="math">a</emphasis>, and you want to find its square root. One way to do that is to start with a rough guess about the answer, <emphasis role="math">x<subscript>0</subscript></emphasis>, and then improve the guess using this formula: </para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>/</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></informalequation><para> For example, if we want to find the square root of 9, and we start with <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inlineequation>, then <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mn>9</mml:mn><mml:mo>/</mml:mo><mml:mn>6</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>75</mml:mn></mml:mrow></mml:math></inlineequation>, which is closer. We can repeat the procedure, using <emphasis role="math">x<subscript>1</subscript></emphasis> to calculate <emphasis role="math">x<subscript>2</subscript></emphasis>, and so on. In this case, <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>075</mml:mn></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>00091</mml:mn></mml:mrow></mml:math></inlineequation>. So it converges quickly on the correct answer. </para><para>Write a method called <literal remap="verb" moreinfo="none">squareRoot</literal> that takes a <literal remap="verb" moreinfo="none">double</literal> and returns an approximation of the square root of the parameter, using this technique. You should not use <literal remap="verb" moreinfo="none">Math.sqrt</literal>. </para><para>As your initial guess, you should use <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inlineequation>. Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001. You can use <literal remap="verb" moreinfo="none">Math.abs</literal> to calculate the absolute value of the difference. </para>
</example> </para><para><example id="a0000003789" role="exercise">
  <title/>
  <para>One way to evaluate <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> is to use the infinite series expansion: </para><informalequation><mml:math mode="display" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>6</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mo>...</mml:mo></mml:mrow></mml:math></informalequation><para> The <emphasis role="math">i</emphasis>th term in this series is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msup><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inlineequation>. Write a method named <literal remap="verb" moreinfo="none">gauss</literal> that takes <literal remap="verb" moreinfo="none">x</literal> and <literal remap="verb" moreinfo="none">n</literal> as arguments and returns the sum of the first <literal remap="verb" moreinfo="none">n</literal> terms of the series. You should not use <literal remap="verb" moreinfo="none">factorial</literal> or <literal remap="verb" moreinfo="none">pow</literal>. </para>
</example> </para><para><example id="a0000003814" role="exercise">
  <title/>
  <para><indexterm significance="normal">
  <primary>abecedarian</primary>

</indexterm>A word is said to be “abecedarian” if the letters in the word appear in alphabetical order. For example, the following are all six-letter English abecedarian words: </para><blockquote remap="quote"><para> abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy </para></blockquote><para>Write a method called <literal remap="verb" moreinfo="none">isAbecedarian</literal> that takes a <literal remap="verb" moreinfo="none">String</literal> and returns a <literal remap="verb" moreinfo="none">boolean</literal> indicating whether the word is abecedarian. </para>
</example> </para><para><example id="doubloon" role="exercise">
  <title/><para><indexterm significance="normal">
  <primary>doubloon</primary>

</indexterm>A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Here are some example doubloons found in the dictionary: </para><blockquote remap="quote"><para> Abba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto </para></blockquote><para>Write a method called <literal remap="verb" moreinfo="none">isDoubloon</literal> that takes a string and checks whether it is a doubloon. To ignore case, invoke the <literal remap="verb" moreinfo="none">toLowerCase</literal> method before checking. </para>
</example> </para><para><example id="a0000003834" role="exercise">
  <title/>
  <para><indexterm significance="normal">
  <primary>Scrabble</primary>

</indexterm>In Scrabble<footnote><para>Scrabble is a registered trademark owned in the USA and Canada by Hasbro Inc., and in the rest of the world by J. W. Spear &amp; Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.</para></footnote> each player has a set of tiles with letters on them. The object of the game is to use those letters to spell words. The scoring system is complex, but longer words are usually worth more than shorter words. </para><para>Imagine you are given your set of tiles as a string, like <literal remap="verb" moreinfo="none">"quijibo"</literal>, and you are given another string to test, like <literal remap="verb" moreinfo="none">"jib"</literal>. </para><para>Write a method called <literal remap="verb" moreinfo="none">canSpell</literal> that takes two strings and checks whether the set of tiles can spell the word. You might have more than one tile with the same letter, but you can only use each tile once. </para>
</example> </para>
</sect1>
</chapter>
