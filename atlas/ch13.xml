<chapter id="a0000010518">
  <title>Objects of Arrays</title>
  
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>In the previous chapter, we defined a class to represent cards and used an array of <literal moreinfo="none">Card</literal> objects to represent a deck. In this chapter, we take additional steps toward object-oriented programming. </para>

  
  <para>First we define a class to represent a deck of cards. Then we present algorithms for shuffling and sorting decks. Finally, we introduce <literal moreinfo="none">ArrayList</literal> from the Java library and use it to represent collections of cards. </para>
<sect1 id="deck" remap="section">
  <title>Decks of Cards</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Here is the beginning of a <literal moreinfo="none">Deck</literal> class that encapsulates an array of <literal moreinfo="none">Card</literal> objects: </para>
<programlisting language="java" format="linespecific">public class Deck {
    private Card[] cards;

    public Deck(int n) {
        this.cards = new Card[n];
    }

    public Card[] getCards() {
        return this.cards;
    }
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>The constructor initializes the instance variable with an array of <literal moreinfo="none">n</literal> cards, but it doesn’t create any <literal moreinfo="none">Card</literal> objects. <xref linkend="fig.deckobject"/> shows what a <literal moreinfo="none">Deck</literal> looks like with no cards. </para>

  
  <figure id="fig.deckobject" float="False">
    <title>Memory diagram of an unpopulated <literal moreinfo="none">Deck</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/deckobject.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

  
  <para>We’ll add another constructor that creates a standard 52-card array and populates it with <literal moreinfo="none">Card</literal> objects: </para>
<programlisting language="java" format="linespecific">public Deck() {
    this.cards = new Card[52];
    int index = 0;
    for (int suit = 0; suit &lt;= 3; suit++) {
        for (int rank = 1; rank &lt;= 13; rank++) {
            this.cards[index] = new Card(rank, suit);
            index++;
        }
    }
}</programlisting><para>This method is similar to the example in <xref linkend="cardarray"/>; we just turned it into a constructor. We can use it to create a complete <literal moreinfo="none">Deck</literal> like this: </para>
<programlisting language="java" format="linespecific">Deck deck = new Deck();</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm>Now that we have a <literal moreinfo="none">Deck</literal> class, we have a logical place to put methods that pertain to decks. Looking at the methods we have written so far, one obvious candidate is <literal moreinfo="none">printDeck</literal> from <xref linkend="cardarray"/>. Here’s how it looks, rewritten as an instance method of <literal moreinfo="none">Deck</literal>: </para>
<programlisting language="java" format="linespecific">public void print() {
    for (Card card : this.cards) {
        System.out.println(card);
    }
}</programlisting><para>Notice that when we transform a static method into an instance method, the code is shorter. Here’s how we invoke it: </para>
<programlisting language="java" format="linespecific">deck.print();</programlisting></sect1><sect1 id="shuffle" remap="section">
  <title>Shuffling Decks</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm>For most card games, you have to shuffle the deck; that is, put the cards in a random order. In <xref linkend="random"/> we saw how to generate random numbers, but it is not obvious how to use them to shuffle a deck. </para>

  
  <para>One possibility is to model the way humans shuffle; for example, we could divide the deck in two halves and then choosing alternately from each one. Since humans usually don’t shuffle perfectly, after about seven iterations the order of the deck is pretty well randomized. </para>

  
  <para>But a computer program would have the annoying property of doing a perfect shuffle every time, which is not very random. In fact, after eight perfect shuffles, you would find the deck back in the order you started in! For more on this, see <ulink url="https://en.wikipedia.org/wiki/Faro_shuffle"/>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>A better shuffling algorithm is to traverse the deck one card at a time, and at each iteration, choose two cards and swap them. To outline this algorithm, we’ll use a combination of Java statements and English comments. This technique is sometimes called <emphasis role="bold">pseudocode</emphasis>. </para>
<programlisting language="java" format="linespecific">public void shuffle() {
    for each index i {
        // choose a random number between i and length - 1
        // swap the ith card and the randomly-chosen card
    }
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>The nice thing about pseudocode is that it often makes clear what other methods you are going to need. In this case, we need a method that chooses a random integer in a given range and a method that takes two indexes and swaps the cards at those positions. </para>
<programlisting language="java" format="linespecific">private static int randomInt(int low, int high) {
    // return a random number between low and high, 
    // including both
}

private void swapCards(int i, int j) {
    // swap the ith and the jth cards in the array
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Methods like <literal moreinfo="none">randomInt</literal> and <literal moreinfo="none">swapCards</literal> are called <emphasis role="bold">helper methods</emphasis>, because they help you solve parts of the problem. Helper methods are often <literal moreinfo="none">private</literal>, because they are only used by methods in the class, and are not needed by methods in other classes. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>The process of writing pseudocode first and then writing helper methods to make it work is a kind of <emphasis role="bold">top-down design</emphasis> (see <ulink url="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design"/>). It is an alternative to “incremental development” and “encapsulation and generalization”, the other design processes you have seen in this book. </para>

  
  <para>One of the exercises at the end of the chapter asks you to write the helper methods <literal moreinfo="none">randomInt</literal> and <literal moreinfo="none">swapCards</literal>, and use them to implement <literal moreinfo="none">shuffle</literal>. </para>

  
  <para>When you do the exercise, notice that <literal moreinfo="none">randomInt</literal> is a class method and <literal moreinfo="none">swapCards</literal> is an instance method. Do you understand why? </para>

</sect1><sect1 id="sorting" remap="section">
  <title>Selection Sort</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Now that we have shuffled the deck, we need a way to put it back in order. There is an algorithm for sorting that is ironically similar to the algorithm for shuffling. It’s called <emphasis role="bold">selection sort</emphasis>, because it works by traversing the array repeatedly and selecting the lowest (or highest) remaining card each time. </para>

  
  <para>During the first iteration, we find the lowest card and swap it with the card in the 0th position. During the <emphasis role="math">i</emphasis>th iteration, we find the lowest card to the right of <emphasis role="math">i</emphasis> and swap it with the <emphasis role="math">i</emphasis>th card. Here is pseudocode for selection sort: </para>
<programlisting language="java" format="linespecific">public void selectionSort() {
    for each index i {
        // find the lowest card at or to the right of i
        // swap the ith card and the lowest card found
    }
}</programlisting><para>Again, the pseudocode helps with the design of the helper methods. For this algorithm we can reuse <literal moreinfo="none">swapCards</literal> from the previous section, so we only need a method to find the lowest card; we’ll call it <literal moreinfo="none">indexLowest</literal>. </para>
<programlisting language="java" format="linespecific">private int indexLowest(int low, int high) {
    // find the lowest card between low and high
}</programlisting><para>One of the exercises at the end of the chapter asks you to write <literal moreinfo="none">indexLowest</literal>, and then use it and <literal moreinfo="none">swapCards</literal> to implement <literal moreinfo="none">selectionSort</literal>. </para>

</sect1><sect1 id="mergesort" remap="section">
  <title>Merge Sort</title><para><indexterm significance="normal">
  <primary></primary>

</indexterm>Selection sort is a simple algorithm, but it is not very efficient. To sort <emphasis role="math">n</emphasis> items, it has to traverse the array <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation> times. Each traversal takes an amount of time proportional to <emphasis role="math">n</emphasis>. The total time, therefore, is proportional to <emphasis role="math">n<superscript>2</superscript></emphasis>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>We will develop a more efficient algorithm called <emphasis role="bold">merge sort</emphasis>. To sort <emphasis role="math">n</emphasis> items, merge sort takes time proportional to <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation>. That may not seem impressive, but as <emphasis role="math">n</emphasis> gets big, the difference between <emphasis role="math">n<superscript>2</superscript></emphasis> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation> can be enormous. </para>

  
  <para>For example, <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub></mml:math></inlineequation> of one million is around 20. So if you had to sort a million numbers, merge sort would require 20 million steps. But selection sort would require one trillion steps! </para>

  
  <para>The idea behind merge sort is this: if you have two decks, each of which has already been sorted, you can quickly merge them into a single, sorted deck. Try this out with a deck of cards: </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Form two decks with about 10 cards each, and sort them so they are face up with the lowest cards on top. Place the decks in front of you. </para>
</listitem>
  
  <listitem>
  
  <para>Compare the top card from each deck and choose the lower one. Flip it over and add it to the merged deck. </para>
</listitem>
  
  <listitem>
  
  <para>Repeat step 2 until one of the decks is empty. Then take the remaining cards and add them to the merged deck. </para>
</listitem>
  
</orderedlist>
  
  <para>The result should be a single sorted deck. In the next few sections, we’ll explain how to implement this algorithm in Java. </para>

</sect1><sect1 id="subdeck" remap="section">
  <title>Subdecks</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The first step of merge sort is to split the deck into two “subdecks”, each with about half of the cards. So we need a method that takes a deck, and a range of indexes, and returns a new deck that contains the specified subset of cards. </para>
<programlisting language="java" format="linespecific">public Deck subdeck(int low, int high) {
    Deck sub = new Deck(high - low + 1);
    for (int i = 0; i &lt; sub.cards.length; i++) {
        sub.cards[i] = this.cards[low + i];
    }
    return sub;
}</programlisting><para>The first line creates an unpopulated <literal moreinfo="none">Deck</literal> object that contains an array of <literal moreinfo="none">null</literal> references. Inside the <literal moreinfo="none">for</literal> loop, the subdeck gets populated with references to <literal moreinfo="none">Card</literal> objects. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The length of the subdeck is <literal moreinfo="none">high - low + 1</literal>, because both the low card and the high card are included. This sort of computation can be confusing, and forgetting the “<literal moreinfo="none">+ 1</literal>” often leads to <emphasis role="bold">off-by-one</emphasis> errors. Drawing a picture is usually the best way to avoid them. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><xref linkend="fig.subdeck"/> is a memory diagram of a subdeck with <literal moreinfo="none">low = 0</literal> and <literal moreinfo="none">high = 4</literal>. The result is a hand with five cards that are <emphasis>shared</emphasis> with the original deck; that is, they are aliased. </para>

  
  <figure id="fig.subdeck" float="False">
    <title>Memory diagram showing the effect of <literal moreinfo="none">subdeck</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/subdeck.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>Aliasing might not be a good idea, because changes to shared cards would be reflected in multiple decks. But since <literal moreinfo="none">Card</literal> objects are immutable, this kind of aliasing is not a problem. And it saves some memory because we don’t create duplicate <literal moreinfo="none">Card</literal> objects. </para>

</sect1><sect1 id="a0000010764" remap="section">
  <title>Merging Decks</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The next helper method we need is <literal moreinfo="none">merge</literal>, which takes two sorted subdecks and returns a new deck containing all cards from both decks, in order. Here’s what the algorithm looks like in pseudocode, assuming the subdecks are named <literal moreinfo="none">d1</literal> and <literal moreinfo="none">d2</literal>: </para>
<programlisting language="java" format="linespecific">private static Deck merge(Deck d1, Deck d2) {
    // create a new deck, d3, big enough for all the cards

    // use the index i to keep track of where we are at in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;

    // the index k traverses the result deck
    for (int k = 0; k &lt; d3.length; k++) {
        // if d1 is empty, use top card from d2
        // if d2 is empty, use top card from d1
        // otherwise, compare the top two cards

        // add lowest card to the new deck at k
        // increment i or j (depending on card)
    }
    // return the new deck
}</programlisting><para>An exercise at the end of the chapter asks you to implement <literal moreinfo="none">merge</literal>. It’s a little tricky, so be sure to test it with different subdecks. Once your <literal moreinfo="none">merge</literal> method is working, you can use it to write a simplified version of merge sort: </para>
<programlisting language="java" format="linespecific">public Deck almostMergeSort() {
    // divide the deck into two subdecks
    // sort the subdecks using selectionSort
    // merge the subdecks, return the result
}</programlisting><para>If you have working versions of <literal moreinfo="none">subdeck</literal>, <literal moreinfo="none">selectionSort</literal>, and <literal moreinfo="none">merge</literal>, you should have no trouble getting this method working. But it is still not very efficient, because it uses <literal moreinfo="none">selectionSort</literal> to sort the subdecks. We can make it more efficient if we use <literal moreinfo="none">mergeSort</literal> instead, but that means we have to make it recursive! </para>

</sect1><sect1 id="a0000010794" remap="section">
  <title>Adding Recursion</title>
    
  
  <para>To make <literal moreinfo="none">mergeSort</literal> work recursively, you have to add a base case; otherwise it repeats forever. </para>

  
  <para>The simplest base case is a subdeck with 1 cards. If there is only one card, it can’t be out of order, so we consider it sorted. And if it is already sorted, we can just return it. </para>

  
  <para>And it will turn out to be convenient if we handle another base case, a subdeck with 0 cards. By the same logic, if there are no cards, they can’t be out of order. So we consider an empty deck to be sorted, and return it. </para>

  
  <para>With these base cases, a recursive version of <literal moreinfo="none">mergeSort</literal> looks like this: </para>
<programlisting language="java" format="linespecific">public Deck mergeSort() {
    // if the deck has 0 or 1 cards, return it
    // otherwise, divide the deck into two subdecks
    // sort the subdecks using mergeSort
    // merge the subdecks
    // return the result
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm>As usual, there are two ways to think about recursive programs: you can follow the flow of execution, or you can make the “leap of faith” (see <xref linkend="fibonacci"/>). This example should encourage you to make the leap of faith. </para>

  
  <para>When you use <literal moreinfo="none">selectionSort</literal> to sort the subdecks, you don’t feel compelled to follow the flow of execution. You assume it works because you already debugged it. When you make <literal moreinfo="none">mergeSort</literal> recursive, you just replace one sorting algorithm with another. There is no reason to read the program differently. </para>

  
  <para>Well, almost. You have to think about the base cases and make sure that you reach them. But other than that, writing the recursive version should be no problem. </para>

  
  <para>As an exercise at the end of this chapter, you’ll have a chance to finish it off. </para>

</sect1><sect1 id="a0000010817" remap="section">
  <title>Static Context</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><xref linkend="fig.deck"/> shows a UML class diagram for <literal moreinfo="none">Deck</literal>, including the instance variable, <literal moreinfo="none">cards</literal>, and the methods we have so far. In UML diagrams, <literal moreinfo="none">private</literal> attributes and methods begin with a minus sign (<literal moreinfo="none">-</literal>) and <literal moreinfo="none">static</literal> methods are underlined. </para>

  
  <figure id="fig.deck" float="False">
    <title>UML diagram for the <literal moreinfo="none">Deck</literal> class.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/deck.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

  
  <para>The helper methods <literal moreinfo="none">randomInt</literal> and <literal moreinfo="none">merge</literal> are <literal moreinfo="none">static</literal>, because they do not read or write any instance variables. All other methods are instance methods, because they access the instance variable, <literal moreinfo="none">cards</literal>. </para>

  
  <para>When you have static methods and instance methods in the same class, it is easy to get them confused. </para>

  
  <para>To invoke an instance method, you need an instance: </para>
<programlisting language="java" format="linespecific">Deck deck = new Deck();
deck.print();  // correct</programlisting><para><literal moreinfo="none">Deck</literal> with a capital <literal moreinfo="none">D</literal> is a class, and <literal moreinfo="none">deck</literal> with a lowercase <literal moreinfo="none">d</literal> is an object. </para>

  
  <para>If you try to invoke <literal moreinfo="none">print</literal> like this: </para>
<programlisting language="java" format="linespecific">Deck.print();  // wrong!</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>You get an compiler error like this: </para><programlisting format="linespecific">Non-static method print() cannot be referenced from a
static context.</programlisting><para>By “static context”, the compiler means you are trying to invoke a method in a context that requires a static method. </para>

  
  <para>On the other hand, if you have a <literal moreinfo="none">Deck</literal> object, you can use it to invoke a static method: </para>
<programlisting language="java" format="linespecific">Deck deck = new Deck();
int i = deck.randomInt(0, 51);  // legal, but not good style</programlisting><para>This is legal, but it is not considered good style, because someone reading this code would expect <literal moreinfo="none">randomInt</literal> to be an instance method. </para>

  
  <para>Another common error is to use <literal moreinfo="none">this</literal> in a static method. For example, if you write something like this: </para>
<programlisting language="java" format="linespecific">private static Deck merge(Deck d1, Deck d2) {
    return this.cards;  // wrong!
}</programlisting><para>You get a compiler error like this: </para><programlisting format="linespecific">Non-static variable this cannot be referenced from a
static context.</programlisting><para>The problem is that <literal moreinfo="none">cards</literal> is an instance variable, so it is “non-static”, so you can’t access it from a static method. In general, you can’t use <literal moreinfo="none">this</literal> in a static method, because a static method is not invoked on an object. </para>

  
  <para>For beginners, error messages about non-static context can be confusing and frustrating. We hope this section helps. </para>

</sect1><sect1 id="a0000010899" remap="section">
  <title>Piles of Cards</title>
    
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Now that we have classes that represent cards and decks, let’s use them to make a game. One of the simplest card games that children play is called “War” (see <ulink url="https://en.wikipedia.org/wiki/War_(card_game)"/>). </para>

  
  <para>Initially, the deck is divided evenly into two piles, one for each player. During each round, each player takes the top card from their pile and places it, face up, in the center. Whoever has the highest ranking card, ignoring suit, takes the two cards and adds them to the bottom of their pile. The game continues until one player has won the entire deck. </para>

  
  <para>We could use the <literal moreinfo="none">Deck</literal> class to represent the individual piles. However, our implementation of <literal moreinfo="none">Deck</literal> uses a <literal moreinfo="none">Card</literal> array, and the length of an array can’t change. As the game progresses, we need to be able to add and remove cards from the piles. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>We can solve this problem with an <literal moreinfo="none">ArrayList</literal>, which is in the <literal moreinfo="none">java.util</literal> package. An <literal moreinfo="none">ArrayList</literal> is a <emphasis role="bold">collection</emphasis>, which is an object that contains other objects. It provides methods to add and remove elements, and it grows and shrinks automatically. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>We define a new class named <literal moreinfo="none">Pile</literal> to represent a pile of cards. It uses an <literal moreinfo="none">ArrayList</literal> to store <literal moreinfo="none">Card</literal> objects. </para>
<programlisting language="java" format="linespecific">public class Pile {
    private ArrayList&lt;Card&gt; cards;

    public Pile() {
        this.cards = new ArrayList&lt;Card&gt;();
    }
}</programlisting><para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm>When you declare an <literal moreinfo="none">ArrayList</literal>, you specify the type it contains in angle brackets (<literal moreinfo="none">&lt;&gt;</literal>). This declaration says that <literal moreinfo="none">cards</literal> is not just an <literal moreinfo="none">ArrayList</literal>; it’s an <literal moreinfo="none">ArrayList</literal> of <literal moreinfo="none">Card</literal> objects. </para>

  
  <para>The constructor initializes <literal moreinfo="none">this.cards</literal> with an empty <literal moreinfo="none">ArrayList</literal>. </para>

  
  <para>Now let’s think about the methods we need to play the game. </para>

  
  <para>At the beginning of each round, each player draws a card from the top of their pile. So we define a method to do that: </para>
<programlisting language="java" format="linespecific">public Card popCard() {
    return this.cards.remove(0);  // from the top of the pile
}</programlisting><para><literal moreinfo="none">popCard</literal> removes the <literal moreinfo="none">Card</literal> at the beginning of the <literal moreinfo="none">ArrayList</literal>, which we think of as the top of the pile. </para>

  
  <para>Because we use <literal moreinfo="none">ArrayList.remove</literal>, it automatically shifts the remaining cards to fill the gap. </para>

  
  <para>At the end of each round, the winner adds cards to the bottom of their pile. So we define a method to do that: </para>
<programlisting language="java" format="linespecific">public void addCard(Card card) {
    this.cards.add(card);        // to the bottom of the pile
}</programlisting><para><literal moreinfo="none">ArrayList</literal> provides a method, <literal moreinfo="none">add</literal>, that adds an element to the end of the collection, which we think of as the bottom of the pile. </para>

  
  <para>To know when to stop the game, have to check if one of the piles is empty. Here’s a method to do that: </para>
<programlisting language="java" format="linespecific">public boolean isEmpty() {
    return this.cards.isEmpty();
}</programlisting><para>So far, these methods don’t do very much; they just invoke methods on the instance variable, <literal moreinfo="none">cards</literal>. Methods like these are called <emphasis role="bold">wrapper methods</emphasis> because they wrap one method with another. </para>

  
  <para>Finally, to start the game, we need to divide the deck into two equal parts. We can do that with <literal moreinfo="none">subdeck</literal> from <xref linkend="subdeck"/> and a new method, <literal moreinfo="none">addDeck</literal>: </para>
<programlisting language="java" format="linespecific">public void addDeck(Deck deck) {
    for (Card card : deck.getCards()) {
        this.cards.add(card);
    }
}</programlisting><para><literal moreinfo="none">addDeck</literal> takes a <literal moreinfo="none">Deck</literal> object, loops through the cards, and adds them to the <literal moreinfo="none">Pile</literal>. Notice that it does not remove the cards from the <literal moreinfo="none">Deck</literal>, so the <literal moreinfo="none">Deck</literal> and the <literal moreinfo="none">Pile</literal> share cards. But that won’t be a problem because cards are immutable. </para>

</sect1><sect1 id="a0000011010" remap="section">
  <title>Playing War</title>
    
  
  <para>Now we can use <literal moreinfo="none">Deck</literal> and <literal moreinfo="none">Pile</literal> to implement the game. We’ll start by creating a deck and shuffling: </para>
<programlisting language="java" format="linespecific">Deck deck = new Deck();
deck.shuffle();</programlisting><para>Then we divide the <literal moreinfo="none">Deck</literal> into two piles: </para>
<programlisting language="java" format="linespecific">Pile p1 = new Pile();
p1.addDeck(deck.subdeck(0, 25));

Pile p2 = new Pile();
p2.addDeck(deck.subdeck(26, 51));</programlisting><para>The game itself is a loop that repeats until one of the piles is empty. At each iteration, we draw a card from each pile and compare their ranks. </para>
<programlisting language="java" format="linespecific">while (!p1.isEmpty() &amp;&amp; !p2.isEmpty()) {
    // pop a card from each pile
    Card c1 = p1.popCard();
    Card c2 = p2.popCard();

    // compare the cards
    int diff = c1.getRank() - c2.getRank();
    if (diff &gt; 0) {
        p1.addCard(c1);
        p1.addCard(c2);
    } else if (diff &lt; 0) {
        p2.addCard(c1);
        p2.addCard(c2);
    } else {  
        // it's a tie
    }</programlisting><para>If the two cards have the same rank, it’s a tie. In that case, each player draws four more cards. Whoever has the higher fourth card takes all cards in play. If there’s another tie, they draw another four cards, and so on. </para>

  
  <para>One of the exercises at the end of this chapter asks you to implement the <literal moreinfo="none">else</literal> block when there’s a tie. </para>

  
  <para>After the <literal moreinfo="none">while</literal> loop ends, we display the winner based on which pile is not empty. </para>
<programlisting language="java" format="linespecific">if (p2.isEmpty()) {
    System.out.println("Player 1 wins!");
} else {
    System.out.println("Player 2 wins!");
}</programlisting><para><literal moreinfo="none">ArrayList</literal> provides many other methods that we didn’t use for this example. Take a minute to read the documentation, which you can find by doing a web search for “Java ArrayList”. </para>

</sect1><sect1 id="a0000011038" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>pseudocode:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A way of designing programs by writing rough drafts in a combination of English and Java. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>helper method:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A method that implements part of a more complex algorithm; often it is not particularly useful on its own. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>top-down design:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>Breaking down a problem into sub-problems, and solving each sub-problem one at a time. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>selection sort:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A simple sorting algorithm that searches for the smallest or largest element <emphasis role="math">n</emphasis> times. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>merge sort:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A recursive sorting algorithm that divides an array into two parts, sorts each part (using merge sort), and merges the results. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>off-by-one:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A common programming mistake that results in iterating one time too many, or too few. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>static context:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>The parts of a class that run without reference to a specific instance of the class. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>collection:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A Java library class, like <literal moreinfo="none">ArrayList</literal>, that represents a group of objects. </para>
</listitem>
  </varlistentry><varlistentry>
    <term>wrapper method:</term>
      <listitem>
  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm>A method that calls another method without doing much additional work. </para>
</listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="ex.shuffle" remap="section">
  <title>Exercises</title>
    
  
  <para>The code for this chapter is in the <literal moreinfo="none">ch13</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para>

  
  <para><example id="a0000011079" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>Write a <literal moreinfo="none">toString</literal> method for the <literal moreinfo="none">Deck</literal> class. It should return a single string that represents the cards in the deck. When it’s printed, this string should display the same results as the <literal moreinfo="none">print</literal> method in <xref linkend="deck"/>. </para>

  
  <para><indexterm significance="normal">
  <primary></primary>

</indexterm><indexterm significance="normal">
  <primary></primary>

</indexterm><emphasis>Hint:</emphasis> You can use the <literal moreinfo="none">+</literal> operator to concatenate strings, but it is not very efficient. Consider using <literal moreinfo="none">java.lang.StringBuilder</literal> instead; see <xref linkend="stringbuilder"/>. </para>

  
  <para><example id="a0000011102" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000011104" role="exercise">
  <title/>
  <div></div>
</example></para>

  
  <para>The goal of this exercise is to implement the shuffling algorithm from this chapter. </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>In the repository for this book, you should find the file named <literal moreinfo="none">Deck.java</literal>. Check that you can compile it in your environment. </para>
</listitem>
  
  <listitem>
  
  <para>Implement the <literal moreinfo="none">randomInt</literal> method. You can use the <literal moreinfo="none">nextInt</literal> method provided by <literal moreinfo="none">java.util.Random</literal>, which we saw in <xref linkend="random"/>. </para>

  
  <para><emphasis>Hint:</emphasis> To avoid creating a <literal moreinfo="none">Random</literal> object every time <literal moreinfo="none">randomInt</literal> is invoked, consider defining a class variable. </para>
</listitem>
  
  <listitem>
  
  <para>Write a <literal moreinfo="none">swapCards</literal> method that takes two indexes and swaps the cards at the given locations. </para>
</listitem>
  
  <listitem>
  
  <para>Fill in the <literal moreinfo="none">shuffle</literal> method using the algorithm in <xref linkend="shuffle"/>. </para>
</listitem>
  
</orderedlist>
  
  <para><example id="a0000011141" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000011143" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>The goal of this exercise is to implement the sorting algorithms from this chapter. Use the <literal moreinfo="none">Deck.java</literal> file from the previous exercise, or create a new one from scratch. </para>
<orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem>
  
  <para>Implement the <literal moreinfo="none">indexLowest</literal> method. Use the <literal moreinfo="none">Card.compareTo</literal> method to find the lowest card in a given range of the deck, from <literal moreinfo="none">lowIndex</literal> to <literal moreinfo="none">highIndex</literal>, including both. </para>
</listitem>
  
  <listitem>
  
  <para>Fill in <literal moreinfo="none">selectionSort</literal> using the algorithm in <xref linkend="sorting"/>. </para>
</listitem>
  
  <listitem>
  
  <para>Using the pseudocode in <xref linkend="mergesort"/>, implement the <literal moreinfo="none">merge</literal> method. The best way to test it is to build and shuffle a deck. Then use <literal moreinfo="none">subdeck</literal> to form two small subdecks, and use selection sort to sort them. Finally, pass the two halves to <literal moreinfo="none">merge</literal> and see if it works.<indexterm significance="normal">
  <primary></primary>

</indexterm></para>
</listitem>
  
  <listitem>
  
  <para>Fill in <literal moreinfo="none">almostMergeSort</literal>, which divides the deck in half, then uses <literal moreinfo="none">selectionSort</literal> to sort the two halves, and uses <literal moreinfo="none">merge</literal> to create a new, sorted deck. You should be able to reuse code from the previous step. </para>
</listitem>
  
  <listitem>
  
  <para>Implement <literal moreinfo="none">mergeSort</literal> recursively. Remember that <literal moreinfo="none">selectionSort</literal> is a modifier and <literal moreinfo="none">mergeSort</literal> is a pure method, which means that they get invoked differently: </para>
<programlisting language="java" format="linespecific">deck.selectionSort();      // modifies an existing deck
deck = deck.mergeSort();   // replaces old deck with new</programlisting></listitem>
  
</orderedlist>
  
  <para><example id="a0000011195" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000011197" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>You can learn more about the sorting algorithms presented in this chapter at <ulink url="https://www.toptal.com/developers/sorting-algorithms"/>. This site provides explanations of the algorithms, along with animations that show how they work. It also includes an analysis of their efficiency. </para>

  
  <para>For example, “insertion sort” is an algorithm that inserts elements into place, one at a time. Read about it on the website and play the animations. Then write a method named <literal moreinfo="none">insertionSort</literal> that implements this algorithm. </para>

  
  <para>One goal of this exercise is to practice top-down design. Your solution should use a helper method, named <literal moreinfo="none">insert</literal>, that implements the inner loop of the algorithm. <literal moreinfo="none">insertionSort</literal> should invoke this method <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation> times. </para>

  
  <para><example id="a0000011210" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para><example id="a0000011212" role="exercise">
  <title/>
  <div></div>
</example> </para>

  
  <para>Find and open the file <literal moreinfo="none">War.java</literal> in the repository. The <literal moreinfo="none">main</literal> method contains all the code from the last section of this chapter. Check that you can compile and run this code before proceeding. </para>

  
  <para>The program is incomplete; it does not handle the case when two cards have the same rank. Finish implementing the <literal moreinfo="none">main</literal> method, beginning at the line that says: <literal moreinfo="none">// it’s a tie</literal>. </para>

  
  <para>When there’s a tie, draw three cards from each pile and store them in a collection, along with the original two. Then draw one more card from each pile and compare them. Whoever wins the tie takes all ten of these cards. </para>

  
  <para>If one pile does not have at least four cards, the game ends immediately. If a tie ends with a tie, draw three more cards, and so on. </para>

  
  <para>Notice that this program depends on <literal moreinfo="none">Deck.shuffle</literal> so you might have to do <xref linkend="ex.shuffle"/> first. </para>

  
  <para><example id="a0000011231" role="exercise">
  <title/>
  <div></div>
</example> </para>

</sect1>
</chapter>
