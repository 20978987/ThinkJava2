<chapter id="mutable">
  <title>Mutable Objects</title><para><indexterm significance="normal">
  <primary>String class</primary>

</indexterm><indexterm significance="normal">
  <primary>type</primary>
<secondary>String</secondary>
</indexterm>As you learned in the previous chapter, an object is a collection of data that provides a set of methods. For example, a <literal remap="verb" moreinfo="none">String</literal> is a collection of characters that provides methods like <literal remap="verb" moreinfo="none">charAt</literal> and <literal remap="verb" moreinfo="none">substring</literal>. </para><para>In this chapter, we’ll explore two new types of objects: <literal remap="verb" moreinfo="none">Point</literal> and <literal remap="verb" moreinfo="none">Rectangle</literal>. We’ll see how to write methods that take objects as parameters and produce objects as return values. </para><para>We will also take a first look at the source code for the Java library. </para><sect1 id="point" remap="section">
  <title>Point Objects</title><para><indexterm significance="normal">
  <primary>coordinate</primary>

</indexterm>In math, 2D “points” are often written in parentheses with a comma separating the coordinates. For example, <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> indicates the origin, and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> indicates the point <emphasis role="math">x</emphasis> units to the right and <emphasis role="math">y</emphasis> units up from the origin. </para><para><indexterm significance="normal">
  <primary>AWT</primary>

</indexterm><indexterm significance="normal">
  <primary>java.awt</primary>

</indexterm><indexterm significance="normal">
  <primary>Point</primary>

</indexterm><indexterm significance="normal">
  <primary>class</primary>
<secondary>Point</secondary>
</indexterm>The <literal remap="verb" moreinfo="none">java.awt</literal> package provides a class named <literal remap="verb" moreinfo="none">Point</literal> that represents a location in a Cartesian plane. In order to use the <literal remap="verb" moreinfo="none">Point</literal> class, you have to import it: </para><programlisting language="java" format="linespecific">import java.awt.Point;</programlisting><para><indexterm significance="normal">
  <primary>new</primary>

</indexterm><indexterm significance="normal">
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm>Then, to create a new point, you use the <literal remap="verb" moreinfo="none">new</literal> operator: </para><programlisting language="java" format="linespecific">Point blank;
blank = new Point(3, 4);</programlisting><para><indexterm significance="normal">
  <primary>memory diagram</primary>

</indexterm><indexterm significance="normal">
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm><indexterm significance="normal">
  <primary>declaration</primary>

</indexterm><indexterm significance="normal">
  <primary>statement</primary>
<secondary>declaration</secondary>
</indexterm><indexterm significance="normal">
  <primary>reference</primary>

</indexterm>The first line declares that <literal remap="verb" moreinfo="none">blank</literal> has type <literal remap="verb" moreinfo="none">Point</literal>. The second line creates the new <literal remap="verb" moreinfo="none">Point</literal> with the coordinates <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inlineequation>. The result of the <literal remap="verb" moreinfo="none">new</literal> operator is a <emphasis>reference</emphasis> to the object. <xref linkend="fig.reference"/> shows the result. </para>
  
  <figure id="fig.reference" float="False">
    <title>Memory diagram showing a variable that refers to a <literal remap="verb" moreinfo="none">Point object.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/reference.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>As usual, the name of the variable <literal remap="verb" moreinfo="none">blank</literal> appears outside the box, and its value appears inside the box. In this case, the value is a reference, which is represented with an arrow. The arrow points to the <literal remap="verb" moreinfo="none">Point</literal> object, which contains two variables, <literal remap="verb" moreinfo="none">x</literal> and <literal remap="verb" moreinfo="none">y</literal>. </para><para><indexterm significance="normal">
  <primary>attribute</primary>

</indexterm><indexterm significance="normal">
  <primary>dot notation</primary>

</indexterm>Variables that belong to an object are called <emphasis role="bold">attributes</emphasis>. In some documentation, you also see them called “fields”. To access an attribute of an object, Java uses <emphasis role="bold">dot notation</emphasis>. For example: </para><programlisting language="java" format="linespecific">int x = blank.x;</programlisting><para>The expression <literal remap="verb" moreinfo="none">blank.x</literal> means “go to the object <literal remap="verb" moreinfo="none">blank</literal> refers to, and get the value of the attribute <literal remap="verb" moreinfo="none">x</literal>.” In this case, we assign that value to a local variable named <literal remap="verb" moreinfo="none">x</literal>. </para><para>There is no conflict between the local variable <literal remap="verb" moreinfo="none">x</literal> and the attribute <literal remap="verb" moreinfo="none">x</literal>. The purpose of dot notation is to identify <emphasis>which</emphasis> variable you are referring to unambiguously. </para><para>You can use dot notation as part of an expression. For example: </para><programlisting language="java" format="linespecific">System.out.println(blank.x + ", " + blank.y);
int sum = blank.x * blank.x + blank.y * blank.y;</programlisting><para>The first line displays <literal remap="verb" moreinfo="none">3, 4</literal>. The second line calculates the value <literal remap="verb" moreinfo="none">25</literal>. </para>
</sect1><sect1 id="a0000006016" remap="section">
  <title>Objects as Parameters</title>
    <para><indexterm significance="normal">
  <primary>parameter</primary>

</indexterm><indexterm significance="normal">
  <primary>object</primary>
<secondary>as parameter</secondary>
</indexterm>You can pass objects as parameters in the usual way. For example: </para><programlisting language="java" format="linespecific">public static void printPoint(Point p) {
    System.out.println("(" + p.x + ", " + p.y + ")");
}</programlisting><para>This method takes a point as an argument and displays its attributes in parentheses. If you invoke <literal remap="verb" moreinfo="none">printPoint(blank)</literal>, it displays <literal remap="verb" moreinfo="none">(3, 4)</literal>. </para><para>As another example, we can rewrite the <literal remap="verb" moreinfo="none">distance</literal> method from <xref linkend="distance"/> so that it takes two <literal remap="verb" moreinfo="none">Point</literal>s as parameters instead of four <literal remap="verb" moreinfo="none">double</literal>s. </para><programlisting language="java" format="linespecific">public static double distance(Point p1, Point p2) {
    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
}</programlisting><para>Passing objects as parameters makes the source code more readable and less error-prone because related values are bundled together. </para><para>You actually don’t need to write a <literal remap="verb" moreinfo="none">distance</literal> method, because <literal remap="verb" moreinfo="none">Point</literal> objects have one built-in already. To compute the distance between two points, we invoke <literal remap="verb" moreinfo="none">distance</literal> on one and pass the other as an argument. </para><programlisting language="java" format="linespecific">Point p1 = new Point(0, 0);
Point p2 = new Point(3, 4);
double dist = p1.distance(p2);  // dist is 5.0</programlisting><para>It turns out you don’t need the <literal remap="verb" moreinfo="none">printPoint</literal> method either. If you invoke <literal remap="verb" moreinfo="none">System.out.println(blank)</literal> you get even more information: </para><programlisting format="linespecific">java.awt.Point[x=3,y=4]</programlisting><para><indexterm significance="normal">
  <primary>toString</primary>

</indexterm><literal remap="verb" moreinfo="none">Point</literal> objects provide a method called <literal remap="verb" moreinfo="none">toString</literal> that returns a string representation of a point. When you call <literal remap="verb" moreinfo="none">println</literal> with objects, it <emphasis>automatically</emphasis> calls <literal remap="verb" moreinfo="none">toString</literal> and displays the result. In this case, it shows the name of the type (<literal remap="verb" moreinfo="none">java.awt.Point</literal>) and the names and values of the attributes. </para>
</sect1><sect1 id="a0000006053" remap="section">
  <title>Objects as Return Values</title>
    <para><indexterm significance="normal">
  <primary>Rectangle</primary>

</indexterm><indexterm significance="normal">
  <primary>class</primary>
<secondary>Rectangle</secondary>
</indexterm>The <literal remap="verb" moreinfo="none">java.awt</literal> package also provides a class named <literal remap="verb" moreinfo="none">Rectangle</literal>. To use it, you have to import it: </para><programlisting language="java" format="linespecific">import java.awt.Rectangle;</programlisting><para><literal remap="verb" moreinfo="none">Rectangle</literal> objects are similar to points, but they have four attributes: <literal remap="verb" moreinfo="none">x</literal>, <literal remap="verb" moreinfo="none">y</literal>, <literal remap="verb" moreinfo="none">width</literal>, and <literal remap="verb" moreinfo="none">height</literal>. The following example creates a <literal remap="verb" moreinfo="none">Rectangle</literal> object and makes the variable <literal remap="verb" moreinfo="none">box</literal> refer to it: </para><programlisting language="java" format="linespecific">Rectangle box = new Rectangle(0, 0, 100, 200);</programlisting><para><xref linkend="fig.rectangle"/> shows the effect of this assignment. </para>
  
  <figure id="fig.rectangle" float="False">
    <title>Memory diagram showing a <literal remap="verb" moreinfo="none">Rectangle object.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/rectangle.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If you run <literal remap="verb" moreinfo="none">System.out.println(box)</literal>, you get: </para><programlisting format="linespecific">java.awt.Rectangle[x=0,y=0,width=100,height=200]</programlisting><para>Again, <literal remap="verb" moreinfo="none">println</literal> uses the <literal remap="verb" moreinfo="none">toString</literal> method provided by <literal remap="verb" moreinfo="none">Rectangle</literal>, which knows how to represent <literal remap="verb" moreinfo="none">Rectangle</literal> objects as strings. </para><para><indexterm significance="normal">
  <primary>return</primary>

</indexterm><indexterm significance="normal">
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>You can write methods that return new objects. For example, <literal remap="verb" moreinfo="none">findCenter</literal> takes a <literal remap="verb" moreinfo="none">Rectangle</literal> as an argument and returns a <literal remap="verb" moreinfo="none">Point</literal> with the coordinates of the center of the rectangle: </para><programlisting language="java" format="linespecific">public static Point findCenter(Rectangle box) {
    int x = box.x + box.width / 2;
    int y = box.y + box.height / 2;
    return new Point(x, y);
}</programlisting><para><indexterm significance="normal">
  <primary>coordinate</primary>

</indexterm>The return type of this method is <literal remap="verb" moreinfo="none">Point</literal>. The last line creates a new <literal remap="verb" moreinfo="none">Point</literal> object and returns a reference to it. </para>
</sect1><sect1 id="a0000006101" remap="section">
  <title>Rectangles are Mutable</title>
    <para><indexterm significance="normal">
  <primary>mutable</primary>

</indexterm><indexterm significance="normal">
  <primary>object</primary>
<secondary>mutable</secondary>
</indexterm>You can change the contents of an object by making an assignment to one of its attributes. For example, to “move” a rectangle without changing its size, you can modify the <literal remap="verb" moreinfo="none">x</literal> and <literal remap="verb" moreinfo="none">y</literal> values: </para><programlisting language="java" format="linespecific">Rectangle box = new Rectangle(0, 0, 100, 200);
box.x = box.x + 50;
box.y = box.y + 100;</programlisting><para>The result is shown in <xref linkend="fig.rectangle2"/>. </para>
  
  <figure id="fig.rectangle2" float="False">
    <title>Memory diagram showing updated attributes.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/rectangle2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>encapsulation</primary>

</indexterm><indexterm significance="normal">
  <primary>generalization</primary>

</indexterm>We can encapsulate this code in a method and generalize it to move the rectangle by any amount: </para><programlisting language="java" format="linespecific">public static void moveRect(Rectangle box, int dx, int dy) {
    box.x = box.x + dx;
    box.y = box.y + dy;
}</programlisting><para>The variables <literal remap="verb" moreinfo="none">dx</literal> and <literal remap="verb" moreinfo="none">dy</literal> indicate how far to move the rectangle in each direction. Invoking this method has the effect of modifying the <literal remap="verb" moreinfo="none">Rectangle</literal> that is passed as an argument. </para><programlisting language="java" format="linespecific">Rectangle box = new Rectangle(0, 0, 100, 200);
moveRect(box, 50, 100);  // now at (50, 100, 100, 200)</programlisting><para>Modifying objects by passing them as arguments to methods can be useful. But it can also make debugging more difficult, because it is not always clear which method invocations modify their arguments. </para><para>Java provides a number of methods that operate on <literal remap="verb" moreinfo="none">Point</literal>s and <literal remap="verb" moreinfo="none">Rectangle</literal>s. For example, <literal remap="verb" moreinfo="none">translate</literal> has the same effect as <literal remap="verb" moreinfo="none">moveRect</literal>, but instead of passing the rectangle as an argument, you use dot notation: </para><programlisting language="java" format="linespecific">box.translate(50, 100);</programlisting><para>This line invokes the <literal remap="verb" moreinfo="none">translate</literal> method for the object that <literal remap="verb" moreinfo="none">box</literal> refers to. This method modifies the <literal remap="verb" moreinfo="none">box</literal> object it is invoked on. </para><para><indexterm significance="normal">
  <primary>object-oriented</primary>

</indexterm>This style, using dot notation to invoke a method on an object, rather than passing it as a parameter, is more consistent with the style of object-oriented programming. </para>
</sect1><sect1 id="aliasing" remap="section">
  <title>Aliasing Revisited</title><para><indexterm significance="normal">
  <primary>reference</primary>

</indexterm>Remember that when you assign an object to a variable, you are assigning a <emphasis>reference</emphasis> to an object. It is possible to have multiple variables that refer to the same object. For example, this code creates two variables that refer to the same <literal remap="verb" moreinfo="none">Rectangle</literal>: </para><programlisting language="java" format="linespecific">Rectangle box1 = new Rectangle(0, 0, 100, 200);
Rectangle box2 = box1;</programlisting><para><xref linkend="fig.aliasing"/> shows the result: <literal remap="verb" moreinfo="none">box1</literal> and <literal remap="verb" moreinfo="none">box2</literal> refer to the same object, so any changes that affect one variable also affect the other. </para>
  
  <figure id="fig.aliasing" float="False">
    <title>Memory diagram showing two variables that refer to the same <literal remap="verb" moreinfo="none">Rectangle object.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/aliasing.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>For example, the following code uses <literal remap="verb" moreinfo="none">grow</literal> to make <literal remap="verb" moreinfo="none">box1</literal> bigger by 50 units in all directions. It decreases <literal remap="verb" moreinfo="none">x</literal> and <literal remap="verb" moreinfo="none">y</literal> by 50, and increases <literal remap="verb" moreinfo="none">height</literal> and <literal remap="verb" moreinfo="none">width</literal> by 100: </para><programlisting language="java" format="linespecific">box1.grow(50, 50);                // grow box1 (alias)</programlisting><para>The result is shown in <xref linkend="fig.aliasing2"/>. </para>
  
  <figure id="fig.aliasing2" float="False">
    <title>Memory diagram showing the effect of invoking <literal remap="verb" moreinfo="none">grow.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/aliasing2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Now, if we print <literal remap="verb" moreinfo="none">box1</literal>, we are not surprised to see that it has changed. </para><programlisting language="java" format="linespecific">java.awt.Rectangle[x=-50,y=-50,width=200,height=300]</programlisting><para>And if we print <literal remap="verb" moreinfo="none">box2</literal>, we should not be surprised to see that it has changed, too, because it refers to the same object: </para><programlisting language="java" format="linespecific">java.awt.Rectangle[x=-50,y=-50,width=200,height=300]</programlisting><para>This scenario is called <emphasis role="bold">aliasing</emphasis> because a single object has multiple names, or “aliases”, that refer to it. </para><para>As you can tell from this simple example, code that involves aliasing can get confusing fast, and it can be difficult to debug. </para>
</sect1><sect1 id="src.zip" remap="section">
  <title>Java Library Source</title><para><indexterm significance="normal">
  <primary>library</primary>

</indexterm><indexterm significance="normal">
  <primary>source code</primary>

</indexterm>So far you have used classes from the Java library including <literal remap="verb" moreinfo="none">System</literal>, <literal remap="verb" moreinfo="none">String</literal>, <literal remap="verb" moreinfo="none">Scanner</literal>, <literal remap="verb" moreinfo="none">Math</literal>, <literal remap="verb" moreinfo="none">Random</literal>, and others. These classes are written in Java, so you can read the source code to see how they work. </para><para><indexterm significance="normal">
  <primary>src.zip</primary>

</indexterm>The Java library contains thousands of files, many of which are thousands of lines of code. That’s more than one person could read and understand fully, but don’t be intimidated! </para><para>Because it’s so large, the library source code is stored in a ZIP archive named <literal remap="verb" moreinfo="none">src.zip</literal>. If you have Java installed on your computer, you have this file somewhere. </para><itemizedlist>
  
    <listitem><para>On Linux, it’s likely under: <literal remap="verb" moreinfo="none">/usr/lib/jvm</literal> If not, you might have to install the <literal moreinfo="none">openjdk-...-source</literal> package. </para></listitem>
  
    <listitem><para>On MacOS, it’s likely under: <literal remap="verb" moreinfo="none">/Library/Java/JavaVirtualMachines/jdk.../Contents/Home/</literal> </para></listitem>
  
    <listitem><para>On Windows, it’s likely under: <literal remap="verb" moreinfo="none">C:\Program Files\Java\jdk...\</literal> </para></listitem>
  
</itemizedlist><para>When you open (or unzip) the file, you will see folders that correspond to Java packages. For example, open the <literal moreinfo="none">java</literal> folder, and then open the <literal moreinfo="none">awt</literal> folder. (If you don’t see a <literal moreinfo="none">java</literal> folder at first, open the <literal moreinfo="none">java.desktop</literal> folder.) You should now see <literal moreinfo="none">Point.java</literal> and <literal moreinfo="none">Rectangle.java</literal>, along with the other classes in the <literal remap="verb" moreinfo="none">java.awt</literal> package. </para><para>Open <literal moreinfo="none">Point.java</literal> in your editor and skim through the file. It uses language features we haven’t discussed yet, so you probably won’t understand every line. But you can get a sense of what professional Java source code looks like by browsing through the library. </para><para><indexterm significance="normal">
  <primary>documentation</primary>

</indexterm><indexterm significance="normal">
  <primary>HTML</primary>

</indexterm><indexterm significance="normal">
  <primary>Javadoc</primary>

</indexterm>Notice how much of <literal moreinfo="none">Point.java</literal> is documentation (see <xref linkend="javadoc"/>). Each method is thoroughly commented, including <literal remap="verb" moreinfo="none">@param</literal>, <literal remap="verb" moreinfo="none">@return</literal>, and other tags. Javadoc reads these comments and generates documentation in HTML. You can see the same documentation online by doing a web search for “Java Point”. </para><para>Now take a look at the <literal remap="verb" moreinfo="none">Rectangle</literal> class’s <literal remap="verb" moreinfo="none">grow</literal> and <literal remap="verb" moreinfo="none">translate</literal> methods. There is more to them than you may have expected. </para>
</sect1><sect1 id="UML" remap="section">
  <title>Class Diagrams</title><para>To summarize what we’ve learned so far, <literal remap="verb" moreinfo="none">Point</literal> and <literal remap="verb" moreinfo="none">Rectangle</literal> objects have their own attributes and methods. Attributes are an object’s <emphasis>data</emphasis>, and methods are an object’s <emphasis>code</emphasis>. An object’s <emphasis>class</emphasis> defines the attributes and methods it has. </para><para><indexterm significance="normal">
  <primary>UML</primary>

</indexterm><emphasis role="bold">Unified Modeling Language</emphasis> (UML) defines a graphical way to summarize this information about a class. <xref linkend="fig.umlPoint"/>, shows two examples, the <emphasis role="bold">UML class diagrams</emphasis> for the <literal remap="verb" moreinfo="none">Point</literal> and <literal remap="verb" moreinfo="none">Rectangle</literal> classes. </para>
  
  <figure id="fig.umlPoint" float="False">
    <title>UML class diagrams for <literal remap="verb" moreinfo="none">Point and <literal remap="verb" moreinfo="none"></literal></literal>Rectangle.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/point-rect.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm significance="normal">
  <primary>class diagram</primary>

</indexterm><indexterm significance="normal">
  <primary>diagram</primary>
<secondary>class</secondary>
</indexterm>Each class is represented by a box with the name of the class, a list of the attributes, and a list of methods. </para><para><indexterm significance="normal">
  <primary>private</primary>

</indexterm><indexterm significance="normal">
  <primary>variable</primary>
<secondary>private</secondary>
</indexterm>To identify the types of attributes and parameters, UML uses language-independent syntax, like <literal moreinfo="none">x: int</literal> rather than Java syntax, like <literal remap="verb" moreinfo="none">int x</literal>. </para><para>The plus sign (<literal remap="verb" moreinfo="none">+</literal>) identifies <literal remap="verb" moreinfo="none">public</literal> attributes and methods. A minus sign (<literal remap="verb" moreinfo="none">-</literal>) would identify <literal remap="verb" moreinfo="none">private</literal> attributes and methods, which we discuss in the next chapter. </para><para>Both <literal remap="verb" moreinfo="none">Point</literal> and <literal remap="verb" moreinfo="none">Rectangle</literal> have additional methods; we are only showing the ones introduced in this chapter. </para><para>In contrast to memory diagrams, which visualize objects (and variables) at run-time, a class diagram visualizes the source code at compile-time. </para>
</sect1><sect1 id="a0000006300" remap="section">
  <title>Garbage Collection</title>
    <para>In the previous section, we said that attributes exist as long as the object exists. But when does an object cease to exist? Here is a simple example: </para><programlisting language="java" format="linespecific">Point blank = new Point(3, 4);
blank = null;</programlisting><para>The first line creates a new <literal remap="verb" moreinfo="none">Point</literal> object and makes <literal remap="verb" moreinfo="none">blank</literal> refer to it. The second line changes <literal remap="verb" moreinfo="none">blank</literal> so that instead of referring to the object, it refers to nothing. As shown in <xref linkend="fig.reference3"/>, there is no longer an arrow between them. </para>
  
  <figure id="fig.reference3" float="False">
    <title>Memory diagram showing the effect of setting a variable to <literal remap="verb" moreinfo="none">null.</literal/>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/reference3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If there are no references to an object, there is no way to access its attributes or invoke a method on it. From the program’s point of view, it ceases to exist. However, it’s still present in the computer’s memory, taking up space. </para><para><indexterm significance="normal">
  <primary>garbage collection</primary>

</indexterm>As your program runs, the system automatically looks for stranded objects and deletes them; then the space can be reused for new objects. This process is called <emphasis role="bold">garbage collection</emphasis>. </para><para>You don’t have to do anything to make garbage collection happen, and in general, you don’t have to be aware of it. But in high-performance applications, you may notice a slight delay every now and then when Java reclaims space from discarded objects. </para>
</sect1><sect1 id="a0000006324" remap="section">
  <title>Mutable vs Immutable</title>
    <para><indexterm significance="normal">
  <primary>mutable</primary>

</indexterm><indexterm significance="normal">
  <primary>immutable</primary>

</indexterm><literal remap="verb" moreinfo="none">Point</literal>s and <literal remap="verb" moreinfo="none">Rectangle</literal>s are <emphasis role="bold">mutable</emphasis> objects, because their attributes can be modified. You can modify their attributes directly, like <literal remap="verb" moreinfo="none">box.x = 15</literal>, or you can invoke methods that modify their attributes, like <literal remap="verb" moreinfo="none">box.translate(15, 0)</literal>. </para><para>In contrast, immutable objects like <literal remap="verb" moreinfo="none">String</literal>s and <literal remap="verb" moreinfo="none">Integer</literal>s cannot be modified. They don’t allow direct access to their attributes or provide methods that change them. </para><para><indexterm significance="normal">
  <primary>Surprise.java</primary>

</indexterm>Immutable objects have a number of advantages that help improve the performance and reliability of programs. For example, two strings that contain the same contents can be stored in memory only once. The Java compiler automatically detects this situation: </para><programlisting language="java" format="linespecific">public class Surprise {
    public static void main(String[] args) {
        String s1 = "Hi, Mom!";
        String s2 = "Hi, " + "Mom!";
        if (s1 == s2) {                // true!
            System.out.println("s1 and s2 are the same");
        }
    }
}</programlisting><para>In this example, <literal remap="verb" moreinfo="none">s1</literal> and <literal remap="verb" moreinfo="none">s2</literal> refer to the <emphasis>same</emphasis> string, even though they are created differently. Because strings are immutable, the compiler decides to use a single object for both <literal remap="verb" moreinfo="none">s1</literal> and <literal remap="verb" moreinfo="none">s2</literal>. As a result, <literal remap="verb" moreinfo="none">s1 == s2</literal>, even though it appears they might be different objects. </para><para>Since neither variable can change the string itself, both <literal remap="verb" moreinfo="none">s1</literal> and <literal remap="verb" moreinfo="none">s2</literal> will be <literal remap="verb" moreinfo="none">"Hi, Mom!"</literal> until they are reassigned. You can pass strings (and other immutable objects) to methods without worrying about their contents changing as a “side-effect” of the method. </para><para><indexterm significance="normal">
  <primary>efficiency</primary>

</indexterm>On the other hand, mutable objects have their own advantages. It’s more efficient to move a rectangle by changing its coordinates than to create a new <literal remap="verb" moreinfo="none">Rectangle</literal> each time. </para><para>And as we’ll see later, it’s easier to implement objects that allow their attributes to be changed. </para>
</sect1><sect1 id="stringbuilder" remap="section">
  <title>StringBuilder Objects</title><para><indexterm significance="normal">
  <primary>Append.java</primary>

</indexterm>Strings are particularly inefficient when you need to concatenate them multiple times. Consider the following program that inputs ten lines from <literal remap="verb" moreinfo="none">System.in</literal> and concatenates them into a single <literal remap="verb" moreinfo="none">String</literal>. </para><programlisting language="java" format="linespecific">import java.util.Scanner;
public class Append {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter 10 lines:");
        String text = "";
        for (int i = 0; i &lt; 10; i++) {
            String line = in.nextLine();        // new string
            text = text + line + '\n';    // two more strings
        }
        System.out.print("You entered:\n" + text);
    }
}</programlisting><para>Inside the <literal remap="verb" moreinfo="none">for</literal> loop, <literal remap="verb" moreinfo="none">in.nextLine()</literal> returns a new string each time it is invoked. The next line of code concatenates <literal remap="verb" moreinfo="none">text</literal> and <literal remap="verb" moreinfo="none">line</literal>, which creates another string, and then appends the newline character, which creates yet another string. </para><para>As a result, this loop creates 30 <literal remap="verb" moreinfo="none">String</literal> objects! At the end, <literal remap="verb" moreinfo="none">text</literal> refers to the most recent <literal remap="verb" moreinfo="none">String</literal>. Garbage collection deletes the rest, but that’s a lot of garbage for a seemly simple program. </para><para>The Java library provides the <literal remap="verb" moreinfo="none">StringBuilder</literal> class for just this reason. It’s part of the <literal remap="verb" moreinfo="none">java.lang</literal> package, so you don’t need to import it. Because <literal remap="verb" moreinfo="none">StringBuilder</literal> objects are mutable, they can implement concatenation more efficiently. </para><para>Here’s a version of the program that uses <literal remap="verb" moreinfo="none">StringBuilder</literal>: </para><programlisting language="java" format="linespecific">StringBuilder text = new StringBuilder();
for (int i = 0; i &lt; 10; i++) {
    String line = in.nextLine();
    text.append(line);
    text.append('\n');
}</programlisting><para>The <literal remap="verb" moreinfo="none">append</literal> method takes a <literal remap="verb" moreinfo="none">String</literal> as a parameter and appends it to the end of the <literal remap="verb" moreinfo="none">StringBuilder</literal>. Each time it is invoked, it modifies the <literal remap="verb" moreinfo="none">StringBuilder</literal>; it doesn’t create any new objects. </para><para>The <literal remap="verb" moreinfo="none">StringBuilder</literal> class also provides methods for inserting and deleting parts of strings efficiently. Programs that manipulate large amounts of text run much faster if you use <literal remap="verb" moreinfo="none">StringBuilder</literal> objects instead of <literal remap="verb" moreinfo="none">String</literal>s. </para>
</sect1><sect1 id="a0000006390" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>attribute:</term>
      <listitem><para><indexterm significance="normal">
  <primary>attribute</primary>

</indexterm>One of the named data items that make up an object. </para></listitem>
  </varlistentry><varlistentry>
    <term>dot notation:</term>
      <listitem><para><indexterm significance="normal">
  <primary>dot notation</primary>

</indexterm>Use of the dot operator (<literal remap="verb" moreinfo="none">.</literal>) to access an object’s attributes or methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>coordinate:</term>
      <listitem><para><indexterm significance="normal">
  <primary>coordinate</primary>

</indexterm>A value that specifies a location in a 2D graphical window. </para></listitem>
  </varlistentry><varlistentry>
    <term>pixel:</term>
      <listitem><para><indexterm significance="normal">
  <primary>pixel</primary>

</indexterm>The unit in which coordinates are measured. </para></listitem>
  </varlistentry><varlistentry>
    <term>object-oriented:</term>
      <listitem><para><indexterm significance="normal">
  <primary>object-oriented</primary>

</indexterm>A way of organizing code and data into objects, rather than independent methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>UML:</term>
      <listitem><para><indexterm significance="normal">
  <primary>UML</primary>

</indexterm>Unified Modeling Language, a standard way to draw diagrams for software engineering. </para></listitem>
  </varlistentry><varlistentry>
    <term>class diagram:</term>
      <listitem><para><indexterm significance="normal">
  <primary>class diagram</primary>

</indexterm>An illustration of the attributes and methods for a class. </para></listitem>
  </varlistentry><varlistentry>
    <term>shadowing:</term>
      <listitem><para><indexterm significance="normal">
  <primary>shadowing</primary>

</indexterm>Occurs when a local variable or parameter has the same name as an attribute. </para></listitem>
  </varlistentry><varlistentry>
    <term>deprecated:</term>
      <listitem><para><indexterm significance="normal">
  <primary>deprecated</primary>

</indexterm>A library method that has been replaced by another method, but left in the class for backwards compatibility. </para></listitem>
  </varlistentry><varlistentry>
    <term>garbage collection:</term>
      <listitem><para><indexterm significance="normal">
  <primary>garbage collection</primary>

</indexterm>The process of finding objects that have no references and reclaiming their storage space. </para></listitem>
  </varlistentry><varlistentry>
    <term>mutable:</term>
      <listitem><para><indexterm significance="normal">
  <primary>mutable</primary>

</indexterm>An object that can be modified at any time. Points and rectangles are mutable by design. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000006416" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal moreinfo="none">ch10</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>At this point you know enough to read <xref linkend="graphics"/>, which is about simple 2D graphics and animations. During the next few chapters, you should take a detour to read this appendix and work through the exercises. </para><para><example id="a0000006428" role="exercise">
  <title/>
  <para>The point of this exercise is to make sure you understand the mechanism for passing objects as parameters. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>For the following program, draw a stack diagram showing the local variables and parameters of <literal remap="verb" moreinfo="none">main</literal> and <literal remap="verb" moreinfo="none">riddle</literal> just before <literal remap="verb" moreinfo="none">riddle</literal> returns. Use arrows to show which objects each variable references. </para></listitem>
  
  <listitem><para>What is the output of the program? </para></listitem>
  
  <listitem><para>Is the <literal remap="verb" moreinfo="none">blank</literal> object mutable or immutable? How can you tell? </para></listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static int riddle(int x, Point p) {
    x = x + 7;
    return x + p.x + p.y;
}</programlisting><programlisting language="java" format="linespecific">public static void main(String[] args) {
    int x = 5;
    Point blank = new Point(1, 2);

    System.out.println(riddle(x, blank));
    System.out.println(x);
    System.out.println(blank.x);
    System.out.println(blank.y);
}</programlisting></example> </para><para><example id="a0000006447" role="exercise">
  <title/>
  <para>The point of this exercise is to make sure you understand the mechanism for returning new objects from methods. The following code uses <literal remap="verb" moreinfo="none">findCenter</literal> and <literal remap="verb" moreinfo="none">distance</literal> as defined in this chapter. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Draw a stack diagram showing the state of the program just before <literal remap="verb" moreinfo="none">findCenter</literal> returns. Include all variables and parameters, and show the objects those variables refer to. </para></listitem>
  
  <listitem><para>Draw a stack diagram showing the state of the program just before <literal remap="verb" moreinfo="none">distance</literal> returns. Show all variables, parameters, and objects. </para></listitem>
  
  <listitem><para>What is the output of this program? (Can you tell without running it?) </para></listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static void main(String[] args) {
    Point blank = new Point(5, 8);

    Rectangle rect = new Rectangle(0, 2, 4, 4);
    Point center = findCenter(rect);

    double dist = distance(center, blank);
    System.out.println(dist);
}</programlisting></example> </para><para><example id="a0000006464" role="exercise">
  <title/>
  <para>This exercise is about aliasing. Recall that aliases are two variables that refer to the same object. The following code uses <literal remap="verb" moreinfo="none">findCenter</literal> and <literal remap="verb" moreinfo="none">printPoint</literal> as defined in this chapter. </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Draw a diagram that shows the state of the program just before the end of <literal remap="verb" moreinfo="none">main</literal>. Include all local variables and the objects they refer to. </para></listitem>
  
  <listitem><para>What is the output of the program? </para></listitem>
  
  <listitem><para>At the end of <literal remap="verb" moreinfo="none">main</literal>, are <literal remap="verb" moreinfo="none">p1</literal> and <literal remap="verb" moreinfo="none">p2</literal> aliased? Why or why not? </para></listitem>
  
</orderedlist><programlisting language="java" format="linespecific">public static void main(String[] args) {
    Rectangle box1 = new Rectangle(2, 4, 7, 9);
    Point p1 = findCenter(box1);
    printPoint(p1);

    box1.grow(1, 1);
    Point p2 = findCenter(box1);
    printPoint(p2);
}</programlisting></example> </para>
</sect1>
</chapter>
