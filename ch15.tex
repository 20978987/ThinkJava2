\chapter{Arrays of Arrays}
\label{conway}

The last two chapters of this book use 2D graphics to illustrate more advanced object-oriented concepts.
If you haven't yet read Appendix~\ref{graphics}, you might want to read it now and get familiar with the \java{Canvas}, \java{Color}, and \java{Graphics} classes from the \java{java.awt} package.
In this chapter we use these classes to draw images and animations, and to run graphical simulations.


\section{Conway's Game of Life}

{\it The Game of Life}, or GoL for short, was developed by John Conway and popularized in 1970 in Martin Gardner's column in Scientific American.
Conway calls it a ``zero-player game'' because no players are needed to choose strategies or make decisions.
After you set up the initial conditions, you watch the game play itself.
That turns out to be more interesting than it sounds; you can read about it at \url{http://en.wikipedia.org/wiki/Conway's_Game_of_Life}.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/glider.png}
\caption{A ``Glider'' in the Game of Life.}
\label{fig:glider}
\end{center}
\end{figure}

The game board is a two-dimensional grid of square cells.
Each cell is either ``alive'' or ``dead''; the color of the cell indicates its status.
Figure~\ref{fig:glider} shows an example grid configuration.

\index{neighbor}

The game proceeds in time steps, during which each cell interacts with its neighbors in the eight adjacent cells.
At each step, the following rules are applied:

\begin{enumerate}
\small
\item A live cell with fewer than two live neighbors dies, as if by underpopulation.
\item A live cell with more than three live neighbors dies, as if by overpopulation.
\item A dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
\end{enumerate}

\index{stable configuration}

Notice some consequences of these rules.
If you start with a single live cell, it dies.
If all cells are dead, no cells come to life.
But if you have four cells in a square, they keep each other alive, so that's a ``stable'' configuration.

Another initial configuration is shown in Figure~\ref{fig:blinker}.
If you start with three horizontal cells, the center cell lives, the left and right cells die, and the top and bottom cells come to life.
The result after the first time step is three vertical cells.

During the next time step, the center cell lives, the top and bottom cells die, and the left and right cells come to life.
The result is three horizontal cells, so we're back where we started, and the cycle repeats forever.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/blinker-0.png}
\raisebox{38pt}{~$\longrightarrow$~}
\includegraphics{figs/blinker-1.png}
\raisebox{38pt}{~$\longrightarrow$~}
\includegraphics{figs/blinker-0.png}
\raisebox{38pt}{~$\longrightarrow$~ \ldots}
\caption{A ``Blinker'' in the Game of Life.}
\label{fig:blinker}
\end{center}
\end{figure}

Patterns like this are called ``periodic'', because they repeat after a period of two or more time steps.
But they are also considered stable, because the total number of live cells doesn't grow over time.

Most simple starting configurations either die out quickly or reach a stable configuration.
But there are a few starting conditions that display remarkable complexity.
One of those is the R-pentomino: it starts with only five cells, runs for 1103 time steps, and ends in a stable configuration with 116 live cells (see \url{http://www.conwaylife.com/wiki/R-pentomino}).

In the following sections, we'll implement the Game of Life in Java.
We'll first implement the cells, then the grid of cells, and finally the game itself.


\section{The Cell Class}

To represent the state of a cell, we use an integer, \java{state}, which is 0 for dead cells and 1 for live cells.
To represent the location, we use the \java{x} and \java{y} coordinates of the upper-left corner.
And to represent the size, we use an integer, \java{size}.

Here is a \java{Cell} class that declares these instance variables:

\begin{code}
public class Cell {
    private final int x;
    private final int y;
    private final int size;
    private int state;
}
\end{code}

Notice that \java{x}, \java{y}, and \java{size} are constants.
Once the cell is created, we don't want it to move or change size.
But \java{state} can and should change, so it is not a constant.

The next step is to write a constructor.
Here's one that takes \java{x}, \java{y}, and \java{size} as parameters, and sets {\tt state} to a default value.

\begin{code}
public Cell(int x, int y, int size) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.state = 0;
}
\end{code}

%The following line uses the constructor to create a \java{Cell}.
%Its upper-left corner is at (0, 0), and the cell is 10x10 pixels.
%
%\begin{code}
%Cell cell = new Cell(0, 0, 10);
%\end{code}

The following method draws a cell.
Like the \java{paint} method in Appendix~\ref{graphics}, it takes a graphics context as a parameter.

\begin{code}
public static final Color[] COLORS = {Color.WHITE, Color.BLACK};

public void draw(Graphics g) {
    g.setColor(COLORS[this.state]);
    g.fillRect(x + 1, y + 1, size - 1, size - 1);
    g.setColor(Color.LIGHT_GRAY);
    g.drawRect(x, y, size, size);
}
\end{code}

The \java{draw} method uses the state of the cell to select a color from an array of \java{Color} objects.
Then it uses to \java{fillRect} to draw the center of the cell and \java{drawRect} to draw a light gray border.

We also need methods to get and set the cell's state.
We could just provide \java{getState} and \java{setState}, but the code will be more readable if we provide methods customized for the Game of Life:

\begin{code}
public boolean isOff() {
    return state == 0;
}

public boolean isOn() {
    return state == 1;
}
\end{code}

%\java{isOff} and \java{isOn} check the state of the cell.

\begin{code}
public void turnOff() {
    state = 0;
}

public void turnOn() {
    state = 1;
}
\end{code}

%\java{turnOff} and \java{turnOn} modify the state of the cell.


\section{Two-Dimensional Arrays}

\index{multidimensional array}

To represent a grid of cells, we can use a {\bf multidimensional array}.
To create a two-dimensional (2D) array, we specify the number of rows and columns:

\begin{code}
int rows = 4;
int cols = 3;
Cell[] array = new Cell[rows][cols];
\end{code}

The result is an array with 4 rows and 3 columns (representing a 3x4 grid).
Initially, the elements of the array are \java{null}.
We can fill the array with \java{Cell} objects like this:

\begin{code}
for (int r = 0; r < rows; r++) {
    int y = r * size;
    for (int c = 0; c < cols; c++) {
        int x = c * size;
        array[r][c] = new Cell(x, y, size);
    }
}
\end{code}

The loop variables \java{r} and \java{c} are the row and column indexes of the cells.
The variables \java{x} and \java{y} are the coordinates.
For example, if \java{size} is 10 pixels, the cell at index (1, 2) would be at coordinates (10, 20) on the screen.

In Java, a 2D array is really an array of arrays.
You can think of it as an array of rows, where each row is an array.
Figure~\ref{fig:2D-array} shows what it looks like.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/2D-array.pdf}
\caption{Storing rows and columns with a 2D array.}
\label{fig:2D-array}
\end{center}
\end{figure}

\index{row-major order}

%\java{array} is an array of references that refer to arrays of \java{Cell} objects.
When we write \java{array[r][c]}, Java uses the first index to select a row and the second index to select an element from the row.
This way of representing two-dimensional data is know as {\bf row-major order}.


\section{The GridCanvas Class}

Now that we have a \java{Cell} class and a way to represent a 2D array of cells, we can write a class to represent a grid of cells.
We encapsulate the code from the previous section and generalize it to construct a grid with any number of rows and columns:

\begin{code}
public class GridCanvas extends Canvas {
    private Cell[][] array;

    public GridCanvas(int rows, int cols, int size) {
        array = new Cell[rows][cols];
        for (int r = 0; r < rows; r++) {
            int y = r * size;
            for (int c = 0; c < cols; c++) {
                int x = c * size;
                array[r][c] = new Cell(x, y, size);
            }
        }

        // set the canvas size
        setSize(cols * size, rows * size);
    }
}
\end{code}

\index{IS-A}
\index{HAS-A}
\index{Graphics}

Using vocabulary from the previous chapter, \java{GridCanvas} ``is~a'' \java{Canvas} that ``has~a'' two-dimensional array of cells.
By extending the \java{Canvas} class from \java{java.awt}, we inherit methods for drawing graphics on the screen.

In fact, the code is surprisingly straightforward: to draw the grid, we simply draw each cell.
We use nested \java{for} loops to traverse the 2D array:

\begin{code}
public void draw(Graphics g) {
    for (Cell[] row : array) {
        for (Cell cell : row) {
            cell.draw(g);
        }
    }
}
\end{code}

The outer loop traverses the rows; the inner loop traverses the cells in each row.
You can almost read this method in English: ``For each \java{row} in the \java{array}, and for each \java{cell} in the \java{row}, draw the \java{cell} in the graphics context.''
Each cell contains its coordinates and size, so it knows how to draw itself.

Classes that extend \java{Canvas} are supposed to provide a method called \java{paint} that ``paints'' the contents of the \java{Canvas}.
It gets invoked when the \java{Canvas} is created and any time it needs to be redrawn, for example, when its window is moved or resized.

Here's the \java{paint} method for \java{GridCanvas}.
When the window management system calls \java{paint}, \java{paint} calls \java{draw}, which draws the cells.

\begin{code}
public void paint(Graphics g) {
    draw(g);
}
\end{code}


\section{Other grid methods}

In addition to \java{draw} and \java{paint}, the \java{Grid} class provides methods for working with the grid itself.
\java{numRows} and \java{numCols} return the number of rows and columns.
We can get this information from the 2D array, using \java{length}:

\begin{code}
public int numRows() {
    return array.length;
}

public int numCols() {
    return array[0].length;
}
\end{code}

Because we are using row-major order, the 2D array is an array of rows.
\java{numRows} simply returns the length of the rows array.
\java{numCols} returns the length of the first row, which is the number of columns.
Since the rows all have the same length, we only have to check one.

\java{GridCanvas} also provides a method that gets the \java{Cell} at a given location, and for convenience, a method that turns on the \java{Cell} at a given location.

\begin{code}
public Cell getCell(int r, int c) {
    return array[r][c];
}

public void turnOn(int r, int c) {
    array[r][c].turnOn();
}
\end{code}


\section{Starting the Game}
\label{conwaymain}

Now we're ready to implement the game.
To encapsulate the rules of GoL, we define a class named \java{Conway}.
The \java{Conway} class ``has~a'' \java{GridCanvas} that represents the state of the game.

This constructor makes a \java{GridCanvas} with 5 rows and 10 columns, with cells that are 20 pixels wide and high.
It then sets up the initial conditions.

\begin{code}
public class Conway {
    private GridCanvas grid;

    public Conway() {
        grid = new GridCanvas(5, 10, 20);
        grid.turnOn(2, 1);
        grid.turnOn(2, 2);
        grid.turnOn(2, 3);
        grid.turnOn(1, 7);
        grid.turnOn(2, 7);
        grid.turnOn(3, 7);
    }
}
\end{code}

\index{JFrame}

Before we implement the rest of the game, we'll write a \java{main} method that creates a \java{Conway} object and displays it.
We can use this method to test \java{Cell} and \java{GridCanvas}, and to develop the other methods we need.

\begin{code}
public static void main(String[] args) {
    String title = "Conway's Game of Life";
    Conway game = new Conway();
    JFrame frame = new JFrame(title);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);
    frame.add(game.grid);
    frame.pack();
    frame.setVisible(true);
    game.mainloop();
}
\end{code}

After constructing the \java{game} object, \java{main} instantiates a \java{JFrame}, which creates a window on the screen.
It then adds the \java{GridCanvas} inside the frame, resizes (``packs'') the frame to fit the canvas, and makes the frame visible.

Figure~\ref{fig:conway} shows the result.
The \java{JFrame} is configured to exit the program when closed.
Resizing the window is disabled.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/conway.png}
\caption{Screenshot of the initial \java{Conway} application.}
\label{fig:conway}
\end{center}
\end{figure}


\section{The Simulation Loop}
\label{mainloop}

At the end of \java{main}, we call \java{mainloop}, which uses a \java{while} loop to simulate the time steps of the Game of Life.
Here's a rough draft of this method:

\begin{code}
public void mainloop() {
    while (true) {
        this.update();
        grid.repaint();
        Thread.sleep(500);    // compiler error
    }
}
\end{code}

During each time step, we update the state of the game and repaint the \java{grid}.
We will present the \java{update} method in Section~\ref{sec:update}.

\java{repaint} comes from the \java{Canvas} class.
By default, it calls the \java{paint} method we provided, which calls \java{draw}.
The reason we use it here is that \java{repaint} does not require a \java{Graphics} object as a parameter.

\index{Thread.sleep}
\index{sleep}

\java{Thread.sleep(500)} causes the program to ``sleep'' for 500 milliseconds, or a half second.
Otherwise the program would run so fast we would not be able to see the animation.

\index{InterruptedException}
\index{Exception!Interrupted}

There's just one problem: compiling this code results in the error ``unreported exception InterruptedException''.
This message means we need to do some exception handling.


\section{Exception Handling}

So far, the only exceptions we have seen are run-time errors like ``array index out of bounds'' and ``null pointer''.
When one of these exceptions occur, Java displays a message and ends the program.

If you don't want the program to end, you can handle exceptions with a \java{try}-\java{catch} statement.
The syntax is similar to an \java{if}-\java{else} statement, and the logic is, too.
Here's what it looks like:

\index{try}
\index{catch}
\index{Statement!try}
\index{Statement!catch}

\begin{code}
try {
    Thread.sleep(500);
} catch (InterruptedException e) {
    // do nothing
}
\end{code}

First, Java runs the code in the try block, which calls \java{Thread.sleep} in this example.
If an \java{InterruptedException} occurs during the try block, Java executes the catch block.
In this example, the catch block contains a comment, so it doesn't do anything.

If a different exception occurs during the try block, Java does whatever it would do otherwise, which is probably to display a message and end the program.
If no exceptions occur during the try block, the catch block doesn't run and the program continues.

In this example, the effect of the \java{try}-\java{catch} statement is to ignore an ``interrupted'' exception if it occurs.

As an alternative, we could use the catch block to display a customized message, end the program, or handle the exception in whatever way is appropriate.
For example, if user input causes an exception, we could catch the exception and prompt the user to try again later.

There's more to learn about exception handling.
You can read about exceptions in the Java tutorials at \url{https://thinkjava.org/exceptions}.


\section{Counting neighbors}

\index{neighbor}

Now that you know about \java{try} and \java{catch}, we can use them to implement a useful method in \java{GridCanvas}.
Part of the GoL logic is to count the number of live neighbors.
Most cells have eight neighbors, as shown in Figure~\ref{fig:neighbors}.

\begin{figure}[!ht]
\begin{center}
\begin{tabular}{|p{1em}|p{1em}|p{1em}|p{1em}|p{1em}|}
\hline
  &   &   &   &   \\
\hline
  & 1 & 2 & 3 &   \\
\hline
  & 4 & * & 5 &   \\
\hline
  & 6 & 7 & 8 &   \\
\hline
  &   &   &   &   \\
\hline
\end{tabular}
\caption{Neighbors for a cell in the middle of the grid.}
\label{fig:neighbors}
\end{center}
\end{figure}

However, cells on the edges and in the corners have fewer neighbors.
If we try to count all possible neighbors, we'll go out of bounds.
%(Normally in the Game of Life, we don't have this problem because the grid size is infinite.
%But we thought that version might be a bit much for this chapter!)
The following method uses a \java{try}-\java{catch} statement to deal with these special cases.

\begin{code}
public int test(int r, int c) {
    try {
        if (array[r][c].isOn()) {
            return 1;
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        // cell doesn't exist
    }
    return 0;
}
\end{code}

The \java{test} method takes a row index, \java{r}, and a column index, \java{c}.
It tries to look up the \java{Cell} at that location.
If both of the indexes are in bounds, the \java{Cell} exists.
In that case, \java{test} returns 1 if the \java{Cell} is on and 0 otherwise.

If either of the indexes is out of bounds, the array lookup throws an exception, but the catch clause catches and ignores it.
Then \java{test} resumes and returns 0.
So the non-existent cells around the perimeter are considered to be off.

Now we can use \java{test} to implement \java{countAlive}, which takes a grid location, \java{(r, c)}, and returns the number of live neighbors surrounding that location.

\begin{code}
private int countAlive(int r, int c) {
    int count = 0;
    count += grid.test(r - 1, c - 1);
    count += grid.test(r - 1, c);
    count += grid.test(r - 1, c + 1);
    count += grid.test(r, c - 1);
    count += grid.test(r, c + 1);
    count += grid.test(r + 1, c - 1);
    count += grid.test(r + 1, c);
    count += grid.test(r + 1, c + 1);
    return count;
}
\end{code}

Because \java{test} handles ``out of bounds'' exceptions, this method works for any values of \java{r} and \java{c}.


\section{Updating the grid}
\label{sec:update}

Now we are ready to write \java{update}, which gets invoked each time through the simulation loop.
It uses the GoL rules to compute the state of the grid after the next time step.

\begin{code}
public void update() {
    int[][] counts = countNeighbors();
    updateGrid(counts);
}
\end{code}

The rules of GoL specify that you have to update the cells ``simultaneously''; that is, you have to count the neighbors for all cells before you can update any of them.

We do that by traversing the grid twice: first, \java{countNeighbors} counts the live neighbors for each cell and puts the results in an array named \java{counts}; second, \java{updateGrid} updates the cells.
Here's \java{countNeighbors}:

\begin{code}
private int[][] countNeighbors() {
    int rows = grid.numRows();
    int cols = grid.numCols();

    int[][] counts = new int[rows][cols];
    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            counts[r][c] = countAlive(r, c);
        }
    }
    return counts;
}
\end{code}

\java{countNeighbors} traverses the cells in the grid and uses \java{countAlive} from the previous section to count the neighbors.
The return value is a 2D array of integers with the same size as \java{grid}.

In contrast to the \java{draw} method of \java{GridCanvas}, which uses enhanced \java{for} loops, \java{countNeighbors} uses standard \java{for} loops.
The reason is that, in this example, we need the indexes \java{r} and \java{c} to store the neighbor counts.

\java{updateGrid} uses \java{getCell} to select each \java{Cell} in the grid and \java{updateCell} to do the update.

\begin{code}
public void updateGrid(int[][] counts) {
    int rows = grid.numRows();
    int cols = grid.numCols();

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            Cell cell = grid.getCell(r, c);
            updateCell(cell, counts[r][c]);
        }
    }
}
\end{code}

\java{updateCell} implements the GoL rules: if the cell is alive, it dies if it has fewer than 2 or more than 3 neighbors; if the cell is dead, it comes to life if it has exactly 3.

\begin{code}
private static void updateCell(Cell cell, int count) {
    if (cell.isOn()) {
        if (count < 2 || count > 3) {
            cell.turnOff();
        }
    } else {
        if (count == 3) {
            cell.turnOn();
        }
    }
}
\end{code}

The \java{updateCell} method \java{private}, because it is a helper method not intended to be invoked from outside the class.
It's also \java{static}, because it does not depend on \java{grid}.

Now our implementation of the Game of Life is complete.
We think it's is pretty fun, and we hope you agree.
But more importantly, this example is meant to demonstrate the use of 2D arrays and an object-oriented design that's a little more substantial than previous chapters.

%In the exercises at the end of this chapter, you'll have a chance to run the code, test other initial conditions, and explore other games with similar rules.


\section{Vocabulary}

\begin{description}

\term{multidimensional array}
An array with more than one dimension; also known as an ``array of arrays''.

\term{row-major order}
Storing data in a two-dimensional array first by rows and then by columns.

\end{description}


\section{Exercises}

The code for this chapter is in the {\tt ch15} directory of {\tt ThinkJavaCode2}.
See page~\pageref{code} for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.


\begin{exercise}
In \java{GridCanvas}, write a method named \java{countOn} that returns the total number of cells that are ``on''.
This method can be used, for example, to track the population in Game of Life over time.
\end{exercise}


\begin{exercise}
In our version of the Game of Life, the grid has a finite size.
As a result, moving objects such as gliders either crash into the wall or go out of bounds.

An interesting variation of the Game of Life is a ``toroidal'' grid, meaning that the cells ``wrap around'' on the edges.
Modify the \java{test} method of \java{GridCanvas} so that the coordinates \java{r} and \java{c} map to the opposite side of the grid if they are too low or two high.

Run your code with a Glider (see Figure~\ref{fig:glider}) to see if it works.
You can initialize the Glider by modifying the constructor in the \java{Conway} class, or by reading it from a file (see the next exercise).
\end{exercise}


%CSM idea for another exercise: 2D arrays -- grow/shrink the grid
%ABD: Good idea, but I think we have enough for now.

%\begin{exercise}
%Another way to handle edge collisions is to expand the grid as needed.
%\end{exercise}


\begin{exercise}

% TODO: Remove the solution from the starter code.

The ``LifeWiki'' \url{http://conwaylife.com/wiki/} has a fascinating collection of patterns for the Game of Life.
These patterns are stored in a file format that is easy to read, in files with the suffix ``\verb|.cells|''.

For example, here is an 8x10 grid with a glider near the upper-left corner:

\begin{stdout}
!Name: Glider
..........
..O.......
...O......
.OOO......
..........
..........
..........
..........
\end{stdout}

Lines that begin with \java{!} are comments and should be ignored.
The rest of the file describes the grid, row by row.
A period represents a dead cell, and an uppercase O represents a live cell.
See \url{http://conwaylife.com/wiki/Plaintext} for more examples.

\begin{enumerate}

\item Create a plain text file with the contents shown above, and save the file as \verb|glider.cells| in the same directory as your code.

% ABD: Should this be a constructor?  I would make it a static method that builds and returns a Conway object, on the principle that constructors generally take parameters that line up with the instance variables, and methods that do substantial work should not be constructors.  But that might be a Pythonic principle that isn't Javai-idiomatic.

\item Define a constructor for the \java{Conway} class that takes a string representing the name (or path) of a ``.cells'' file.
Here is a starting point:

\begin{code}
public Conway(String path) {
    File file = new File(path);
    Scanner scan = new Scanner(file);
}
\end{code}

\item Modify the main method to invoke the constructor as follows:

\begin{code}
Conway game = new Conway("glider.cells");
\end{code}

\item Handle the \java{FileNotFoundException} that may be thrown when creating a \java{Scanner} for a \java{File} by invoking \java{printStackTrace} on the exception object and calling \java{System.exit()} with a status of 1, indicating an error.

\item Continue implementing the constructor by reading all non-comment lines into an \java{ArrayList} using \java{hasNextLine} and \java{nextLine} of the \java{Scanner}.

\item Determine the number of rows and columns of the grid by examining the \java{ArrayList} contents.

\item Create and initialize a \java{GridCanvas} based on the \java{ArrayList}.

\end{enumerate}

Once your constructor is working, you will be able to run many of the patterns on the LifeWiki.
You might want to add a margin of empty cells around the initial pattern, to give it room to grow.

\end{exercise}


\begin{exercise}
Some files on the LifeWiki use ``Run Length Encoding'' (RLE) instead of plain text.
The basic idea of RLE is to describe the number of dead and alive cells, rather than type out each individual cell.

For example, \verb|glider.cells| from the previous exercise could be represented this way with RLE:

\begin{stdout}
#C Name: Glider
x = 10, y = 8
$2bo$3bo$b3o!
\end{stdout}%$

The first line specifies \verb|x| (the number of columns) and \verb|y| (the number of rows).
Subsequent lines consist of the letters \verb|b| (dead), \verb|o| (alive), and \verb|$| (end of line), optionally preceded by a count.
The pattern ends with \verb|!|, after which any remaining file contents are ignored.

Lines beginning with \java{#} have special meaning and are not part of the pattern.
For example, \java{#C} is a comment line.
You can read more about RLE format on \url{http://conwaylife.com/wiki/RLE}.

\begin{enumerate}

\item Create a plain text file with the contents shown above, and save the file as \verb|glider.rle| in the same directory as your code.

%ABD: As in the previous exercise, should this be a constructor?  And either way, should it be a separate method, or modify the other method to read both formats?

\item Modify your constructor from the previous exercise to check the last three characters of the \java{path}.
If they are \java{"rle"}, then you will need to process the file as RLE.
Otherwise, assume the file is in ``.cells'' format.

\item In the end, your constructor should be able to read and initialize grids in both formats.
Test your constructor by modifying the \java{main} method to read different files.

\end{enumerate}

\end{exercise}

\begin{exercise}

Now that we've finished the Game of Life, we can use the \java{Cell} and \java{GridCanvas} classes to implement other simulations.
One of the most interesting zero-player games is {\it Langton's Ant}, which models an ``ant'' that walks around a grid of cells.
The ant follows only two simple rules:

\begin{enumerate}
\item If the ant is on a white cell, it turns to the right, makes the cell black, and moves forward.
\item If the ant is on a black cell, it turns to the left, makes the cell white, and moves forward.
\end{enumerate}

Because the rules are simple, you might expect the ant to do something simple, like make a square or repeat a simple pattern.
But starting on a grid with all white cells, the ant makes more than 10,000 steps in a seemingly random pattern before it settles into a repeating loop of 104 steps.
You can read more about it at \url{http://en.wikipedia.org/wiki/Langton's_ant}.

Reusing the classes we developed in this chapter, write an implementation of Langton's Ant.

\end{exercise}



\chapter{Abstract classes}

In the previous chapter, we developed classes to implement Conway's Game of Life.
As an exercise, you had a chance to implement Langton's Ant.

In this chapter, we present a solution to that exercise, and use it to demonstrate a new Java feature, ``abstract classes''.


\section{Langton's Ant solution}

We begin by defining a \java{Langton} class that ``has~a'' grid and information about the ant.
The constructor takes the grid dimensions as parameters.

\begin{code}
public class Langton {
    private GridCanvas grid;
    private int xpos;
    private int ypos;
    private int head; // 0=North, 1=East, 2=South, 3=West

    public Langton(int rows, int cols) {
        grid = new GridCanvas(rows, cols, 10);
        xpos = rows / 2;
        ypos = cols / 2;
        head = 0;
    }
}
\end{code}

\java{grid} is a \java{GridCanvas} object, which represents the state of the cells.
\java{xpos} and \java{ypos} are the coordinates of the ant, and \java{head} is the ``heading'' of the ant, that is, what direction it is facing.
\java{head} is an integer with four possible values, where 0 means the ant is facing ``north'', that is, toward the top of the screen, 1 means ``east'', etc.

Here's the \java{update} function that implements the rules for Langton's ant:

\begin{code}
public void update() {
    flipCell();
    moveAnt();
}
\end{code}

\java{flipCell} gets the \java{Cell} at the ant's location, figures out which way to turn, and flips the state of the cell.

\begin{code}
private void flipCell() {
    Cell cell = grid.getCell(xpos, ypos);
    if (cell.isOff()) {
        // at a white square; turn right and flip color
        head = (head + 1) % 4;
        cell.turnOn();
    } else {
        // at a black square; turn left and flip color
        head = (head + 3) % 4;
        cell.turnOff();
    }
}
\end{code}

We use the modulus operator, \verb"%", to make \java{head} wrap around: if \java{head} is 3 and we turn right, it wraps around to 0; if \java{head} is 0 and we turn left, it wraps around to 3.

\java{moveAnt} moves the ant forward one square, using \java{head} to determine which way is forward.

\begin{code}
private void moveAnt() {
    if (head == 0) {
        ypos -= 1;
    } else if (head == 1) {
        xpos += 1;
    } else if (head == 2) {
        ypos += 1;
    } else {
        xpos -= 1;
    }
}
\end{code}

If you run this code with a grid size of 61x61 or larger, you will see the ant eventually settle into a repeating pattern.


\section{Refactoring}

Here is the \java{main} method we use to create and display the \java{Langton} object:

\begin{code}
public static void main(String[] args) {
    String title = "Langton's Ant";
    Langton game = new Langton(61, 61);
    JFrame frame = new JFrame(title);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);
    frame.add(game.grid);
    frame.pack();
    frame.setVisible(true);
    mainloop(game);
}
\end{code}

Most of this method is the same as the \java{main} method we used to create and run \java{Conway}, in Section~\ref{conwaymain}.
It creates and configures a \java{JFrame} and runs \java{mainloop}.

Whenever we see repeated code like this, we should think about ways to remove it.
In the previous chapter, we used inheritance to eliminate repeated code.
We'll do something similar with \java{Conway} and \java{Langton}.

First we define a class named \java{Automaton} where we will put the code \java{Conway} and \java{Langton} have in common.

\begin{code}
public class Automaton {
    private GridCanvas grid;

    public void run(String title, int rate) {
        JFrame frame = new JFrame(title);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setResizable(false);
        frame.add(this.grid);
        frame.pack();
        frame.setVisible(true);
        mainloop(rate);
    }
}
\end{code}

\java{Automaton} declares \java{grid} as an instance variable, so every \java{Automaton} ``has~a'' \java{GridCanvas}.

\java{Automaton} provides \java{run}, which contains the code that creates and configures the \java{JFrame}.
\java{run} takes two parameters, the title for the \java{JFrame} and the frame rate, that is, the number of frames to show per second.

It uses the title when is created the \java{JFrame}, and it passes \java{rate} to \java{mainloop}:

\begin{code}
public void mainloop(int rate) {
    // main simulation loop
    while (true) {

        // update the drawing
        this.update();
        grid.repaint();

        // delay the simulation
        try {
            Thread.sleep(1000 / rate);
        } catch (InterruptedException e) {
            // do nothing
        }
    }
}
\end{code}

\java{mainloop} contains the code we saw in Section~\ref{mainloop}.
It runs a \java{while} loop forever (or until interrupted).
Each time through the loop, it runs \java{update} to update \java{grid} and then \java{repaint} to redraw the grid.

Then it calls \java{Thread.sleep} with a delay that depends on \java{rate}.
For example, if {\tt rate} is 2, we should draw two frames per second, so the delay is a half second, or 500 milliseconds.

This implementation works, and if we are not planning to implement any other zero-person games, we could leave well enough alone.
Bu there are a few problems with the current design:

\begin{enumerate}

\item The \java{grid} attribute is \java{private}, making it inaccessible in \java{Conway} and \java{Langton}.
We could make it public, but then other (unrelated) classes would have access to it as well.

\item The \java{Automaton} class has no constructors, and even if it did, there would be no reason to create an instance of this class.

\item The \java{Automaton} class does not provide an implementation of \java{update}.
In order to work properly, child classes would have to provide one.

\end{enumerate}

\index{protected}
\index{abstract}

Java provides language features to solve these problems:

\begin{enumerate}

\item We can make the \java{grid} attribute \java{protected}, which means it's accessible to subclasses but not other classes.

\item We can make the class \java{abstract}, which means it cannot be instantiated.
If you attempt to create an object for an abstract class, you will get a compiler error.

\item We can declare \java{update} as an \java{abstract} method, meaning that it must be overriden in subclasses.
If the subclass does not override an abstract method, you will get a compiler error.
\end{enumerate}

Here's what \java{Automaton} looks like as an abstract class:

\begin{code}
public abstract class Automaton {
    protected GridCanvas grid;

    public abstract void update();

    public void run(String title, int delay) {
        // body of this method omitted
    }

    public void mainloop(int rate) {
        // body of this method omitted
    }
}
\end{code}

First, notice the word \java{abstract} in the first line, which declares that \java{Automaton} is an abstract class.

Second, notice the word \java{abstract} in the first (and only) line of \java{update} which declares that it is an abstract method.
In order to be an abstract class, \java{Automaton} has to have at least one abstract method.

Third, notice that \java{update} has no body.
The declaration specifies the name, arguments and return type, but it does not provide an implementation.

Any class that extends \java{Automaton} has to provide an implementation of \java{update}; the declaration here allows the compiler to check.

Here's what \java{Conway} looks like as a subclass of \java{Automaton}:

\begin{code}
public class Conway extends Automaton {

    public Conway() {
        grid = new GridCanvas(30, 25, SIZE);
    }

    public void update() {
        int[][] counts = countNeighbors();
        updateGrid(counts);
    }

    public static void main(String[] args) {
        String title = "Conway's Game of Life";
        Conway game = new Conway("pulsar.cells", 2);
        game.run(title, 2);
    }
}
\end{code}

\java{Conway} extends \java{Automaton}, so it inherits the instance variable \java{grid} and the methods \java{run} and \java{mainloop}.
But because \java{Automaton} is abstract, \java{Conway} has to provide \java{update} and a constructor.

Abstract classes are essentially incomplete class definitions that provide methods to be used by subclasses and specify methods to be implemented by subclasses.


\section{Vocabulary}

% TODO: Anything else?

\begin{description}

\term{refactor}
The process of restructuring or reorganizing existing code without changing its behavior.

\end{description}


\section{Exercises}

\begin{exercise}

The last section of this chapter introduces \java{Automaton} as an \java{abstract} class and rewrites \java{Conway} as a subclass of \java{Automaton}.
Now it's your turn.
Rewrite \java{Langton} as a subclass of \java{Automaton}, removing the code that's no longer needed.

\end{exercise}


\begin{exercise}

Mathematically speaking, Game of Life and Langton's Ant are ``cellular automatons'', where
``cellular'' means it has cells, and the ``automaton'' means it runs itself.
See \url{https://en.wikipedia.org/wiki/Cellular_automaton} for more discussion.

Implement another cellular automaton of your choice.
You may have to modify \java{Cell} and/or \java{GridCanvas}, in addition to extending \java{Automaton}.
For example, Brian's Brain (\url{https://en.wikipedia.org/wiki/Brian's_Brain}) requires three states: ``on'', ``dying'', and ``off''.

\end{exercise}
