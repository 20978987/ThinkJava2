<chapter id="a0000012001">
  <title>Advanced Topics</title>
  <para><indexterm significance="normal">
  <primary>inheritance</primary>

</indexterm><indexterm significance="normal">
  <primary>generalization</primary>

</indexterm>When we first looked at inheritance in <xref linkend="eights"/>, our purpose was to avoid duplicating code. We noticed that “decks of cards” and “hands of cards” had common functionality, and we designed a <literal moreinfo="none">CardCollection</literal> class to provide it. This technique is an example of <emphasis role="bold">generalization</emphasis>. By generalizing the code, we were able to reuse it in the <literal moreinfo="none">Deck</literal> and <literal moreinfo="none">Hand</literal> classes. </para><para><indexterm significance="normal">
  <primary>specialization</primary>

</indexterm>In <xref linkend="conway"/>, we looked at inheritance from a different point of view. When designing <literal moreinfo="none">GridCanvas</literal> to represent a grid of cells, we extended <literal moreinfo="none">Canvas</literal> and overrode its <literal moreinfo="none">paint</literal> method. This design is an example of <emphasis role="bold">specialization</emphasis>. Using the code provided by <literal moreinfo="none">Canvas</literal>, we created a specialized subclass with minimal additional code. </para><para>We didn’t write the code for <literal moreinfo="none">Canvas</literal>; it’s part of the Java Library. But we were able to customize it for our own purposes. In fact, the <literal moreinfo="none">Canvas</literal> class was explicitly designed to be extended. </para><para>In this chapter, we’ll explore the concept of inheritance more fully and explore event-driven programming. We’ll continue to develop graphical simulations as a running example, but this time in varying shapes and colors! </para><sect1 id="a0000012034" remap="section">
  <title>Polygon Objects</title>
    <para>The word polygon means “many angles”; the most basic polygons are triangles (3 angles), rectangles (4 angles), pentagons (5 angles), and so forth. Polygons are an important part of computer graphics because they are used to compose more complex images. </para><para>Java provides a <literal moreinfo="none">Polygon</literal> class (in <literal moreinfo="none">java.awt</literal>) that we can use to represent and draw polygons. The following code creates an empty <literal moreinfo="none">Polygon</literal> and adds three points, forming a triangle. </para><programlisting language="java" format="linespecific">Polygon p = new Polygon();
p.addPoint(57, 110);
p.addPoint(100, 35);
p.addPoint(143, 110);</programlisting><para>Internally, <literal moreinfo="none">Polygon</literal> objects have three attributes: </para><itemizedlist>
  
    <listitem><para><literal moreinfo="none">public int npoints;</literal> <literal moreinfo="none">   </literal> <literal moreinfo="none">// total number of points</literal> </para></listitem>
  
    <listitem><para><literal moreinfo="none">public int[] xpoints;</literal> <literal moreinfo="none"> </literal> <literal moreinfo="none">// array of X coordinates</literal> </para></listitem>
  
    <listitem><para><literal moreinfo="none">public int[] ypoints;</literal> <literal moreinfo="none"> </literal> <literal moreinfo="none">// array of Y coordinates</literal> </para></listitem>
  
</itemizedlist><para>When a <literal moreinfo="none">Polygon</literal> is created, <literal moreinfo="none">npoints</literal> is 0 and the two arrays are initialized with length 4. As points are added, <literal moreinfo="none">npoints</literal> is incremented. If <literal moreinfo="none">npoints</literal> exceeds the length of the arrays, larger arrays are created, and the previous values are copied over (similar to how <literal moreinfo="none">ArrayList</literal> works). </para><para>The <literal moreinfo="none">Polygon</literal> class provides many useful methods, like <literal moreinfo="none">contains</literal>, <literal moreinfo="none">intersects</literal>, and <literal moreinfo="none">translate</literal>. We’ll get to those later, but first we’re going to do some specialization. </para>
</sect1><sect1 id="a0000012099" remap="section">
  <title>Adding Color</title>
    <para>Specialization is useful for adding new features to an existing class, especially when you can’t (or don’t want to) change its design. For example, we can extend the <literal moreinfo="none">Polygon</literal> class by adding a <literal moreinfo="none">draw</literal> method and a <literal moreinfo="none">Color</literal> attribute: </para><programlisting language="java" format="linespecific">public class DrawablePolygon extends Polygon {
    public Color color;

    public DrawablePolygon() {
        super();
        color = Color.GRAY;
    }

    public void draw(Graphics g) {
        g.setColor(color);
        g.fillPolygon(this);
    }
}</programlisting><para>As a reminder, constructors are not inherited when you extend a class. If you don’t define a constructor, the compiler will generate one that does nothing. </para><para>The constructor for <literal moreinfo="none">DrawablePolygon</literal> uses <literal moreinfo="none">super</literal> to invoke the constructor for <literal moreinfo="none">Polygon</literal>, which initializes the attributes <literal moreinfo="none">npoints</literal>, <literal moreinfo="none">xpoints</literal>, and <literal moreinfo="none">ypoints</literal>. Then <literal moreinfo="none">DrawablePolygon</literal> initializes the <literal moreinfo="none">color</literal> attribute to <literal moreinfo="none">GRAY</literal>. </para><para><literal moreinfo="none">DrawablePolygon</literal> has the same attributes and methods that <literal moreinfo="none">Polygon</literal> has, so you can use <literal moreinfo="none">addPoint</literal> as before, or you can directly access <literal moreinfo="none">npoints</literal>, <literal moreinfo="none">xpoints</literal>, and <literal moreinfo="none">ypoints</literal> (since they are <literal moreinfo="none">public</literal>). You can also use methods like <literal moreinfo="none">contains</literal>, <literal moreinfo="none">intersects</literal>, and <literal moreinfo="none">translate</literal>. </para><para>The following code creates a <literal moreinfo="none">DrawablePolygon</literal> with the same points as in the previous section and sets its color to <literal moreinfo="none">GREEN</literal>: </para><programlisting language="java" format="linespecific">DrawablePolygon p = new DrawablePolygon();
p.addPoint(57, 110);
p.addPoint(100, 35);
p.addPoint(143, 110);
p.color = Color.GREEN;</programlisting></sect1><sect1 id="a0000012157" remap="section">
  <title>Regular Polygons</title>
    <para>A “regular” polygon has all sides the same length and all angles equal in measure. Regular polygons are a special case of polygons, so we will use specialization to define a class for them. </para><para>We could extend the <literal moreinfo="none">Polygon</literal> class, like we did in the previous section. But then we would not have the <literal moreinfo="none">Color</literal> functionality we just added. So we will make <literal moreinfo="none">RegularPolygon</literal> extend <literal moreinfo="none">DrawablePolygon</literal>. </para><para>To construct a <literal moreinfo="none">RegularPolygon</literal>, we specify the number of sides, the radius (distance from the center to a vertex), and the color. For example: </para><programlisting language="java" format="linespecific">RegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);</programlisting><figure id="fig..hexagon" float="False">
    <title>Determining the <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> coordinates of vertex V1, given the radius <emphasis role="math">r</emphasis> and angle <emphasis role="math">θ</emphasis>. The center of the polygon is at the origin <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/hexagon.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The constructor uses trigonometry to find the coordinates of each vertex. <xref linkend="fig..hexagon"/> illustrates the process. The number of sides (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inlineequation>) and the radius (<inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inlineequation>) are given as parameters. </para><itemizedlist>
  
    <listitem><para>Imagine a clock hand starting at V0 and rotating counterclockwise to V1, V2, and so forth. In <xref linkend="fig..hexagon"/>, the hand is currently at V1. </para></listitem>
  
    <listitem><para>The angle <emphasis role="math">θ</emphasis> is <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation>, since there are <emphasis role="math">2π</emphasis> radians in a circle. In other words, we are dividing the rotation of the clock hand into <emphasis role="math">n</emphasis> equal angles. </para></listitem>
  
    <listitem><para>By definition, <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">cos</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>/</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:math></inlineequation>. Therefore, <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mo form="prefix">cos</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. </para></listitem>
  
    <listitem><para>We can determine the other <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> coordinates by multiplying <emphasis role="math">θ</emphasis> by <emphasis role="math">i</emphasis>, where <emphasis role="math">i</emphasis> is the vertex number. </para></listitem>
  
</itemizedlist><para>Here is the constructor for <literal moreinfo="none">RegularPolygon</literal>: </para><programlisting language="java" format="linespecific">public RegularPolygon(int nsides, int radius, Color color) {

    // initialize DrawablePolygon attributes
    this.npoints = nsides;
    this.xpoints = new int[nsides];
    this.ypoints = new int[nsides];
    this.color = color;

    // the amount to rotate for each vertex (in radians)
    double theta = 2.0 * Math.PI / nsides;

    // compute x and y coordinates, centered at the origin
    for (int i = 0; i &lt; nsides; i++) {
        double x = radius * Math.cos(i * theta);
        double y = radius * Math.sin(i * theta);
        xpoints[i] = (int) Math.round(x);
        ypoints[i] = (int) Math.round(y);
    }
}</programlisting><para>This constructor initializes all four <literal moreinfo="none">DrawablePolygon</literal> attributes, so it doesn’t have to invoke <literal moreinfo="none">super()</literal>. </para><para>It initializes <literal moreinfo="none">xpoints</literal> and <literal moreinfo="none">ypoints</literal> by creating arrays of integer coordinates. Inside the <literal moreinfo="none">for</literal> loop, it uses <literal moreinfo="none">Math.sin</literal> and <literal moreinfo="none">Math.cos</literal> (see <xref linkend="mathmeth"/>) to compute the coordinates of the vertices as floating-point numbers. Then it rounds them off to integers, and stores them in the arrays. </para><para>When we construct a <literal moreinfo="none">RegularPolygon</literal>, the vertices are centered at the point <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. If we want the center of the polygon to be somewhere else, we can use <literal moreinfo="none">translate</literal>, which we inherit from <literal moreinfo="none">Polygon</literal>: </para><programlisting language="java" format="linespecific">RegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);
rp.translate(100, 100);</programlisting><para>The result is a 6-sided polygon with radius 50 centered at the point <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>100</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. </para>
</sect1><sect1 id="a0000012263" remap="section">
  <title>More Constructors</title>
    <para>Classes in the Java library often have more than one constructor for convenience. We can do the same with <literal moreinfo="none">RegularPolygon</literal>. For example, we can make the <literal moreinfo="none">color</literal> parameter optional by defining a second constructor: </para><programlisting language="java" format="linespecific">public RegularPolygon(int nsides, int radius) {
    this(nsides, radius, Color.GRAY);
}</programlisting><para>The keyword <literal moreinfo="none">this</literal>, when used in a constructor, invokes another constructor in the same class. It has a similar syntax as the keyword <literal moreinfo="none">super</literal>, which invokes a constructor in the superclass. </para><para>Similarly, we could make the <literal moreinfo="none">radius</literal> parameter optional too: </para><programlisting language="java" format="linespecific">public RegularPolygon(int nsides) {
    this(nsides, 50);
}</programlisting><para>Now, suppose we invoke the <literal moreinfo="none">RegularPolygon</literal> constructor like this: </para><programlisting language="java" format="linespecific">RegularPolygon rp = new RegularPolygon(6);</programlisting><para>Because we provide only one integer argument, Java calls the third constructor, which calls the second one, which calls the first one. The result is a <literal moreinfo="none">RegularPolygon</literal> with the specified value of <literal moreinfo="none">nsides</literal>, 6, the default value of <literal moreinfo="none">radius</literal>, 50, and the default color, <literal moreinfo="none">GRAY</literal>. </para><para>When writing constructors, it’s a good idea to validate the values you get as arguments. Doing so prevents run-time errors later in the program, which makes the code easier to debug. </para><para>For <literal moreinfo="none">RegularPolygon</literal>, the number of sides should be at least three, the radius should be greater than zero, and the color should not be <literal moreinfo="none">null</literal>. We can add the following lines to the first constructor: </para><programlisting language="java" format="linespecific">public RegularPolygon(int nsides, int radius, Color color) {

    // validate the arguments
    if (nsides &lt; 3) {
        throw new IllegalArgumentException("invalid nsides");
    }
    if (radius &lt;= 0) {
        throw new IllegalArgumentException("invalid radius");
    }
    if (color == null) {
        throw new NullPointerException("invalid color");
    }

    // the rest of the method is omitted</programlisting><para><indexterm significance="normal">
  <primary>throw</primary>

</indexterm><indexterm significance="normal">
  <primary>Statement</primary>
<secondary>throw</secondary>
</indexterm>In this example, we <literal moreinfo="none">throw</literal> an exception to indicate that one of the arguments is invalid. By default, these exceptions terminate the program and display an error message along with the stack trace. </para><para>Because we added this code to the most general constructor, we don’t have to add it to the others. </para>
</sect1><sect1 id="sec..drawing" remap="section">
  <title>An Initial Drawing</title><para>Now that we have <literal moreinfo="none">DrawablePolygon</literal> and <literal moreinfo="none">RegularPolygon</literal>, let’s take them for a test drive. We’ll need a <literal moreinfo="none">Canvas</literal> for drawing them, so we define a new class, <literal moreinfo="none">Drawing</literal>, that extends <literal moreinfo="none">Canvas</literal>: </para><programlisting language="java" format="linespecific">public class Drawing extends Canvas {
    private ArrayList&lt;DrawablePolygon&gt; list;

    public Drawing(int width, int height) {
        setSize(width, height);
        setBackground(Color.WHITE);
        list = new ArrayList&lt;DrawablePolygon&gt;();
    }</programlisting><programlisting language="java" format="linespecific">    public void add(DrawablePolygon cp) {
        list.add(cp);
    }

    public void paint(Graphics g) {
        for (DrawablePolygon dp : list) {
            dp.draw(g);
        }
    }
}</programlisting><para>The <literal moreinfo="none">Drawing</literal> class has an <literal moreinfo="none">ArrayList</literal> of <literal moreinfo="none">DrawablePolygon</literal> objects. When we create a <literal moreinfo="none">Drawing</literal> object, the list is initially empty. The <literal moreinfo="none">add</literal> method takes a <literal moreinfo="none">DrawablePolygon</literal> and adds it to the list. </para><para><literal moreinfo="none">Drawing</literal> overrides the <literal moreinfo="none">paint</literal> method that it inherits from <literal moreinfo="none">Canvas</literal>. <literal moreinfo="none">paint</literal> loops through the list of <literal moreinfo="none">DrawablePolygon</literal> objects and invokes <literal moreinfo="none">draw</literal> on each one. </para><para>Here is an example that creates three <literal moreinfo="none">RegularPolygon</literal> objects and draws them. <xref linkend="fig..drawing"/> shows the result. </para><programlisting language="java" format="linespecific">public static void main(String[] args) {

    // create some regular polygons
    DrawablePolygon p1 = new RegularPolygon(3, 50, Color.GREEN);
    DrawablePolygon p2 = new RegularPolygon(6, 50, Color.ORANGE);
    DrawablePolygon p3 = new RegularPolygon(360, 50, Color.BLUE);

    // move them out of the corner
    p1.translate(100, 80);
    p2.translate(250, 120);
    p3.translate(400, 160);

    // create drawing, add polygons
    Drawing drawing = new Drawing(500, 250);
    drawing.add(p1);
    drawing.add(p2);
    drawing.add(p3);</programlisting><programlisting language="java" format="linespecific">    // set up the window frame
    JFrame frame = new JFrame("Drawing");
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.add(drawing);
    frame.pack();
    frame.setVisible(true);
}</programlisting><figure id="fig..drawing" float="False">
    <title>Initial drawing of three <literal moreinfo="none">RegularPolygon</literal> objects.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/drawing.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The first block of code creates <literal moreinfo="none">RegularPolygon</literal> objects with 3, 6, and 360 sides. As you can see, a polygon with 360 sides is a pretty good approximation of a circle. </para><para>The second block of code translates the polygons to different locations. The third block of code creates the <literal moreinfo="none">Drawing</literal> and adds the polygons to it. And the fourth block of code creates a <literal moreinfo="none">JFrame</literal>, adds the <literal moreinfo="none">Drawing</literal> to it, and displays the result. </para><para>Most of these pieces should be familiar, but there is one part of this program that might surprise you. When we create the <literal moreinfo="none">RegularPolygon</literal> objects, we assign them to <literal moreinfo="none">DrawablePolygon</literal> variables. It might not be obvious why that’s legal. </para><para><indexterm significance="normal">
  <primary>IS-A</primary>

</indexterm><literal moreinfo="none">RegularPolygon</literal> extends <literal moreinfo="none">DrawablePolygon</literal>, so every <literal moreinfo="none">RegularPolygon</literal> object is also a <literal moreinfo="none">DrawablePolygon</literal>. The parameter of <literal moreinfo="none">Drawing.add</literal> has to be a <literal moreinfo="none">DrawablePolygon</literal>, but it can be any type of <literal moreinfo="none">DrawablePolygon</literal>, including <literal moreinfo="none">RegularPolygon</literal> and other subclasses. </para><para><indexterm significance="normal">
  <primary>polymorphism</primary>

</indexterm>This design is an example of <emphasis role="bold">polymorphism</emphasis>, a fancy word that means “having many forms”. <literal moreinfo="none">Drawing.add</literal> is polymorphic method, because the parameter can be one of many types. And the <literal moreinfo="none">ArrayList</literal> in <literal moreinfo="none">Drawing</literal> is a polymorphic data structure, because the elements can be different types. </para>
</sect1><sect1 id="a0000012411" remap="section">
  <title>Blinking Polygons</title>
    <para>At this point, we have a simple program that draws polygons; we can make it more fun by adding animation. <xref linkend="conway"/> introduced the idea of simulating time steps. Here’s a loop that runs the animation. </para><programlisting language="java" format="linespecific">while (true) {
    drawing.step();
    try {
        Thread.sleep(1000 / 30);
    } catch (InterruptedException e) {
        // do nothing
    }
}</programlisting><para>Each time through the loop, we call <literal moreinfo="none">step</literal> to update the <literal moreinfo="none">Drawing</literal>. Then we sleep with a delay calculated to update about 30 times per second. </para><para>Here’s what the <literal moreinfo="none">step</literal> method of <literal moreinfo="none">Drawing</literal> looks like: </para><programlisting language="java" format="linespecific">public void step() {
    for (DrawablePolygon dp : list) {
        dp.step();
    }
    repaint();
}</programlisting><para>It invokes <literal moreinfo="none">step</literal> on each <literal moreinfo="none">DrawablePolygon</literal> in the list and then repaints (clears and redraws) the canvas. </para><para>In order for this code to compile, we need <literal moreinfo="none">DrawablePolygon</literal> to provide a <literal moreinfo="none">step</literal> method. Here’s a version that doesn’t do anything; we’ll override it in subclasses. </para><programlisting language="java" format="linespecific">public void step() {
    // do nothing
}</programlisting><para>Now let’s design a new type of polygon that blinks. We’ll define a class named <literal moreinfo="none">BlinkingPolygon</literal> that extends <literal moreinfo="none">RegularPolygon</literal> and adds two more attributes: <literal moreinfo="none">visible</literal>, which indicates whether the polygon is visible, and <literal moreinfo="none">count</literal>, which counts the number of time steps since the last blink. </para><programlisting language="java" format="linespecific">public class BlinkingPolygon extends RegularPolygon {
    public boolean visible;
    public int count;

    public BlinkingPolygon(int nsides, int radius, Color c) {
        super(nsides, radius, c);
        visible = true;
        count = 0;
    }

    public void draw(Graphics g) {
        if (visible) {
            super.draw(g);
        }
    }

    public void step() {
        count++;
        if (count == 10) {
            visible = !visible;
            count = 0;
        }
    }
}</programlisting><para>The constructor uses <literal moreinfo="none">super</literal> to call the <literal moreinfo="none">RegularPolygon</literal> constructor. Then it initializes <literal moreinfo="none">visible</literal> and <literal moreinfo="none">count</literal>. Initially the <literal moreinfo="none">BlinkingPolygon</literal> is visible. </para><para>The <literal moreinfo="none">draw</literal> method draws the polygon only if it is visible. It uses <literal moreinfo="none">super</literal> to call <literal moreinfo="none">draw</literal> in the parent class. But the parent class is <literal moreinfo="none">RegularPolygon</literal>, which does not provide a <literal moreinfo="none">draw</literal> method. In this case, <literal moreinfo="none">super</literal> invokes <literal moreinfo="none">draw</literal> from the <literal moreinfo="none">DrawablePolygon</literal> class. </para><para>The <literal moreinfo="none">step</literal> method increments <literal moreinfo="none">count</literal>. Every 10 time steps, it toggles <literal moreinfo="none">visible</literal> and resets <literal moreinfo="none">count</literal> to 0. </para>
</sect1><sect1 id="a0000012489" remap="section">
  <title>Interfaces</title>
    <para>You might be getting tired of polygons at this point. Can’t we draw anything else? Of course we can, but <literal moreinfo="none">Drawing</literal> is currently based on <literal moreinfo="none">DrawablePolygon</literal>. To draw other types of objects, we have to generalize the code. </para><para>The <literal moreinfo="none">Drawing</literal> class does essentially three things: (1) it maintains a <literal moreinfo="none">list</literal> of objects, (2) it invokes the <literal moreinfo="none">draw</literal> method on each object, and (3) it invokes the <literal moreinfo="none">step</literal> method on each object. </para><para>So here’s one way we could make the code more general: </para><orderedlist inheritnum="ignore" continuation="restarts">
  
  <listitem><para>Define a new superclass, which we call <literal moreinfo="none">Actor</literal>, that provides the two methods needed by <literal moreinfo="none">Drawing</literal>: </para><programlisting language="java" format="linespecific">public class Actor {
    public void draw(Graphics g) {
        // do nothing
    }
    public void step() {
        // do nothing
    }
}</programlisting></listitem>
  
  <listitem><para>In the <literal moreinfo="none">Drawing</literal> class, replace <literal moreinfo="none">DrawablePolygon</literal> with <literal moreinfo="none">Actor</literal>. </para></listitem>
  
  <listitem><para>Any class that we want to draw must now extend <literal moreinfo="none">Actor</literal>. </para></listitem>
  
</orderedlist><para>There’s just one problem: <literal moreinfo="none">DrawablePolygon</literal> already extends <literal moreinfo="none">Polygon</literal>, and classes can only extend one superclass. Also, the <literal moreinfo="none">Actor</literal> class seems pointless, since the methods it defines don’t do anything. </para><para><indexterm significance="normal">
  <primary>inheritance</primary>

</indexterm>Java provides another mechanism for inheritance that solves these problems. We can define <literal moreinfo="none">Actor</literal> as an <literal moreinfo="none">interface</literal> instead of a <literal moreinfo="none">class</literal>, like this: </para><programlisting language="java" format="linespecific">public interface Actor {
    void draw(Graphics g);
    void step();
}</programlisting><para><indexterm significance="normal">
  <primary>interface</primary>

</indexterm>Like a class definition, an <emphasis role="bold">interface</emphasis> definition contains methods. But it contains only the declarations of the methods, not their implementations. </para><para>Like an abstract class, an interface specifies methods that must be provided by subclasses. The difference is that an abstract class can implement some methods; an interface cannot. </para><para>All interface methods are <literal moreinfo="none">public</literal> by default, since they are intended to be used by other classes. So there is no need to declare them as <literal moreinfo="none">public</literal>. </para><para>To inherit from an interface, you use the keyword <literal moreinfo="none">implements</literal> instead of <literal moreinfo="none">extends</literal>. Here’s a version of <literal moreinfo="none">DrawablePolygon</literal> that extends <literal moreinfo="none">Polygon</literal> and implements <literal moreinfo="none">Actor</literal>. So it inherits methods from <literal moreinfo="none">Polygon</literal>, and it is required to provide the methods in <literal moreinfo="none">Actor</literal>, namely <literal moreinfo="none">step</literal> and <literal moreinfo="none">draw</literal>. </para><programlisting language="java" format="linespecific">public class DrawablePolygon extends Polygon implements Actor {
    // rest of the class omitted
}</programlisting><para>In terms of inheritance, <literal moreinfo="none">DrawablePolygon</literal> is both a <literal moreinfo="none">Polygon</literal> and an <literal moreinfo="none">Actor</literal>. So the following assignments are legal: </para><programlisting language="java" format="linespecific">Polygon p1 = new DrawablePolygon();
Actor a2 = new DrawablePolygon();</programlisting><para>And the same is true for subclasses of <literal moreinfo="none">DrawablePolygon</literal>; these assignments are legal, too: </para><programlisting language="java" format="linespecific">Polygon p2 = new RegularPolygon(5, 50, Color.YELLOW);
Actor a2 = new RegularPolygon(5, 50, Color.YELLOW);</programlisting><para><indexterm significance="normal">
  <primary>polymorphism</primary>

</indexterm>Interfaces are another example of polymorphism. <literal moreinfo="none">a1</literal> and <literal moreinfo="none">a2</literal> are the same type of variable, but they refer to objects with different types. And similarly with <literal moreinfo="none">p1</literal> and <literal moreinfo="none">p2</literal>. </para><para>Classes may extend only one superclass, but they may implement as many interfaces as needed. Java Library classes often implement multiple interfaces. </para>
</sect1><sect1 id="a0000012600" remap="section">
  <title>Event Listeners</title>
    <para><indexterm significance="normal">
  <primary>sprite</primary>

</indexterm>Now that our <literal moreinfo="none">Drawing</literal> is based on <literal moreinfo="none">Actor</literal> instead of <literal moreinfo="none">DrawablePolygon</literal>, we can draw other types of graphics. Here is the beginning of a class that reads an image from a file and shows the image moving across the canvas. The class is called <literal moreinfo="none">Sprite</literal> because a moving image is sometimes called a <emphasis role="bold">sprite</emphasis>, in the context of computer graphics. </para><programlisting language="java" format="linespecific">public class Sprite implements Actor, KeyListener {
    private int xpos;
    private int ypos;
    private int dx;
    private int dy;
    private Image image;

    public Sprite(String path, int xpos, int ypos) {
        this.xpos = xpos;
        this.ypos = ypos;
        try {
            this.image = ImageIO.read(new File(path));
        } catch (IOException exc) {
            exc.printStackTrace();
        }
    }
}</programlisting><para>The instance variables <literal moreinfo="none">xpos</literal> and <literal moreinfo="none">ypos</literal> represent the location of the sprite. <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal> represent the velocity of the sprite in the <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> directions. </para><para>The constructor takes as parameters the name of a file and the initial position. It uses <literal moreinfo="none">ImageIO</literal>, from the <literal moreinfo="none">javax.imageio</literal> package, to read the file. If an error occurs during reading, an <literal moreinfo="none">IOException</literal> is caught, and the program displays the stack trace for debugging. </para><para><literal moreinfo="none">Sprite</literal> implements two interfaces: <literal moreinfo="none">Actor</literal> and <literal moreinfo="none">KeyListener</literal>. <literal moreinfo="none">Actor</literal> requires that we provide <literal moreinfo="none">draw</literal> and <literal moreinfo="none">step</literal> methods: </para><programlisting language="java" format="linespecific">    public void draw(Graphics g) {
        g.drawImage(image, xpos, ypos, null);
    }

    public void step() {
        xpos += dx;
        ypos += dy;
    }</programlisting><para>The <literal moreinfo="none">draw</literal> method draws the image at the sprite’s current position. The <literal moreinfo="none">step</literal> method changes the position based on <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal>, which are initially zero. </para><para><literal moreinfo="none">KeyListener</literal> is an interface for receiving keyboard events, which means we can detect and respond to key presses. A class that implements <literal moreinfo="none">KeyListener</literal> has to provide the following methods: </para><itemizedlist>
  
    <listitem><para><literal moreinfo="none">void keyPressed(KeyEvent e);</literal> Invoked when a key has been “pressed”. This method is invoked repeatedly while a key is being held down. </para></listitem>
  
    <listitem><para><literal moreinfo="none">void keyReleased(KeyEvent e);</literal> Invoked when a key has been “released”, meaning it is no longer down. </para></listitem>
  
    <listitem><para><literal moreinfo="none">void keyTyped(KeyEvent e);</literal> Invoked when a key has been “typed”, which generally means it has been both pressed and released. </para></listitem>
  
</itemizedlist><para>These methods get invoked when the user presses and releases <emphasis>any</emphasis> key. They take a <literal moreinfo="none">KeyEvent</literal> object as a parameter, which specifies which key was pressed, released, or typed. </para><para>We can use these methods to design a simple animation using the arrow keys. When the user presses up or down, the sprite will move up or down. When the user presses left or right, the sprite will move left or right. </para><para>Here’s an implementation of <literal moreinfo="none">keyPressed</literal> that uses a <literal moreinfo="none">switch</literal> statement to test which arrow key was pressed and sets <literal moreinfo="none">dx</literal> or <literal moreinfo="none">dy</literal> accordingly. (There is no <literal moreinfo="none">default</literal> branch, so we ignore all other keys.) </para><programlisting language="java" format="linespecific">public void keyPressed(KeyEvent e) {
    switch (e.getKeyCode()) {
        case KeyEvent.VK_UP:
            dy = -5;
            break;
        case KeyEvent.VK_DOWN:
            dy = +5;
            break;
        case KeyEvent.VK_LEFT:
            dx = -5;
            break;
        case KeyEvent.VK_RIGHT:
            dx = +5;
            break;
    }
}</programlisting><para>The values of <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal> determine how much the sprite moves each time <literal moreinfo="none">step</literal> is invoked. While the user holds down an arrow key, the sprite will move at a constant speed. </para><para>Here’s an implementation of <literal moreinfo="none">keyReleased</literal> that runs when the user releases the key. </para><programlisting language="java" format="linespecific">public void keyReleased(KeyEvent e) {
    switch (e.getKeyCode()) {
        case KeyEvent.VK_UP:
        case KeyEvent.VK_DOWN:
            dy = 0;
            break;
        case KeyEvent.VK_LEFT:
        case KeyEvent.VK_RIGHT:
            dx = 0;
            break;
    }
}</programlisting><para>When the user releases the key, <literal moreinfo="none">keyReleased</literal> sets <literal moreinfo="none">dx</literal> or <literal moreinfo="none">dy</literal> to 0, so the sprite stops moving in that direction. </para><para>We don’t need the <literal moreinfo="none">keyTyped</literal> method for this example, but it’s required by the interface; if we don’t provide one, the compiler will complain. So we provide an implementation that does nothing: </para><programlisting language="java" format="linespecific">public void keyTyped(KeyEvent e) {
    // do nothing
}</programlisting><para>Now, here’s the code we need to create a <literal moreinfo="none">Sprite</literal>, add it to a <literal moreinfo="none">Drawing</literal>, and configure it as a <literal moreinfo="none">KeyListener</literal>: </para><programlisting language="java" format="linespecific">Sprite sprite = new Sprite("face-smile.png", 25, 150);
drawing.add(sprite);
drawing.addKeyListener(sprite);
drawing.setFocusable(true);</programlisting><para>Recall that the <literal moreinfo="none">add</literal> method is one that we wrote in <xref linkend="sec..drawing"/>. It adds an <literal moreinfo="none">Actor</literal> to the list of objects to be drawn. </para><para>The <literal moreinfo="none">addKeyListener</literal> method is inherited from <literal moreinfo="none">Canvas</literal>. It adds a <literal moreinfo="none">KeyListener</literal> to the list of objects that will receive key events. </para><para>In graphical applications, key events are only sent to components when they have the keyboard focus. The <literal moreinfo="none">setFocusable</literal> method ensures that <literal moreinfo="none">drawing</literal> will be have the focus initially, without the user having to click on it first. </para>
</sect1><sect1 id="a0000012750" remap="section">
  <title>Timers</title>
    <para>Now that you know about interfaces and events, we can show you a better way to create animations. Previously, we implemented the animation loop using <literal moreinfo="none">while (true)</literal> and <literal moreinfo="none">Thread.sleep</literal>. Java provides a <literal moreinfo="none">Timer</literal> class (in <literal moreinfo="none">javax.swing</literal>) that encapsulates this behavior. </para><para>A <literal moreinfo="none">Timer</literal> is useful for executing code at regular intervals. The constructor for <literal moreinfo="none">Timer</literal> takes two parameters: </para><itemizedlist>
  
    <listitem><para><literal moreinfo="none">int delay</literal> <literal moreinfo="none">               </literal> <literal moreinfo="none">// milliseconds between events</literal> </para></listitem>
  
    <listitem><para><literal moreinfo="none">ActionListener listener</literal> <literal moreinfo="none"> </literal> <literal moreinfo="none">// for handling timer events</literal> </para></listitem>
  
</itemizedlist><para>The <literal moreinfo="none">ActionListener</literal> interface requires only one method, <literal moreinfo="none">actionPerformed</literal>. This is the method the <literal moreinfo="none">Timer</literal> invokes after the given delay. </para><para>Using a <literal moreinfo="none">Timer</literal>, we can reorganize the code in <literal moreinfo="none">main</literal> by defining a class that implements <literal moreinfo="none">ActionListener</literal>. </para><programlisting language="java" format="linespecific">public class VideoGame implements ActionListener {
    private Drawing drawing;

    public VideoGame() {
        Sprite sprite = new Sprite("face-smile.png", 50, 50);
        drawing = new Drawing(800, 600);
        drawing.add(sprite);
        drawing.addKeyListener(sprite);
        drawing.setFocusable(true);

        JFrame frame = new JFrame("Video Game");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(drawing);
        frame.pack();
        frame.setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        drawing.step();
    }

    public static void main(String[] args) {
        VideoGame game = new VideoGame();
        Timer timer = new Timer(33, game);
        timer.start();
    }
}</programlisting><para>The <literal moreinfo="none">main</literal> method constructs a <literal moreinfo="none">VideoGame</literal> object, which creates a <literal moreinfo="none">Sprite</literal>, a <literal moreinfo="none">Drawing</literal>, and a <literal moreinfo="none">JFrame</literal>. Then it constructs a <literal moreinfo="none">Timer</literal> object and starts the timer. Every 33 milliseconds, the <literal moreinfo="none">Timer</literal> invokes <literal moreinfo="none">actionPerformed</literal>, which invokes <literal moreinfo="none">step</literal> on the <literal moreinfo="none">Drawing</literal>. </para><para><literal moreinfo="none">Drawing.step</literal> invokes <literal moreinfo="none">step</literal> on all of its <literal moreinfo="none">Actor</literal> objects, which causes them to update their position, color, or other aspects of their appearance. The <literal moreinfo="none">Drawing.step</literal> then repaints the <literal moreinfo="none">Canvas</literal>, and the time step is done. </para><para>At this point you have all of the elements you need to write your own video games. In the exercises at the end of this chapter, we have some suggestions for getting started. </para><para>We hope this final chapter has been a helpful summary of topics presented throughout the book, including input and output, decisions and loops, classes and methods, arrays and objects, inheritance, and graphics. Congratulations on making it to the end! </para>
</sect1><sect1 id="a0000012849" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>generalization:</term>
      <listitem><para><indexterm significance="normal">
  <primary>generalization</primary>

</indexterm>The process of extracting common code from two or more classes and moving it into a superclass. </para></listitem>
  </varlistentry><varlistentry>
    <term>specialization:</term>
      <listitem><para><indexterm significance="normal">
  <primary>specialization</primary>

</indexterm>Extending a class to add new attributes or methods, or to modify existing behavior. </para></listitem>
  </varlistentry><varlistentry>
    <term>polymorphism:</term>
      <listitem><para><indexterm significance="normal">
  <primary>polymorphism</primary>

</indexterm>A language feature that allows objects to be assigned to variables of related types. </para></listitem>
  </varlistentry><varlistentry>
    <term>sprite:</term>
      <listitem><para><indexterm significance="normal">
  <primary>sprite</primary>

</indexterm>A computer graphic which may be moved or otherwise manipulated on the screen. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000012860" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal moreinfo="none">ch16</literal> directory of <literal moreinfo="none">ThinkJavaCode2</literal>. See <xref linkend="code"/> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>The following exercises give you a chance to practice using the features in this chapter by extending the example code. </para><para><example id="a0000012870" role="exercise">
  <title/>
  <para> The <literal moreinfo="none">Polygon</literal> class does not provide a <literal moreinfo="none">toString</literal> method; it inherits the default <literal moreinfo="none">toString</literal> from <literal moreinfo="none">java.lang.Object</literal>, which only includes the class’s name and memory location. Write a more useful <literal moreinfo="none">toString</literal> method for <literal moreinfo="none">DrawablePolygon</literal> that includes its <inlineequation><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> points. </para>
</example> </para><para><example id="a0000012885" role="exercise">
  <title/>
  <para> Write a class <literal moreinfo="none">MovingPolygon</literal> that extends <literal moreinfo="none">RegularPolygon</literal> and implements <literal moreinfo="none">Actor</literal>. It should have instance variables <literal moreinfo="none">posx</literal> and <literal moreinfo="none">posy</literal> that specify its position and <literal moreinfo="none">dx</literal> and <literal moreinfo="none">dy</literal> that specify its velocity (and direction). During each time step, it should update its position. If it gets to the edge of the <literal moreinfo="none">Drawing</literal>, it should reverse direction by changing the sign of <literal moreinfo="none">dx</literal> or <literal moreinfo="none">dy</literal>. </para>
</example> </para><para><example id="a0000012907" role="exercise">
  <title/>
  <para> Modify the <literal moreinfo="none">VideoGame</literal> class so it displays a <literal moreinfo="none">Sprite</literal> and a <literal moreinfo="none">MovingPolygon</literal> (from the previous exercise). Add code that detects collisions between <literal moreinfo="none">Actor</literal> objects in the same <literal moreinfo="none">Drawing</literal>, and invoke a method on both objects when they collide. Hint: You might want to add a method to the <literal moreinfo="none">Actor</literal> interface, guaranteeing that all <literal moreinfo="none">Actor</literal> objects know how to handle collisions. </para>
</example> </para><para><example id="a0000012923" role="exercise">
  <title/>
  <para> Java provides other event listeners that you can implement to make your programs interactive. For example, the interfaces <literal moreinfo="none">MouseListener</literal>, <literal moreinfo="none">MouseMotionListener</literal>, and <literal moreinfo="none">MouseWheelListener</literal> allow you to respond to mouse input. Use the <literal moreinfo="none">MouseListener</literal> interface to implement an <literal moreinfo="none">Actor</literal> that can respond to mouse clicks. </para>
</example> </para></sect1>
</chapter>
