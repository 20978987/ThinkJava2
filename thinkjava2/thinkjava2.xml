<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">


<book role="animal-ah61">
    <title>Think Java</title><bookinfo>
  <title>Think Java</title>
  <authorgroup>
    <author>
      <surname>Allen B. Downey and Chris Mayfield</surname>
    </author>
  </authorgroup>
  
  
</bookinfo>
<preface id="a0000000059">
  <title>Preface</title><para><emphasis>Think Java</emphasis> is an introduction to computer science and programming intended for readers with little or no experience. We start with the most basic concepts and are careful to define all terms when they are first used. The book presents each new idea in a logical progression. Larger topics, like control flow statements and object-oriented programming, are divided into smaller examples and introduced over the course of several chapters. </para><para>This book is intentionally concise. Each chapter is 12–14 pages and covers the material for one week of a college course. It is not meant to be a comprehensive presentation of Java, but rather, an initial exposure to programming constructs and techniques. We begin with small problems and basic algorithms and work up to object-oriented design. In the vocabulary of computer science pedagogy, this book uses the “objects late” approach. </para><sect1 id="a0000000067" remap="section">
  <title>The Philosophy Behind the Book</title>
    <para>Here are the guiding principles that make the book the way it is: </para><itemizedlist>
  
    <listitem><para><emphasis>One concept at a time.</emphasis> We break down topics that give beginners trouble into a series of small steps, so that they can exercise each new concept in isolation before continuing. </para></listitem>
  
    <listitem><para><emphasis>Balance of Java and concepts.</emphasis> The book is not primarily about Java; it uses code examples to demonstrate computer science. Most chapters start with language features and end with concepts. </para></listitem>
  
    <listitem><para><emphasis>Conciseness.</emphasis> An important goal of the book is to be small enough so that students can read and understand the entire text in a one-semester college or AP course. </para></listitem>
  
    <listitem><para><emphasis>Emphasis on vocabulary.</emphasis> We try to introduce the minimum number of terms and define them carefully when they are first used. We also organize them in glossaries at the end of each chapter. </para></listitem>
  
    <listitem><para><emphasis>Program development.</emphasis> There are many strategies for writing programs, including bottom-up, top-down, and others. We demonstrate multiple program development techniques, allowing readers to choose methods that work best for them. </para></listitem>
  
    <listitem><para><emphasis>Multiple learning curves.</emphasis> To write a program, you have to understand the algorithm, know the programming language, and be able to debug errors. We discuss these and other aspects throughout the book, and include an appendix that summarizes our advice. </para></listitem>
  
</itemizedlist>
</sect1><sect1 id="a0000000095" remap="section">
  <title>Object-Oriented Programming</title>
    <para>Some Java books introduce classes and objects immediately; others begin with procedural programming and transition to object-oriented more gradually. </para><para>Many of Java’s object-oriented features are motivated by problems with previous languages, and their implementations are influenced by this history. Some of these features are hard to explain when people aren’t familiar with the problems they solve. </para><para>We get to object-oriented programming as quickly as possible (beginning with <xref linkend="immutable" />). But we introduce concepts one at a time, as clearly as possible, in a way that allows readers to practice each idea in isolation before moving on. So it takes some time to get there. </para><para>You can’t write Java programs (even hello world) without encountering object-oriented features. In some cases we explain a feature briefly when it first appears, and then explain it more deeply later on. </para><para>If you read the entire book, you will see nearly every topic required for Java SE Programmer I certification. Supplemental lessons are available in the official Java tutorials on Oracle’s website: <ulink url="https://thinkjava.org/tutorial"></ulink>. </para><para>This book is also well suited to prepare high school students for the AP Computer Science A exam, which includes object-oriented design and implementation. (AP is a registered trademark of The College Board.) A mapping of <emphasis>Think Java</emphasis> section numbers to the AP course description is available on our website: <ulink url="https://thinkjava.org/"></ulink>. </para>
</sect1><sect1 id="a0000000108" remap="section">
  <title>Changes to the 2nd Edition</title>
    <para>This new edition was written over several years, with feedback from dozens of instructors and hundreds of students. A complete history of all changes is available on GitHub. Here are some of the highlights: </para><variablelist>
  <varlistentry>
    <term>Chapters 1–4:</term>
      <listitem><para>We reordered the material in Chapter 1 to present a more interesting balance of theory and practice. Chapters 2–3 are much cleaner now too. Methods are now presented in a single chapter, along with additional in-depth examples. </para></listitem>
  </varlistentry><varlistentry>
    <term>Chapters 5–8:</term>
      <listitem><para>We rearranged these chapters a lot, added many examples and new figures, and removed unnecessary details. Strings are covered earlier (before arrays) so that readers can apply them to loop problems. The material on recursion is now a chapter, and we added new sections to explain binary numbers and CodingBat problems. </para></listitem>
  </varlistentry><varlistentry>
    <term>Chapters 9–12:</term>
      <listitem><para>Our main goal for these chapters was to provide better explanations and more diagrams. Chapters 9 and 10 focus more on immutable vs mutable objects, and we added new sections on BigInteger and StringBuilder. The other content is largely the same, but it should be easier to understand now. </para></listitem>
  </varlistentry><varlistentry>
    <term>Chapters 13–17:</term>
      <listitem><para>We balanced the amount of content in Chapters 13–14 by moving ArrayLists earlier, and we implement the “War” card game as another example. Chapters 15–17 are brand new in this edition; they cover more advanced topics including 2D arrays, graphics, exceptions, abstract classes, interfaces, and events. </para></listitem>
  </varlistentry><varlistentry>
    <term>Appendixes:</term>
      <listitem><para>We added <xref linkend="javadoc" /> to explain documentation comments and Javadoc in more detail. The other three appendixes that were present in the first edition have been revised for clarity and layout. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000000128" remap="section">
  <title>About the Appendixes</title>
    <para>The chapters of this book are meant to be read in order, because each one builds on the previous one. We also include several appendixes with material that can be read at any time: </para><variablelist>
  <varlistentry>
    <term></term>
      <listitem><para><emphasis role="bold">Appendix A: Tools</emphasis> </para><para>This appendix explains how to download and install Java so you can compile programs on your computer. It also provides a brief introduction to DrJava—an “integrated development environment” (IDE) that is designed primarily for students—and other development tools, including Checkstyle for code quality and JUnit for testing. </para></listitem>
  </varlistentry><varlistentry>
    <term></term>
      <listitem><para><emphasis role="bold">Appendix B: Javadoc</emphasis> </para><para>It’s important to document your classes and methods so that other programmers (including yourself in the future) will know how to use them. This appendix explains how to read documentation, how to write documentation, and how to use the Javadoc tool. </para></listitem>
  </varlistentry><varlistentry>
    <term></term>
      <listitem><para><emphasis role="bold">Appendix C: Graphics</emphasis> </para><para>Java provides libraries for working with graphics and animation, and these topics can be engaging for students. The libraries require object-oriented features that students will not completely understand until after <xref linkend="mutable" />, but they can be used much earlier. </para></listitem>
  </varlistentry><varlistentry>
    <term></term>
      <listitem><para><emphasis role="bold">Appendix D: Debugging</emphasis> </para><para>We provide debugging suggestions throughout the book, but we also have an appendix with many more suggestions on how to debug your programs. We recommend that readers review this appendix frequently as they work through the book. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="code" remap="section">
  <title>Using the Code Examples</title><para>Most of the code examples in this book are available from a Git repository at <ulink url="https://github.com/ChrisMayfield/ThinkJavaCode2"></ulink>. Git is a “version control system” that allows you to keep track of the files that make up a project. A collection of files under Git’s control is called a “repository”. </para><para><indexterm>
  <primary>repository</primary>

</indexterm><indexterm>
  <primary>GitHub</primary>

</indexterm>GitHub is a hosting service that provides storage for Git repositories and a convenient web interface. It provides several ways to work with the code: </para><itemizedlist>
  
    <listitem><para>You can create a copy of the repository on GitHub by pressing the Fork button. If you don’t already have a GitHub account, you’ll need to create one. After forking, you’ll have your own repository on GitHub that you can use to keep track of code you write. Then you can “clone” the repository, which downloads a copy of the files to your computer. </para></listitem>
  
    <listitem><para>Alternatively, you could clone the original repository without forking. If you choose this option, you don’t need a GitHub account, but you won’t be able to save your changes on GitHub. </para></listitem>
  
    <listitem><para>If you don’t want to use Git at all, you can download the code in a ZIP archive using the Download ZIP button on the GitHub page, or this link: <ulink url="https://thinkjava.org/code2zip"></ulink>. </para></listitem>
  
</itemizedlist><para>After you clone the repository or unzip the ZIP file, you should have a directory named <literal>ThinkJavaCode2</literal> with a subdirectory for each chapter in the book. </para><para>The examples in this book were developed and tested using OpenJDK 11. If you are using a more recent version, everything should still work. If you are using an older version, some of the examples might not. </para>
</sect1><sect1 id="a0000000178" remap="section">
  <title>Acknowledgments</title>
    <para>Many people have sent corrections and suggestions over the years, and we appreciate their valuable feedback! This list begins with Version 4.0 of the open-source edition, so it omits those who contributed to earlier versions. </para><itemizedlist>
  
    <listitem><para>Ellen Hildreth used this book to teach Data Structures at Wellesley College and submitted a whole stack of corrections and suggestions. </para></listitem>
  
    <listitem><para>Tania Passfield pointed out that some glossaries had leftover terms that no longer appeared in the text. </para></listitem>
  
    <listitem><para>Elizabeth Wiethoff noticed that the series expansion of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> was wrong. She has also worked on a Ruby version of the book. </para></listitem>
  
    <listitem><para>Matt Crawford sent in a whole patch file full of corrections. </para></listitem>
  
    <listitem><para>Chi-Yu Li pointed out a typo and an error in one of the code examples. </para></listitem>
  
    <listitem><para>Doan Thanh Nam corrected an example. </para></listitem>
  
    <listitem><para>Muhammad Saied translated the book into Arabic, and found several errors in the process. </para></listitem>
  
    <listitem><para>Marius Margowski found an inconsistency in a code example. </para></listitem>
  
    <listitem><para>Leslie Klein discovered another error in the series expansion of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>, identified typos in the card array figures, and gave helpful suggestions to clarify several exercises. </para></listitem>
  
    <listitem><para>Micah Lindstrom reported half a dozen typos and sent corrections. </para></listitem>
  
    <listitem><para>James Riely ported the textbook source from LaTeX to Sphinx. <ulink url="http://fpl.cs.depaul.edu/jriely/thinkapjava/"></ulink> </para></listitem>
  
    <listitem><para>Peter Knaggs ported the book to C#. <ulink url="https://www.rigwit.co.uk/think/sharp/"></ulink> </para></listitem>
  
    <listitem><para>Heidi Gentry-Kolen recorded several video lectures that follow the book. <ulink url="https://www.youtube.com/user/digipipeline"></ulink> </para></listitem>
  
    <listitem><para>Waldo Ribeiro submitted a pull request that corrected a dozen typos. </para></listitem>
  
    <listitem><para>Michael Stewart made several suggestions for improving the first half of the book. </para></listitem>
  
    <listitem><para>Steven Richardson adapted the book for an online course and contributed many ideas for improving the text. </para></listitem>
  
    <listitem><para>Fazl Rahman provided detailed feedback, chapter by chapter, and offered many suggestions for improving the text. </para></listitem>
  
</itemizedlist><para>We are especially grateful to the technical reviewers of the O’Reilly Media first edition: Blythe Samuels, David Wisneski, and Stephen Rose. They found errors, made many great suggestions, and helped make the book much better. </para><para>Likewise we thank Marc Loy for his thorough review of the O’Reilly Media second edition. He contributed many corrections, insights, and clarifications throughout the book. </para><para>Many students have given exceptional feedback, including Ian Staton, Tanner Wernecke, Jacob Green, Rasha Abuhantash, Nick Duncan, Kylie Davidson, Shirley Jiang, Elena Trafton, Jennifer Gregorio, and Azeem Mufti. </para><para>Other contributors who found one or more typos: Stijn Debrouwere, Guy Driesen, Andai Velican, Chris Kuszmaul, Daniel Kurikesu, Josh Donath, Rens Findhammer, Elisa Abedrapo, Yousef BaAfif, Bruce Hill, Matt Underwood, Isaac Sultan, Dan Rice, Robert Beard, Daniel Pierce, Michael Giftthaler, Chris Fox, Min Zeng, Markus Geuss, Mauricio Gonzalez, Enrico Sartirana, Kasem Satitwiwat, and Jason Miller. </para><para>If you have additional comments or ideas about the text, please send them to: <ulink url="mailto:feedback@greenteapress.com"></ulink>. </para><para>Allen Downey and Chris Mayfield </para></sect1>
</preface><chapter id="theway">
  <title>Computer Programming</title><para>The goal of this book is to teach you to think like a computer scientist. This way of thinking combines some of the best features of mathematics, engineering, and natural science. Like mathematicians, computer scientists use formal languages to denote ideas, specifically computations. Like engineers, they design things, assembling components into systems and evaluating trade-offs among alternatives. And like scientists, they observe the behavior of complex systems, form hypotheses, and test predictions. </para><para><indexterm>
  <primary>problem solving</primary>

</indexterm>An important skill for a computer scientist is <emphasis role="bold">problem solving</emphasis>. It involves the ability to formulate problems, think creatively about solutions, and express solutions clearly and accurately. As it turns out, the process of learning to program computers is an excellent opportunity to develop problem-solving skills. On one level you will be learning to write Java programs, a useful skill by itself. But on another level you will use programming as a means to an end. As we go along, that end will become clearer. </para><sect1 id="a0000000245" remap="section">
  <title>What Is a Computer?</title>
    <para>When people hear the word computer, they often think of a desktop or laptop. Not surprisingly, searching for “computer” on <ulink url="https://images.google.com/"></ulink> displays rows and rows of these types of machines. However, in a more general sense, a computer can be any type of device that stores and processes data. </para><para>Dictionary.com defines a computer as “a programmable electronic device designed to accept data, perform prescribed mathematical and logical operations at high speed, and display the results of these operations. Mainframes, desktop and laptop computers, tablets, and smartphones are some of the different types of computers.” </para><para><indexterm>
  <primary>hardware</primary>

</indexterm><indexterm>
  <primary>processor</primary>

</indexterm><indexterm>
  <primary>memory</primary>

</indexterm><indexterm>
  <primary>CPU</primary>

</indexterm><indexterm>
  <primary>RAM</primary>

</indexterm>Each type of computer has its own unique design, but internally they all share the same type of <emphasis role="bold">hardware</emphasis>. The two most important hardware components are <emphasis role="bold">processors</emphasis> (or CPUs) that perform simple calculations and <emphasis role="bold">memory</emphasis> (or RAM) that temporarily stores information. <xref linkend="fig.cpuram" /> shows what these components look like. </para>
  
  <figure id="fig.cpuram" float="False">
    <title>Example processor and memory hardware.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/CPU.jpg"></imagedata>
  </imageobject>
</mediaobject>  <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/RAM.jpg"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Users generally see and interact with touchscreens, keyboards, and monitors, but it’s the processors and memory that perform the actual computation. Nowadays it’s fairly standard, even for a smartphone, to have at least eight processors and four gigabytes (four billion cells) of memory. </para>
</sect1><sect1 id="a0000000268" remap="section">
  <title>What Is Programming?</title>
    <para><indexterm>
  <primary>program</primary>

</indexterm>A <emphasis role="bold">program</emphasis> is a sequence of instructions that specifies how to perform a computation on computer hardware. The computation might be something mathematical, like solving a system of equations or finding the roots of a polynomial. It could also be a symbolic computation, like searching and replacing text in a document or (strangely enough) compiling a program. </para><para>The details look different in different languages, but a few basic instructions appear in just about every language: </para><variablelist>
  <varlistentry>
    <term>input:</term>
      <listitem><para>Get data from the keyboard, a file, a sensor, or some other device. </para></listitem>
  </varlistentry><varlistentry>
    <term>output:</term>
      <listitem><para>Display data on the screen, or send data to a file or other device. </para></listitem>
  </varlistentry><varlistentry>
    <term>math:</term>
      <listitem><para>Perform basic mathematical operations like addition and division. </para></listitem>
  </varlistentry><varlistentry>
    <term>decision:</term>
      <listitem><para>Check for certain conditions and execute the appropriate code. </para></listitem>
  </varlistentry><varlistentry>
    <term>repetition:</term>
      <listitem><para>Perform some action repeatedly, usually with some variation. </para></listitem>
  </varlistentry>
</variablelist><para><indexterm>
  <primary>programming</primary>

</indexterm>Believe it or not, that’s pretty much all there is to it. Every program you’ve ever used, no matter how complicated, is made up of small instructions that look much like these. So you can think of <emphasis role="bold">programming</emphasis> as the process of breaking down a large, complex task into smaller and smaller subtasks. The process continues until the subtasks are simple enough to be performed with the electronic circuits provided by the hardware. </para>
</sect1><sect1 id="hello" remap="section">
  <title>The Hello World Program</title><para><indexterm>
  <primary>Hello.java</primary>

</indexterm>Traditionally, the first program you write when learning a new programming language is called the hello world program. All it does is output the words “Hello, World!” to the screen. In Java, it looks like this: </para><programlisting language="java">
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }
}</programlisting><para>When this program runs it displays: </para><programlisting>Hello, World!</programlisting><para>Notice that the output does not include the quotation marks. </para><para><indexterm>
  <primary>statement</primary>

</indexterm><indexterm>
  <primary>print statement</primary>

</indexterm>Java programs are made up of <emphasis>class</emphasis> and <emphasis>method</emphasis> definitions, and methods are made up of <emphasis>statements</emphasis>. A <emphasis role="bold">statement</emphasis> is a line of code that performs a basic action. In the hello world program, this line is a <emphasis role="bold">print statement</emphasis> that displays a message to the user: </para><programlisting language="java">
System.out.println("Hello, World!");</programlisting><para><indexterm>
  <primary>println</primary>

</indexterm><indexterm>
  <primary>semicolon</primary>

</indexterm><indexterm>
  <primary>; semicolon</primary>

</indexterm><literal>System.out.println</literal> displays results on the screen; the name <literal>println</literal> stands for “print line”. Confusingly, <emphasis>print</emphasis> can mean both “display on the screen” and “send to the printer”. In this book, we’ll try to say “display” when we mean output to the screen. Like most statements, the print statement ends with a semicolon (<literal>;</literal>). </para><para><indexterm>
  <primary>case-sensitive</primary>

</indexterm>Java is “case-sensitive”, which means that uppercase and lowercase are not the same. In the hello world program, <literal>System</literal> has to begin with an uppercase letter; <literal>system</literal> and <literal>SYSTEM</literal> won’t work. </para><para><indexterm>
  <primary>method</primary>

</indexterm>A <emphasis role="bold">method</emphasis> is a named sequence of statements. This program defines one method named <literal>main</literal>: </para><programlisting language="java">
public static void main(String[] args)</programlisting><para><indexterm>
  <primary>main</primary>

</indexterm>The name and format of <literal>main</literal> is special: when the program runs, it starts at the first statement in <literal>main</literal> and ends when it finishes the last statement. Later, we will see programs that define more than one method. </para><para><indexterm>
  <primary>class</primary>

</indexterm>This program defines a class named <literal>Hello</literal>. For now, a <emphasis role="bold">class</emphasis> is a collection of methods; we’ll have more to say about this later. You can give a class any name you like, but it is conventional to start with a capital letter. The name of the class has to match the name of the file it is in, so this class has to be in a file named <literal>Hello.java</literal>. </para><para><indexterm>
  <primary>{} curly braces</primary>

</indexterm><indexterm>
  <primary>brackets</primary>
<secondary>curly</secondary>
</indexterm>Java uses curly braces ({ and }) to group things together. In <literal>Hello.java</literal>, the outermost braces contain the class definition, and the inner braces contain the method definition. </para><para><indexterm>
  <primary>comment</primary>
<secondary>end-of-line</secondary>
</indexterm><indexterm>
  <primary>statement</primary>
<secondary>comment</secondary>
</indexterm>The line that begins with two slashes (<literal>//</literal>) is a <emphasis role="bold">comment</emphasis>, which is a bit of English text that explains the code. When Java sees <literal>//</literal>, it ignores everything from there until the end of the line. Comments have no effect on the execution of the program, but they make it easier for other programmers (and your future self) to understand what you meant to do. </para>
</sect1><sect1 id="a0000000371" remap="section">
  <title>Compiling Java Programs</title>
    <para><indexterm>
  <primary>high-level language</primary>

</indexterm><indexterm>
  <primary>language</primary>
<secondary>high-level</secondary>
</indexterm>The programming language you will learn in this book is Java, which is a <emphasis role="bold">high-level language</emphasis>. Other high-level languages you may have heard of include Python, C and C++, PHP, Ruby, and JavaScript. </para><para><indexterm>
  <primary>low-level language</primary>

</indexterm><indexterm>
  <primary>language</primary>
<secondary>low-level</secondary>
</indexterm>Before they can run, programs in high-level languages have to be translated into a <emphasis role="bold">low-level language</emphasis>, also called “machine language”. This translation takes some time, which is a small disadvantage of high-level languages. But high-level languages have two major advantages: </para><itemizedlist>
  
    <listitem><para><indexterm>
  <primary>portable</primary>

</indexterm>It is <emphasis>much</emphasis> easier to program in a high-level language. Programs take less time to write, they are shorter and easier to read, and they are more likely to be correct. </para></listitem>
  
    <listitem><para>High-level languages are <emphasis role="bold">portable</emphasis>, meaning they can run on different kinds of computers with few or no modifications. Low-level programs can only run on one kind of computer. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>interpret</primary>

</indexterm>Two kinds of programs translate high-level languages into low-level languages: interpreters and compilers. An <emphasis role="bold">interpreter</emphasis> reads a high-level program and executes it, meaning that it does what the program says. It processes the program a little at a time, alternately reading lines and performing computations. <xref linkend="fig.interpreter" /> shows the structure of an interpreter. </para>
  
  <figure id="fig.interpreter" float="False">
    <title>How interpreted languages are executed.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/interpreter.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>compile</primary>

</indexterm><indexterm>
  <primary>source code</primary>

</indexterm><indexterm>
  <primary>object code</primary>

</indexterm><indexterm>
  <primary>executable</primary>

</indexterm>In contrast, a <emphasis role="bold">compiler</emphasis> reads the entire program and translates it completely before the program starts running. In this context, the high-level program is called the <emphasis role="bold">source code</emphasis>. The translated program is called the <emphasis role="bold">object code</emphasis> or the <emphasis role="bold">executable</emphasis>. Once a program is compiled, you can execute it repeatedly without further translation. As a result, compiled programs often run faster than interpreted programs. </para><para>Note that object code, as a low-level language, is not portable. You cannot run an executable compiled for a Windows laptop on an Android phone, for example. In order to run a program on different types of machines, it must be compiled multiple times. It can be difficult to write source code that compiles and runs correctly on different types of machines. </para><para><indexterm>
  <primary>byte code</primary>

</indexterm><indexterm>
  <primary>virtual machine</primary>

</indexterm>To address this issue, Java is <emphasis>both</emphasis> compiled and interpreted. Instead of translating source code directly into an executable, the Java compiler generates code for a <emphasis role="bold">virtual machine</emphasis>. This “imaginary” machine has the functionality common to desktops, laptops, tablets, phones, etc. Its language, called Java <emphasis role="bold">byte code</emphasis>, looks like object code and is easy and fast to interpret. </para><para><indexterm>
  <primary>javac</primary>

</indexterm><indexterm>
  <primary>JVM</primary>

</indexterm>As a result, it’s possible to compile a Java program on one machine, transfer the byte code to another machine, and run the byte code on the other machine. <xref linkend="fig.compiler" /> shows the steps of the development process. The Java compiler is a program named <literal>javac</literal>. It translates <literal>.java</literal> files into <literal>.class</literal> files that store the resulting byte code. The Java interpreter is another program, named <literal>java</literal>, which is short for “Java Virtual Machine” (JVM). </para>
  
  <figure id="fig.compiler" float="False">
    <title>The process of compiling and running a Java program.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/compiler.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The programmer writes source code in the file <literal>Hello.java</literal> and uses <literal>javac</literal> to compile it. If there are no errors, the compiler saves the byte code in the file <literal>Hello.class</literal>. To run the program, the programmer uses <literal>java</literal> to interpret the byte code. The result of the program is then displayed on the screen. </para><para>Although it might seem complicated, these steps are automated for you in most development environments. Usually you only have to press a button or type a single command to compile and interpret your program. On the other hand, it is important to know what steps are happening in the background, so if something goes wrong you can figure out what it is. </para>
</sect1><sect1 id="goodbye" remap="section">
  <title>Displaying Two Messages</title>
    <para>You can put as many statements as you like in the <literal>main</literal> method. For example, to display more than one line of output: </para><programlisting language="java">
public class Hello2 {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");  // first line
        System.out.println("How are you?");   // another line
    }
}</programlisting><para>As this example also shows, you can put comments at the end of a line as well as on lines all by themselves. </para><para><indexterm>
  <primary>quote mark</primary>

</indexterm><indexterm>
  <primary>string</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>String</secondary>
</indexterm><indexterm>
  <primary>char</primary>

</indexterm>Phrases that appear in quotation marks are called <emphasis role="bold">strings</emphasis>, because they contain a sequence of characters strung together in memory. Characters can be letters, numbers, punctuation marks, symbols, spaces, tabs, etc. </para><para><indexterm>
  <primary>Goodbye.java</primary>

</indexterm><indexterm>
  <primary>newline</primary>

</indexterm><indexterm>
  <primary>print</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>print</secondary>
</indexterm><literal>System.out.println</literal> appends a special character, called a <emphasis role="bold">newline</emphasis>, that moves to the beginning of the next line. If you don’t want a newline at the end, you can use <literal>print</literal> instead of <literal>println</literal>: </para><programlisting language="java">
public class Goodbye {

    public static void main(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel world");
    }
}</programlisting><para>In this example, the first statement does not add a newline, so the output appears on a single line: </para><programlisting>Goodbye, cruel world</programlisting><para>Notice that there is a space at the end of the first string, which appears in the output just before the word <literal>cruel</literal>. </para>
</sect1><sect1 id="formatting" remap="section">
  <title>Formatting Source Code</title><para>In Java source code, some spaces are required. For example, you need at least one space between words, so this program is not legal: </para><programlisting language="java">
publicclassGoodbye{

    publicstaticvoidmain(String[] args) {
        System.out.print("Goodbye, ");
        System.out.println("cruel world");
    }
}</programlisting><para>But most other spaces are optional. For example, this program <emphasis>is</emphasis> legal: </para><programlisting language="java">
public class Goodbye {
public static void main(String[] args) {
System.out.print("Goodbye, ");
System.out.println("cruel world");
}
}</programlisting><para>The newlines are optional, too. So we could just write: </para><programlisting language="java">
public class Goodbye { public static void main(String[] args)
{ System.out.print("Goodbye, "); System.out.println
("cruel world");}}</programlisting><para>It still works, but the program is getting harder and harder to read. Newlines and spaces are important for organizing your program visually, making it easier to understand the program and find errors when they occur. </para><para>Many editors will automatically format source code with consistent indenting and line breaks. For example, in DrJava (see <xref linkend="drjava" />) you can indent your code by selecting all text (Ctrl+A) and pressing the Tab key. </para><para><indexterm>
  <primary>Google style</primary>

</indexterm><indexterm>
  <primary>style guide</primary>

</indexterm>Organizations that do a lot of software development usually have strict guidelines on how to format source code. For example, Google publishes its Java coding standards for use in open-source projects: <ulink url="https://google.github.io/styleguide/javaguide.html"></ulink>. </para><para>You probably won’t understand these guidelines now, because they refer to language features we haven’t yet seen. But you might want to refer back to them periodically as you read this book. </para>
</sect1><sect1 id="a0000000504" remap="section">
  <title>Escape Sequences</title>
    <para>It’s possible to display multiple lines of output with only one line of code. You just have to tell Java where to put the line breaks. </para><programlisting language="java">
public class Hello3 {

    public static void main(String[] args) {
        System.out.print("Hello!\nHow are you doing?\n");
    }
}</programlisting><para>The output is two lines, each ending with a newline character: </para><programlisting>Hello!
How are you doing?</programlisting><para><indexterm>
  <primary>escape sequence</primary>

</indexterm>Each <literal remap="verb">\n</literal> is an <emphasis role="bold">escape sequence</emphasis>, or two characters of source code that represent a single character. (The backslash allows you to “escape” the string to write special characters.) Notice there is no space between <literal remap="verb">\n</literal> and <literal remap="verb">How</literal>. If you add a space there, there will be a space at the beginning of the second line. </para>
   
     <table id="tab..escape" remap="tabular">
     <title>Common escape sequences</title>
     <tgroup>
     
     <tbody>
     <row>
     
       
       <entry> </entry>
     
       
       <entry><para> <literal remap="verb">\n</literal> </para><para> newline </para><para><literal remap="verb">\t</literal> </para><para> tab </para><para><literal remap="verb">\"</literal> </para><para> double quote </para><para><literal remap="verb">\\</literal> </para><para> backslash </para></entry>
     
       
       <entry> </entry>
     
       
       <entry>Common escape sequences</entry>
     
       
       <entry> </entry>
     
       
       <entry></entry>
     
       
       <entry> </entry>
     
     </row>
     </tbody>
     </tgroup>
     </table>
   
   
<para>Java has a total of eight escape sequences, and the four most commonly used ones are listed in <xref linkend="tab..escape" />. For example, to write quotation marks inside of strings, you need to escape them with a backslash. </para><programlisting language="java">
System.out.println("She said \"Hello!\" to me.");</programlisting><para>The result is: </para><programlisting>She said "Hello!" to me.</programlisting></sect1><sect1 id="a0000000560" remap="section">
  <title>What Is Computer Science?</title>
    <para>This book intentionally omits some details about the Java language (such as the other escape sequences), because our main goal is learning how to think like a computer scientist. Being able to understand computation is much more valuable than just learning how to write code. </para><para>If you’re interested in learning more about Java itself, Oracle maintains an official set of tutorials on their website: <ulink url="https://thinkjava.org/tutorial"></ulink>. The “Language Basics” tutorial (found under “Learning the Java Language”) is a good place to start. </para><para>One of the most interesting aspects of writing programs is deciding how to solve a particular problem, especially when there are multiple solutions. For example, there are numerous ways to sort a list of numbers, and each way has its advantages. In order to determine which way is best for a given situation, we need techniques for describing and analyzing solutions formally. </para><para><indexterm>
  <primary>algorithm</primary>

</indexterm><indexterm>
  <primary>computer science</primary>

</indexterm>An <emphasis role="bold">algorithm</emphasis> is a sequence of steps that specifies how to solve a problem. Some algorithms are faster than others, and some use less space in computer memory. <emphasis role="bold">Computer science</emphasis> is the science of algorithms, including their discovery and analysis. As you learn to develop algorithms for problems you haven’t solved before, you will learn to think like a computer scientist. </para><para><indexterm>
  <primary>bug</primary>

</indexterm><indexterm>
  <primary>debugging</primary>

</indexterm>Designing algorithms and writing code is difficult and error-prone. For historical reasons, programming errors are called <emphasis role="bold">bugs</emphasis>, and the process of tracking them down and correcting them is called <emphasis role="bold">debugging</emphasis>. As you learn to debug your programs, you will develop new problem-solving skills. You will need to think creatively when unexpected errors happen. </para><para>Although it can be frustrating, debugging is an intellectually rich, challenging, and interesting part of computer science. In some ways, debugging is like detective work. You are confronted with clues, and you have to infer the processes and events that led to the results you see. Thinking about how to correct programs and improve their performance sometimes even leads to the discovery of new algorithms. </para>
</sect1><sect1 id="sec..examples" remap="section">
  <title>Debugging Programs</title><para>It is a good idea to read this book in front of a computer so you can try out the examples as you go. You can run many of the examples directly in DrJava’s Interactions Pane (see <xref linkend="interactions" />). But if you put the code in a source file, it will be easier to try out variations. </para><para><indexterm>
  <primary>error</primary>
<secondary>message</secondary>
</indexterm>Whenever you are experimenting with a new feature, you should also try to make mistakes. For example, in the hello world program, what happens if you leave out one of the quotation marks? What if you leave out both? What if you spell <literal>println</literal> wrong? These kinds of experiments help you remember what you read. They also help with debugging, because you learn what the error messages mean. It is better to make mistakes now and on purpose than later on and accidentally. </para><para><indexterm>
  <primary>experimental debugging</primary>

</indexterm><indexterm>
  <primary>debugging</primary>
<secondary>experimental</secondary>
</indexterm>Debugging is like an experimental science: once you have an idea about what is going wrong, you modify your program and try again. If your hypothesis was correct, then you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one. </para><para>Programming and debugging should go hand in hand. Don’t just write a bunch of code and then perform trial and error debugging until it all works. Instead, start with a program that does <emphasis>something</emphasis> and make small modifications, debugging them as you go, until the program does what you want. That way you will always have a working program, and it will be easier to isolate errors. </para><para><indexterm>
  <primary>Linux</primary>

</indexterm><indexterm>
  <primary>Torvalds, Linus</primary>

</indexterm><indexterm>
  <primary>Greenfield, Larry</primary>

</indexterm>A great example of this principle is the Linux operating system, which contains millions of lines of code. It started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. According to Larry Greenfield in <emphasis>The Linux Users’ Guide</emphasis>, “One of Linus’s earlier projects was a program that would switch between printing AAAA and BBBB. This later evolved to Linux.” </para><para>Finally, programming sometimes brings out strong emotions. If you are struggling with a difficult bug, you might feel angry, despondent, or embarrassed. Remember that you are not alone, and virtually every programmer has had similar experiences. Don’t hesitate to reach out to a friend and ask questions! </para>
</sect1><sect1 id="a0000000597" remap="section">
  <title>Vocabulary</title>
    <para>Throughout the book, we try to define each term the first time we use it. At the end of each chapter, we include the new terms and their definitions in order of appearance. If you spend some time learning this vocabulary, you will have an easier time reading the following chapters. </para><variablelist>
  <varlistentry>
    <term>problem solving:</term>
      <listitem><para><indexterm>
  <primary>problem solving</primary>

</indexterm>The process of formulating a problem, finding a solution, and expressing the solution. </para></listitem>
  </varlistentry><varlistentry>
    <term>hardware:</term>
      <listitem><para><indexterm>
  <primary>hardware</primary>

</indexterm>The electronic and mechanical components of a computer, such as CPUs, RAM, and hard disks. </para></listitem>
  </varlistentry><varlistentry>
    <term>processor:</term>
      <listitem><para><indexterm>
  <primary>processor</primary>

</indexterm>A computer chip that performs simple instructions like basic arithmetic and logic. </para></listitem>
  </varlistentry><varlistentry>
    <term>memory:</term>
      <listitem><para><indexterm>
  <primary>memory</primary>

</indexterm>Circuits that store data as long as the computer is turn on. Not to be confused with permanent storage devices like hard disks and flash. </para></listitem>
  </varlistentry><varlistentry>
    <term>program:</term>
      <listitem><para><indexterm>
  <primary>program</primary>

</indexterm>A sequence of instructions that specifies how to perform tasks on a computer. Also known as software. </para></listitem>
  </varlistentry><varlistentry>
    <term>programming:</term>
      <listitem><para><indexterm>
  <primary>programming</primary>

</indexterm>The application of problem solving to creating executable computer programs. </para></listitem>
  </varlistentry><varlistentry>
    <term>statement:</term>
      <listitem><para><indexterm>
  <primary>statement</primary>

</indexterm>Part of a program that specifies one step of an algorithm. </para></listitem>
  </varlistentry><varlistentry>
    <term>print statement:</term>
      <listitem><para><indexterm>
  <primary>print statement</primary>

</indexterm>A statement that causes output to be displayed on the screen. </para></listitem>
  </varlistentry><varlistentry>
    <term>method:</term>
      <listitem><para><indexterm>
  <primary>method</primary>

</indexterm>A named sequence of statements. </para></listitem>
  </varlistentry><varlistentry>
    <term>class:</term>
      <listitem><para><indexterm>
  <primary>class</primary>

</indexterm>For now, a collection of related methods. (We will see later that there is a lot more to it.) </para></listitem>
  </varlistentry><varlistentry>
    <term>comment:</term>
      <listitem><para><indexterm>
  <primary>comment</primary>

</indexterm>A part of a program that contains information about the program but has no effect when the program runs. </para></listitem>
  </varlistentry><varlistentry>
    <term>high-level language:</term>
      <listitem><para><indexterm>
  <primary>high-level language</primary>

</indexterm>A programming language that is designed to be easy for humans to read and write. </para></listitem>
  </varlistentry><varlistentry>
    <term>low-level language:</term>
      <listitem><para><indexterm>
  <primary>low-level language</primary>

</indexterm>A programming language that is designed to be easy for a computer to run. Also called “machine language”. </para></listitem>
  </varlistentry><varlistentry>
    <term>portable:</term>
      <listitem><para><indexterm>
  <primary>portable</primary>

</indexterm>The ability of a program to run on more than one kind of computer. </para></listitem>
  </varlistentry><varlistentry>
    <term>interpret:</term>
      <listitem><para><indexterm>
  <primary>interpret</primary>

</indexterm>To run a program in a high-level language by translating it one line at a time and immediately executing the corresponding instructions. </para></listitem>
  </varlistentry><varlistentry>
    <term>compile:</term>
      <listitem><para><indexterm>
  <primary>compile</primary>

</indexterm>To translate a program in a high-level language into a low-level language, all at once, in preparation for later execution. </para></listitem>
  </varlistentry><varlistentry>
    <term>source code:</term>
      <listitem><para><indexterm>
  <primary>source code</primary>

</indexterm>A program in a high-level language, before being compiled. </para></listitem>
  </varlistentry><varlistentry>
    <term>object code:</term>
      <listitem><para><indexterm>
  <primary>object code</primary>

</indexterm>The output of the compiler, after translating the program. </para></listitem>
  </varlistentry><varlistentry>
    <term>executable:</term>
      <listitem><para><indexterm>
  <primary>executable</primary>

</indexterm>Another name for object code that is ready to run on specific hardware. </para></listitem>
  </varlistentry><varlistentry>
    <term>virtual machine:</term>
      <listitem><para><indexterm>
  <primary>virtual machine</primary>

</indexterm>An emulation of a real machine. The Java Virtual Machine enables a computer to run Java programs. </para></listitem>
  </varlistentry><varlistentry>
    <term>byte code:</term>
      <listitem><para><indexterm>
  <primary>byte code</primary>

</indexterm>A special kind of object code used for Java programs. Byte code is similar to object code, but it is portable like a high-level language. </para></listitem>
  </varlistentry><varlistentry>
    <term>string:</term>
      <listitem><para><indexterm>
  <primary>string</primary>

</indexterm>A sequence of characters; the primary data type for text. </para></listitem>
  </varlistentry><varlistentry>
    <term>newline:</term>
      <listitem><para><indexterm>
  <primary>newline</primary>

</indexterm>A special character signifying the end of a line of text. Also known as line ending, end of line (EOL), or line break. </para></listitem>
  </varlistentry><varlistentry>
    <term>escape sequence:</term>
      <listitem><para><indexterm>
  <primary>escape sequence</primary>

</indexterm>A sequence of code that represents a special character when used inside a string. </para></listitem>
  </varlistentry><varlistentry>
    <term>algorithm:</term>
      <listitem><para><indexterm>
  <primary>algorithm</primary>

</indexterm>A procedure or formula for solving a problem, with or without a computer. </para></listitem>
  </varlistentry><varlistentry>
    <term>computer science:</term>
      <listitem><para><indexterm>
  <primary>computer science</primary>

</indexterm>The scientific and practical approach to computation and its applications. </para></listitem>
  </varlistentry><varlistentry>
    <term>bug:</term>
      <listitem><para><indexterm>
  <primary>bug</primary>

</indexterm>An error in a program. </para></listitem>
  </varlistentry><varlistentry>
    <term>debugging:</term>
      <listitem><para><indexterm>
  <primary>debugging</primary>

</indexterm>The process of finding and removing errors. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000000657" remap="section">
  <title>Exercises</title>
    <para>At the end of each chapter, we include exercises you can do with the things you’ve learned. We encourage you to at least attempt every problem. You can’t learn to program only by reading about it; you have to practice. </para><para>Before you can compile and run Java programs, you might have to download and install a few tools. There are many good options, but we recommend DrJava, which is an “integrated development environment” (IDE) well suited for beginners. Instructions for getting started are in <xref linkend="tools" />. </para><para>The code for this chapter is in the <literal>ch01</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000000670" role="exercise">
  <title></title>
  <para>Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning. For example, in English, statements and comments are the same thing, but in programs they are different. </para><orderedlist>
  
  <listitem><para>In computer jargon, what’s the difference between a statement and a comment? </para></listitem>
  
  <listitem><para>What does it mean to say that a program is portable? </para></listitem>
  
  <listitem><para>In common English, what does the word compile mean? </para></listitem>
  
  <listitem><para>What is an executable? Why is that word used as a noun? </para></listitem>
  
</orderedlist><para>The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science. When you see familiar words, don’t assume that you know what they mean! </para>
</example> </para><para><example id="a0000000684" role="exercise">
  <title></title>
  <para>Before you do anything else, find out how to compile and run a Java program. Some environments provide sample programs similar to the example in <xref linkend="hello" />. </para><orderedlist>
  
  <listitem><para>Type in the hello world program, then compile and run it. </para></listitem>
  
  <listitem><para>Add a print statement that displays a second message after the “Hello, World!”. Say something witty like, “How are you?” Compile and run the program again. </para></listitem>
  
  <listitem><para>Add a comment to the program (anywhere), recompile, and run it again. The new comment should not affect the result. </para></listitem>
  
</orderedlist><para>This exercise may seem trivial, but it is the starting place for many of the programs we will work with. To debug with confidence, you will need to have confidence in your programming environment. </para><para>In some environments, it is easy to lose track of which program is executing. You might find yourself trying to debug one program while you are accidentally running another. Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running. </para>
</example> </para><para><example id="a0000000699" role="exercise">
  <title></title>
  <para>It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces. Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it. But sometimes the error messages are misleading. Over time you will develop a sense for when you can trust the compiler and when you have to figure things out yourself. </para><para>Starting with the hello world program, try out each of the following errors. After you make each change, compile the program, read the error message (if there is one), and then fix the error. </para><orderedlist>
  
  <listitem><para>Remove one of the open curly braces. </para></listitem>
  
  <listitem><para>Remove one of the close curly braces. </para></listitem>
  
  <listitem><para>Instead of <literal>main</literal>, write <literal>mian</literal>. </para></listitem>
  
  <listitem><para>Remove the word <literal>static</literal>. </para></listitem>
  
  <listitem><para>Remove the word <literal>public</literal>. </para></listitem>
  
  <listitem><para>Remove the word <literal>System</literal>. </para></listitem>
  
  <listitem><para>Replace <literal>println</literal> with <literal>Println</literal>. </para></listitem>
  
  <listitem><para>Replace <literal>println</literal> with <literal>print</literal>. </para></listitem>
  
  <listitem><para>Delete one of the parentheses. </para></listitem>
  
  <listitem><para>Add an extra parenthesis. </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</chapter><chapter id="a0000000742">
  <title>Variables and Operators</title>
  <para>This chapter describes how to write statements using <emphasis>variables</emphasis>, which store values like numbers and words, and <emphasis>operators</emphasis>, which are symbols that perform a computation. We also explain three kinds of programming errors and offer additional debugging advice. </para><para>To run the examples in this chapter, you will need to create a new Java class with a <literal>main</literal> method (see <xref linkend="hello" />). Throughout the book, we often omit class and method definitions to keep the examples concise. </para><sect1 id="a0000000753" remap="section">
  <title>Declaring Variables</title>
    <para><indexterm>
  <primary>variable</primary>

</indexterm><indexterm>
  <primary>value</primary>

</indexterm>One of the most powerful features of a programming language is the ability to define and manipulate <emphasis role="bold">variables</emphasis>. A variable is a named location in memory that stores a <emphasis role="bold">value</emphasis>. Values may be numbers, text, images, sounds, and other types of data. To store a value, you first have to declare a variable. </para><programlisting language="java">
String message;</programlisting><para><indexterm>
  <primary>declaration</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>declaration</secondary>
</indexterm><indexterm>
  <primary>type</primary>
<secondary>int</secondary>
</indexterm><indexterm>
  <primary>type</primary>
<secondary>char</secondary>
</indexterm><indexterm>
  <primary>type</primary>
<secondary>String</secondary>
</indexterm>This statement is called a <emphasis role="bold">declaration</emphasis>, because it declares that the variable <literal>message</literal> has the type <literal>String</literal>. Each variable has a <emphasis role="bold">type</emphasis> that determines what kind of values it can store. For example, the <literal>int</literal> type can store integers like <literal>1</literal> and <literal>-5</literal>, and the <literal>char</literal> type can store characters like <literal>’A’</literal> and <literal>’z’</literal>. </para><para>Some types begin with a capital letter and some with lowercase. We will learn the significance of this distinction later, but for now you should take care to get it right. There is no such type as <literal>Int</literal> or <literal>string</literal>. </para><para>To declare an integer variable named <literal>x</literal>, you simply type: </para><programlisting language="java">
int x;</programlisting><para>Note that <literal>x</literal> is an arbitrary name for the variable. In general, you should use names that indicate what the variables mean. </para><programlisting language="java">
String firstName;
String lastName;
int hour, minute;</programlisting><para>This example declares two variables with type <literal>String</literal> and two with type <literal>int</literal>. The last line shows how to declare multiple variables with the same type: <literal>hour</literal> and <literal>minute</literal> are both integers. Note that each declaration statement ends with a semicolon (<literal>;</literal>). </para><para><indexterm>
  <primary>case-sensitive</primary>

</indexterm>Variable names usually begin with a lowercase letter, in contrast to class names (like <literal>Hello</literal>) that start with a capital letter. When a variable name contains more than one word (like <literal>firstName</literal>), it is conventional to capitalize the first letter of each subsequent word. Variable names are case-sensitive, so <literal>firstName</literal> is not the same as <literal>firstname</literal> or <literal>FirstName</literal>. </para><para><indexterm>
  <primary>keyword</primary>

</indexterm>You can use any name you want for a variable. But there are about 50 reserved words, called <emphasis role="bold">keywords</emphasis>, that you are not allowed to use as variable names. These words include <literal>public</literal>, <literal>class</literal>, <literal>static</literal>, <literal>void</literal>, and <literal>int</literal>, which are used by the compiler to analyze the structure of the program. </para><para>You can see the full list of keywords at <ulink url="https://thinkjava.org/keywords"></ulink>, but you don’t have to memorize them. Most programming editors provide “syntax highlighting”, which makes different parts of the program appear in different colors. And the compiler will complain even if one does sneak past you and your editor. </para>
</sect1><sect1 id="a0000000838" remap="section">
  <title>Assigning Variables</title>
    <para><indexterm>
  <primary>assignment</primary>

</indexterm><indexterm>
  <primary>= assignment operator</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>assignment</secondary>
</indexterm>Now that we have declared some variables, we can use them to store values. We do that with an <emphasis role="bold">assignment</emphasis> statement. </para><programlisting language="java">
message = "Hello!";  // give message the value "Hello!"
hour = 11;           // assign the value 11 to hour
minute = 59;         // set minute to 59</programlisting><para>This example shows three assignments, and the comments illustrate different ways people sometimes talk about assignment statements. The vocabulary can be confusing here, but the idea is straightforward: </para><itemizedlist>
  
    <listitem><para>When you declare a variable, you create a named storage location. </para></listitem>
  
    <listitem><para>When you make an assignment to a variable, you update its value. </para></listitem>
  
</itemizedlist><para>As a general rule, a variable has to have the same type as the value you assign to it. For example, you cannot store a string in <literal>minute</literal> or an integer in <literal>message</literal>. We will see some examples that seem to break this rule, but we’ll get to that later. </para><para>A common source of confusion is that some strings <emphasis>look</emphasis> like integers, but they are not. For example, <literal>message</literal> can contain the string <literal>"123"</literal>, which is made up of the characters <literal>’1’</literal>, <literal>’2’</literal>, and <literal>’3’</literal>. But that is not the same thing as the integer <literal>123</literal>. </para><programlisting language="java">
message = "123";     // legal
message = 123;       // not legal</programlisting><para><indexterm>
  <primary>initialize</primary>

</indexterm>Variables must be <emphasis role="bold">initialized</emphasis> (assigned for the first time) before they can be used. You can declare a variable and then assign a value later, as in the previous example. You can also declare and initialize on the same line: </para><programlisting language="java">
String message = "Hello!";
int hour = 11;
int minute = 59;</programlisting></sect1><sect1 id="state" remap="section">
  <title>Memory Diagrams</title><para>Because Java uses the <literal>=</literal> symbol for assignment, it is tempting to interpret the statement <literal>a = b</literal> as a statement of equality. It is not! </para><para>Equality is commutative, and assignment is not. For example, in mathematics if <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>7</mml:mn></mml:mrow></mml:math></inlineequation> then <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>7</mml:mn><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></inlineequation>. In Java <literal>a = 7;</literal> is a legal assignment statement, but <literal>7 = a;</literal> is not. The left side of an assignment statement has to be a variable name (storage location). </para><para>Also, in mathematics, a statement of equality is true for all time. If <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inlineequation> now, <emphasis role="math">a</emphasis> is always equal to <emphasis role="math">b</emphasis>. In Java, an assignment statement can make two variables equal, but they don’t have to stay that way. </para><programlisting language="java">
int a = 5;
int b = a;     // a and b are now equal
a = 3;         // a and b are no longer equal</programlisting><para>The third line changes the value of <literal>a</literal>, but it does not change the value of <literal>b</literal>, so they are no longer equal. </para><para><indexterm>
  <primary>state</primary>

</indexterm>Taken together, the variables in a program and their current values make up the program’s <emphasis role="bold">state</emphasis>. <xref linkend="fig.state" /> shows the state of the program after these assignment statements run. </para>
  
  <figure id="fig.state" float="False">
    <title>Memory diagram of the variables <literal>a</literal> and <literal>b</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/state.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>Diagrams like this one that show the state of the program are called <emphasis role="bold">memory diagrams</emphasis>. Each variable is represented with a box showing the name of the variable on the outside and its current value inside. </para><para>As the program runs, the state of memory changes, so memory diagrams only show a particular point in time. For example, if we added the line <literal>int c = 0;</literal> to the previous example, the memory diagram would look like <xref linkend="fig.state2" />. </para>
  
  <figure id="fig.state2" float="False">
    <title>Memory diagram of the variables <literal>a</literal>, <literal>b</literal>, and <literal>c</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/state2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

</sect1><sect1 id="sec..printvar" remap="section">
  <title>Printing Variables</title><para>You can display the current value of a variable using <literal>print</literal> or <literal>println</literal>. The following statements declare a variable named <literal>firstLine</literal>, assign it the value <literal>"Hello, again!"</literal>, and display that value. </para><programlisting language="java">
String firstLine = "Hello, again!";
System.out.println(firstLine);</programlisting><para>When we talk about displaying a variable, we generally mean the <emphasis>value</emphasis> of the variable. To display the <emphasis>name</emphasis> of a variable, you have to put it in quotes. </para><programlisting language="java">
System.out.print("The value of firstLine is ");
System.out.println(firstLine);</programlisting><para>For this example, the output is: </para><programlisting>The value of firstLine is Hello, again!</programlisting><para>Conveniently, the code for displaying a variable is the same regardless of its type. For example: </para><programlisting language="java">
int hour = 11;
int minute = 59;
System.out.print("The current time is ");
System.out.print(hour);
System.out.print(":");
System.out.print(minute);
System.out.println(".");</programlisting><para>The output of this program is: </para><programlisting>The current time is 11:59.</programlisting><para>To output multiple values on the same line, it’s common to use several <literal>print</literal> statements followed by <literal>println</literal> at the end. But don’t forget the <literal>println</literal>! On many computers, the output from <literal>print</literal> is stored without being displayed until <literal>println</literal> is run; then the entire line is displayed at once. If you omit the <literal>println</literal>, the program might display the stored output at unexpected times or even terminate without displaying anything. </para>
</sect1><sect1 id="a0000000984" remap="section">
  <title>Arithmetic Operators</title>
    <para><indexterm>
  <primary>operator</primary>

</indexterm><indexterm>
  <primary>addition</primary>
<secondary>integer</secondary>
</indexterm><emphasis role="bold">Operators</emphasis> are symbols that represent simple computations. For example, the addition operator is <literal>+</literal>, subtraction is <literal>-</literal>, multiplication is <literal>*</literal>, and division is <literal>/</literal>. </para><para>The following program converts a time of day to minutes: </para><programlisting language="java">
int hour = 11;
int minute = 59;
System.out.print("Number of minutes since midnight: ");
System.out.println(hour * 60 + minute);</programlisting><para>The output is: </para><programlisting>Number of minutes since midnight: 719</programlisting><para><indexterm>
  <primary>expression</primary>

</indexterm><indexterm>
  <primary>operand</primary>

</indexterm>In this program, <literal>hour * 60 + minute</literal> is an <emphasis role="bold">expression</emphasis>, which represents a single value to be computed (<literal>719</literal>). When the program runs, each variable is replaced by its current value, and then the operators are applied. The values that operators work with are called <emphasis role="bold">operands</emphasis>. </para><para>Expressions are generally a combination of numbers, variables, and operators. When compiled and executed, they become a single value. For example, the expression <literal>1 + 1</literal> has the value <literal>2</literal>. In the expression <literal>hour - 1</literal>, Java replaces the variable with its value, yielding <literal>11 - 1</literal>, which has the value <literal>10</literal>. </para><para>In the expression <literal>hour * 60 + minute</literal>, both variables get replaced, yielding <literal>11 * 60 + 59</literal>. The multiplication happens first, yielding <literal>660 + 59</literal>. Then the addition yields <literal>719</literal>. </para><para>Addition, subtraction, and multiplication all do what you expect, but you might be surprised by division. For example, the following fragment tries to compute the fraction of an hour that has elapsed:</para><programlisting language="java">
System.out.print("Fraction of the hour that has passed: ");
System.out.println(minute / 60);</programlisting><para>The output is: </para><programlisting>Fraction of the hour that has passed: 0</programlisting><para><indexterm>
  <primary>division</primary>
<secondary>integer</secondary>
</indexterm><indexterm>
  <primary>integer division</primary>

</indexterm>This result often confuses people. The value of <literal>minute</literal> is 59, and 59 divided by 60 should be 0.98333, not 0. The problem is that Java performs “integer division” when the operands are integers. By design, integer division always rounds toward zero, even in cases like this one where the next integer is close. </para><para>As an alternative, we can calculate a percentage rather than a fraction: </para><programlisting language="java">
System.out.print("Percent of the hour that has passed: ");
System.out.println(minute * 100 / 60);</programlisting><para>The new output is: </para><programlisting>Percent of the hour that has passed: 98</programlisting><para>Again the result is rounded down, but at least now it’s approximately correct. </para>
</sect1><sect1 id="a0000001050" remap="section">
  <title>Floating-Point Numbers</title>
    <para><indexterm>
  <primary>floating-point</primary>

</indexterm><indexterm>
  <primary>double</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>double</secondary>
</indexterm>A more general solution is to use <emphasis role="bold">floating-point</emphasis> numbers, which represent values with decimal places. In Java, the default floating-point type is called <literal>double</literal>, which is short for double-precision. You can create <literal>double</literal> variables and assign values to them the same way we did for the other types: </para><programlisting language="java">
double pi;
pi = 3.14159;</programlisting><para>Java performs “floating-point division” when one or more operands are <literal>double</literal> values. So we can solve the problem we saw in the previous section: </para><programlisting language="java">
double minute = 59.0;
System.out.print("Fraction of the hour that has passed: ");
System.out.println(minute / 60.0);</programlisting><para>The output is: </para><programlisting>Fraction of the hour that has passed: 0.9833333333333333</programlisting><para>Although floating-point numbers are useful, they can be a source of confusion. For example, Java distinguishes the integer value <literal>1</literal> from the floating-point value <literal>1.0</literal>, even though they seem to be the same number. They belong to different data types, and strictly speaking, you are not allowed to make assignments between types. </para><para>The following is illegal because the variable on the left is an <literal>int</literal> and the value on the right is a <literal>double</literal>: </para><programlisting language="java">
int x = 1.1;  // compiler error</programlisting><para><indexterm>
  <primary>automatic conversion</primary>

</indexterm>It is easy to forget this rule, because in many cases Java <emphasis>automatically</emphasis> converts from one type to another: </para><programlisting language="java">
double y = 1;  // legal, but bad style</programlisting><para>The preceding example should be illegal, but Java allows it by converting the <literal>int</literal> value <literal>1</literal> to the <literal>double</literal> value <literal>1.0</literal> automatically. This leniency is convenient, but it often causes problems for beginners. For example: </para><programlisting language="java">
double y = 1 / 3;  // common mistake</programlisting><para><indexterm>
  <primary>division</primary>
<secondary>integer</secondary>
</indexterm><indexterm>
  <primary>integer division</primary>

</indexterm>You might expect the variable <literal>y</literal> to get the value <literal>0.333333</literal>, which is a legal floating-point value. But instead it gets the value <literal>0.0</literal>. The expression on the right divides two integers, so Java does integer division, which yields the <literal>int</literal> value <literal>0</literal>. Converted to <literal>double</literal>, the value assigned to <literal>y</literal> is <literal>0.0</literal>. </para><para>One way to solve this problem (once you figure out the bug) is to make the right-hand side a floating-point expression. The following sets <literal>y</literal> to <literal>0.333333</literal>, as expected: </para><programlisting language="java">
double y = 1.0 / 3.0;  // correct</programlisting><para>As a matter of style, you should always assign floating-point values to floating-point variables. The compiler won’t make you do it, but you never know when a simple mistake will come back and haunt you. </para>
</sect1><sect1 id="rounderr" remap="section">
  <title>Rounding Errors</title><para>Most floating-point numbers are only <emphasis>approximately</emphasis> correct. Some numbers, like reasonably-sized integers, can be represented exactly. But repeating fractions, like <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inlineequation>, and irrational numbers, like <emphasis role="math">π</emphasis>, cannot. To represent these numbers, computers have to round off to the nearest floating-point number. </para><para><indexterm>
  <primary>rounding error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>rounding</secondary>
</indexterm>The difference between the number we want and the floating-point number we get is called <emphasis role="bold">rounding error</emphasis>. For example, the following two statements should be equivalent: </para><programlisting language="java">
System.out.println(0.1 * 10);
System.out.println(0.1 + 0.1 + 0.1 + 0.1 + 0.1
                 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);</programlisting><para>But on many machines, the output is: </para><programlisting>1.0
0.9999999999999999</programlisting><para>The problem is that <literal>0.1</literal> is a repeating fraction when converted into binary. So its floating-point representation stored in memory is only approximate. When we add up the approximations, the rounding errors accumulate. </para><para>For many applications, like computer graphics, encryption, statistical analysis, and multimedia rendering, floating-point arithmetic has benefits that outweigh the costs. But if you need <emphasis>absolute</emphasis> precision, use integers instead. For example, consider a bank account with a balance of $123.45: </para><programlisting language="java">
double balance = 123.45;  // potential rounding error</programlisting><para>In this example, balances will become inaccurate over time as the variable is used in arithmetic operations like deposits and withdrawals. The result would be angry customers and potential lawsuits. You can avoid the problem by representing the balance as an integer: </para><programlisting language="java">
int balance = 12345;      // total number of cents</programlisting><para><indexterm>
  <primary>type</primary>
<secondary>long</secondary>
</indexterm>This solution works as long as the number of cents doesn’t exceed the largest <literal>int</literal>, which is about 2 billion. </para>
</sect1><sect1 id="a0000001157" remap="section">
  <title>Operators for Strings</title>
    <para><indexterm>
  <primary>string</primary>
<secondary>operator</secondary>
</indexterm><indexterm>
  <primary>operator</primary>
<secondary>string</secondary>
</indexterm>In general, you cannot perform mathematical operations on strings, even if the strings look like numbers. The following expressions are illegal: </para><programlisting language="java">
"Hello" - 1     "World" / 123     "Hello" * "World"</programlisting><para><indexterm>
  <primary>concatenate</primary>

</indexterm><indexterm>
  <primary>addition</primary>
<secondary>string</secondary>
</indexterm>The <literal>+</literal> operator works with strings, but it might not do what you expect. For strings, the <literal>+</literal> operator performs <emphasis role="bold">concatenation</emphasis>, which means joining end-to-end. So <literal>"Hello, " + "World!"</literal> yields the string <literal>"Hello, World!"</literal>. </para><para>Likewise if you have a variable called <literal>name</literal> that has type <literal>String</literal>, the expression <literal>"Hello, " + name</literal> appends the value of <literal>name</literal> to the hello string, which creates a personalized greeting. </para><para>Since addition is defined for both numbers and strings, Java performs automatic conversions you may not expect: </para><programlisting language="java">
System.out.println(1 + 2 + "Hello");
// the output is 3Hello

System.out.println("Hello" + 1 + 2);
// the output is Hello12</programlisting><para>Java executes these operations from left to right. In the first line, <literal>1 + 2</literal> is <literal>3</literal>, and <literal>3 + "Hello"</literal> is <literal>"3Hello"</literal>. But in the second line, <literal>"Hello" + 1</literal> is <literal>"Hello1"</literal>, and <literal>"Hello1" + 2</literal> is <literal>"Hello12"</literal>. </para><para><indexterm>
  <primary>order of operations</primary>

</indexterm><indexterm>
  <primary>precedence</primary>

</indexterm>When more than one operator appears in an expression, they are evaluated according to the <emphasis role="bold">order of operations</emphasis>. Generally speaking, Java evaluates operators from left to right (as we saw in the previous section). But for numeric operators, Java follows mathematical conventions: </para><itemizedlist>
  
    <listitem><para>Multiplication and division take “precedence” over addition and subtraction, which means they happen first. So <literal>1 + 2 * 3</literal> yields 7, not 9, and <literal>2 + 4 / 2</literal> yields 4, not 3. </para></listitem>
  
    <listitem><para><indexterm>
  <primary>parentheses</primary>

</indexterm><indexterm>
  <primary>( ) parentheses</primary>

</indexterm>If the operators have the same precedence, they are evaluated from left to right. So in the expression <literal>minute * 100 / 60</literal>, the multiplication happens first; if the value of <literal>minute</literal> is 59, we get <literal>5900 / 60</literal>, which yields <literal>98</literal>. If these same operations had gone from right to left, the result would have been <literal>59 * 1</literal>, which is incorrect. </para></listitem>
  
    <listitem><para>Any time you want to override the order of operations (or you are not sure what it is) you can use parentheses. Expressions in parentheses are evaluated first, so <literal>(1 + 2) * 3</literal> is 9. You can also use parentheses to make an expression easier to read, as in <literal>(minute * 100) / 60</literal>, even though it doesn’t change the result. </para></listitem>
  
</itemizedlist><para>See the official Java tutorials for a complete table of operator precedence: <ulink url="https://thinkjava.org/operators"></ulink>. If the order of operations is not obvious when looking at an expression, you can always add parentheses to make it more clear. But over time, you should internalize these kinds of details about the Java language. </para>
</sect1><sect1 id="a0000001236" remap="section">
  <title>Compiler Error Messages</title>
    <para><indexterm>
  <primary>error</primary>
<secondary>message</secondary>
</indexterm>Three kinds of errors can occur in a program: compile-time errors, run-time errors, and logic errors. It is useful to distinguish among them in order to track them down more quickly. </para><para><indexterm>
  <primary>compile-time error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>compile-time</secondary>
</indexterm><emphasis role="bold">Compile-time</emphasis> errors occur when you violate the rules of the Java language. For example, parentheses and braces have to come in matching pairs. So <literal>(1 + 2)</literal> is legal, but <literal>8)</literal> is not. In the latter case, the program cannot be compiled, and the compiler displays a “syntax error”. </para><para><indexterm>
  <primary>error</primary>
<secondary>message</secondary>
</indexterm>Error messages from the compiler usually indicate where in the program the error occurred. Sometimes they can tell you exactly what the error is. As an example, let’s get back to the hello world program from <xref linkend="hello" />. </para><programlisting language="java">
public class Hello {

    public static void main(String[] args) {
        // generate some simple output
        System.out.println("Hello, World!");
    }
}</programlisting><para><indexterm>
  <primary>semicolon</primary>

</indexterm><indexterm>
  <primary>; semicolon</primary>

</indexterm>If you forget the semicolon at the end of the print statement, you might get an error message like this: </para><programlisting>File: Hello.java  [line: 5]
Error: ';' expected</programlisting><para>That’s pretty good: the location of the error is correct, and the error message tells you what’s wrong. But error messages are not always easy to understand. Sometimes the compiler reports the place in the program where the error was <emphasis>detected</emphasis>, not where it actually occurred. And sometimes the description of the problem is more confusing than helpful. </para><para>For example, if you forget the closing brace at the end of <literal>main</literal> (line 6), you might get a message like this: </para><programlisting>File: Hello.java  [line: 7]
Error: reached end of file while parsing</programlisting><para><indexterm>
  <primary>parse</primary>

</indexterm>There are two problems here. First, the error message is written from the compiler’s point of view, not yours. <emphasis role="bold">Parsing</emphasis> is the process of reading a program before translating; if the compiler gets to the end of the file while still parsing, that means something was omitted. But the compiler doesn’t know what. It also doesn’t know where. The compiler discovers the error at the end of the program (line 7), but the missing brace should be on the previous line. </para><para>Error messages contain useful information, so you should make an effort to read and understand them. But don’t take them too literally. During the first few weeks of your programming career, you will probably spend a lot of time tracking down syntax and other compile-time errors. As you gain experience, you will make fewer mistakes and find them more quickly. </para>
</sect1><sect1 id="exception" remap="section">
  <title>Other Types of Errors</title><para><indexterm>
  <primary>run-time error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>run-time</secondary>
</indexterm><indexterm>
  <primary>exception</primary>

</indexterm>The second type of error is a <emphasis role="bold">run-time error</emphasis>, so-called because it does not appear until after the program has started running. In Java, these errors occur while the interpreter is executing byte code and something goes wrong. These errors are also called “exceptions” because they usually indicate that something unexpected has happened. </para><para>Run-time errors are rare in the simple programs you will see in the first few chapters, so it might be a while before you encounter one. When a run-time error occurs, the program “crashes” (terminates) and displays an error message that explains what happened and where. For example, if you accidentally divide by zero you will get a message like: </para><para><programlisting>Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Hello.main(Hello.java:5)</programlisting></para><para><indexterm>
  <primary>ArithmeticException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>Arithmetic</secondary>
</indexterm>Error messages are very useful for debugging. The first line includes the name of the exception, <literal>ArithmeticException</literal>, and a message that indicates more specifically what happened, division by zero. The next line shows the method where the error occurred; <literal>Hello.main</literal> indicates the method <literal>main</literal> in the class <literal>Hello</literal>. It also reports the file where the method is defined, <literal>Hello.java</literal>, and the line number where the error occurred, <literal>5</literal>. </para><para><indexterm>
  <primary>logic error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>logic</secondary>
</indexterm>The third type of error is a <emphasis role="bold">logic error</emphasis>. If your program has a logic error, it will compile and run without generating error messages, but it will not do the right thing. Instead, it will do exactly what you told it to do. For example, here is a version of the hello world program with a logic error: </para><programlisting language="java">
public class Hello {

    public static void main(String[] args) {
        System.out.println("Hello, ");
        System.out.println("World!");
    }
}</programlisting><para>This program compiles and runs just fine, but the output is: </para><programlisting>Hello,
World!</programlisting><para>Assuming that we wanted the output on one line, this is not correct. The problem is that the first line uses <literal>println</literal>, when we probably meant to use <literal>print</literal> (see the “goodbye world” example of <xref linkend="goodbye" />). </para><para>Identifying logic errors can be hard because you have to work backwards, looking at the output of the program, trying to figure out why it is doing the wrong thing, and how to make it do the right thing. Usually the compiler and the interpreter can’t help you, since they don’t know what the right thing is. </para>
</sect1><sect1 id="a0000001311" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>variable:</term>
      <listitem><para><indexterm>
  <primary>variable</primary>

</indexterm>A named storage location for values. All variables have a type, which is declared when the variable is created. </para></listitem>
  </varlistentry><varlistentry>
    <term>value:</term>
      <listitem><para><indexterm>
  <primary>value</primary>

</indexterm>A number, string, or other data that can be stored in a variable. Every value belongs to a type (for example, <literal>int</literal> or <literal>String</literal>). </para></listitem>
  </varlistentry><varlistentry>
    <term>type:</term>
      <listitem><para><indexterm>
  <primary>type</primary>

</indexterm>Mathematically speaking, a set of values. The type of a variable determines which values it can have. </para></listitem>
  </varlistentry><varlistentry>
    <term>declaration:</term>
      <listitem><para><indexterm>
  <primary>declaration</primary>

</indexterm>A statement that creates a new variable and specifies its type. </para></listitem>
  </varlistentry><varlistentry>
    <term>keyword:</term>
      <listitem><para><indexterm>
  <primary>keyword</primary>

</indexterm>A reserved word used by the compiler to analyze programs. You cannot use keywords (like <literal>public</literal>, <literal>class</literal>, and <literal>void</literal>) as variable names. </para></listitem>
  </varlistentry><varlistentry>
    <term>assignment:</term>
      <listitem><para><indexterm>
  <primary>assignment</primary>

</indexterm>A statement that gives a value to a variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>initialize:</term>
      <listitem><para><indexterm>
  <primary>initialize</primary>

</indexterm>To assign a variable for the first time. </para></listitem>
  </varlistentry><varlistentry>
    <term>state:</term>
      <listitem><para><indexterm>
  <primary>state</primary>

</indexterm>The variables in a program and their current values. </para></listitem>
  </varlistentry><varlistentry>
    <term>memory diagram:</term>
      <listitem><para><indexterm>
  <primary>memory diagram</primary>

</indexterm>A graphical representation of the state of a program at a point in time. </para></listitem>
  </varlistentry><varlistentry>
    <term>operator:</term>
      <listitem><para><indexterm>
  <primary>operator</primary>

</indexterm>A symbol that represents a computation like addition, multiplication, or string concatenation. </para></listitem>
  </varlistentry><varlistentry>
    <term>operand:</term>
      <listitem><para><indexterm>
  <primary>operand</primary>

</indexterm>One of the values on which an operator operates. Most operators in Java require two operands. </para></listitem>
  </varlistentry><varlistentry>
    <term>expression:</term>
      <listitem><para><indexterm>
  <primary>expression</primary>

</indexterm>A combination of variables, operators, and values that represents a single value. Expressions also have types, as determined by their operators and operands. </para></listitem>
  </varlistentry><varlistentry>
    <term>floating-point:</term>
      <listitem><para><indexterm>
  <primary>floating-point</primary>

</indexterm>A data type that represents numbers with an integer part and a fractional part. In Java, the default floating-point type is <literal>double</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>rounding error:</term>
      <listitem><para><indexterm>
  <primary>rounding error</primary>

</indexterm>The difference between the number we want to represent and the nearest floating-point number. </para></listitem>
  </varlistentry><varlistentry>
    <term>concatenate:</term>
      <listitem><para><indexterm>
  <primary>concatenate</primary>

</indexterm>To join two values, often strings, end-to-end. </para></listitem>
  </varlistentry><varlistentry>
    <term>order of operations:</term>
      <listitem><para><indexterm>
  <primary>order of operations</primary>

</indexterm>The rules that determine in what order expressions are evaluated. Also known as “operator precedence”. </para></listitem>
  </varlistentry><varlistentry>
    <term>compile-time error:</term>
      <listitem><para><indexterm>
  <primary>compile-time error</primary>

</indexterm>An error in the source code that makes it impossible to compile. Also called a “syntax error”. </para></listitem>
  </varlistentry><varlistentry>
    <term>parse:</term>
      <listitem><para><indexterm>
  <primary>parse</primary>

</indexterm>To analyze the structure of a program; what the compiler does first. </para></listitem>
  </varlistentry><varlistentry>
    <term>run-time error:</term>
      <listitem><para><indexterm>
  <primary>run-time error</primary>

</indexterm>An error in a program that makes it impossible to run to completion. Also called an “exception”. </para></listitem>
  </varlistentry><varlistentry>
    <term>logic error:</term>
      <listitem><para><indexterm>
  <primary>logic error</primary>

</indexterm>An error in a program that makes it do something other than what the programmer intended. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000001366" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch02</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="interactions" />, now might be a good time. It describes the DrJava Interactions Pane, which is a useful way to develop and test short fragments of code without writing a complete class definition. </para><para><example id="a0000001378" role="exercise">
  <title></title>
  <para>If you are using this book in a class, you might enjoy this exercise. Find a partner and play “Stump the Chump”: </para><para>Start with a program that compiles and runs correctly. One player looks away while the other player adds an error to the program. Then the first player tries to find and fix the error. You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don’t find it. </para>
</example> </para><para><example id="ex..date" role="exercise">
  <title></title><para>The point of this exercise is (1) to use string concatenation to display values with different types (<literal>int</literal> and <literal>String</literal>), and (2) to practice developing programs gradually by adding a few statements at a time. </para><orderedlist>
  
  <listitem><para>Create a new program named <literal>Date.java</literal>. Copy or type in something like the hello world program and make sure you can compile and run it. </para></listitem>
  
  <listitem><para>Following the example in <xref linkend="sec..printvar" />, write a program that creates variables named <literal>day</literal>, <literal>date</literal>, <literal>month</literal>, and <literal>year</literal>. The variable <literal>day</literal> will contain the day of the week (like Friday), and <literal>date</literal> will contain the day of the month (like the 13th). Assign values to those variables that represent today’s date. </para></listitem>
  
  <listitem><para>Display the value of each variable on a line by itself. This is an intermediate step that is useful for checking that everything is working so far. Compile and run your program before moving on. </para></listitem>
  
  <listitem><para>Modify the program so that it displays the date in standard American format, for example: <literal>Thursday, July 16, 2015</literal>. </para></listitem>
  
  <listitem><para>Modify the program so it also displays the date in European format. The final output should be: </para><programlisting>American format:
Thursday, July 16, 2015
European format:
Thursday 16 July 2015</programlisting></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000001422" role="exercise">
  <title></title>
  <para>The point of this exercise is to (1) use some of the arithmetic operators, and (2) start thinking about compound entities (like time of day) that are represented with multiple values. </para><orderedlist>
  
  <listitem><para>Create a new program called <literal>Time.java</literal>. From now on, we won’t remind you to start with a small, working program, but you should. </para></listitem>
  
  <listitem><para>Following the example program in <xref linkend="sec..printvar" />, create variables named <literal>hour</literal>, <literal>minute</literal>, and <literal>second</literal>. Assign values that are roughly the current time. Use a 24-hour clock so that at 2pm the value of <literal>hour</literal> is 14. </para></listitem>
  
  <listitem><para>Make the program calculate and display the number of seconds since midnight. </para></listitem>
  
  <listitem><para>Calculate and display the number of seconds remaining in the day. </para></listitem>
  
  <listitem><para>Calculate and display the percentage of the day that has passed. You might run into problems when computing percentages with integers, so consider using floating-point. </para></listitem>
  
  <listitem><para>Change the values of <literal>hour</literal>, <literal>minute</literal>, and <literal>second</literal> to reflect the current time. Then write code to compute the elapsed time since you started working on this exercise. </para></listitem>
  
</orderedlist><para><emphasis>Hint:</emphasis> You might want to use additional variables to hold values during the computation. Variables that are used in a computation but never displayed are sometimes called “intermediate” or “temporary” variables. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000001459">
  <title>Input and Output</title>
  <para>The programs we’ve looked at so far simply display messages, which doesn’t really involve that much computation. This chapter will show you how to read input from the keyboard, use that input to calculate a result, and then format that result for output. </para><sect1 id="a0000001461" remap="section">
  <title>The System Class</title>
    <para><indexterm>
  <primary>class</primary>
<secondary>System</secondary>
</indexterm>We have been using <literal>System.out.println</literal> for a while, but you might not have thought about what it means. <literal>System</literal> is a class that provides methods related to the “system” or environment where programs run. It also provides <literal>System.out</literal>, which is a special value that has additional methods (like <literal>println</literal>) for displaying output. </para><para><indexterm>
  <primary>System.out</primary>

</indexterm>In fact, we can use <literal>System.out.println</literal> to display the value of <literal>System.out</literal>: </para><programlisting language="java">
System.out.println(System.out);</programlisting><para>The result is: </para><programlisting>java.io.PrintStream@685d72cd</programlisting><para><indexterm>
  <primary>package</primary>

</indexterm><indexterm>
  <primary>java.io</primary>

</indexterm>This output indicates that <literal>System.out</literal> is a <literal>PrintStream</literal>, which is defined in a package called <literal>java.io</literal>. A <emphasis role="bold">package</emphasis> is a collection of related classes; <literal>java.io</literal> contains classes for “I/O” which stands for input and output. </para><para><indexterm>
  <primary>address</primary>

</indexterm><indexterm>
  <primary>hexadecimal</primary>

</indexterm>The numbers and letters after the <literal>@</literal> sign are the <emphasis role="bold">address</emphasis> of <literal>System.out</literal>, represented as a hexadecimal (base 16) number. The address of a value is its location in the computer’s memory, which might be different on different computers. In this example the address is <literal>685d72cd</literal>, but if you run the same code you will likely get something else. </para><para><indexterm>
  <primary>library</primary>

</indexterm>As shown in <xref linkend="fig.system" />, <literal>System</literal> is defined in a file called <literal>System.java</literal>, and <literal>PrintStream</literal> is defined in <literal>PrintStream.java</literal>. These files are part of the Java <emphasis role="bold">library</emphasis>, which is an extensive collection of classes that you can use in your programs. The source code for these classes is usually included with the compiler (see <xref linkend="src.zip" />). </para>
  
  <figure id="fig.system" float="False">
    <title><literal>System.out.println</literal> refers to the <literal>out</literal> variable of the <literal>System</literal> class, which is a <literal>PrintStream</literal> that provides a method called <literal>println</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/system.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

</sect1><sect1 id="scanner" remap="section">
  <title>The Scanner Class</title><indexterm>
  <primary>Scanner</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Scanner</secondary>
</indexterm><para><indexterm>
  <primary>System.in</primary>

</indexterm>The <literal>System</literal> class also provides the special value <literal>System.in</literal>, which is an <literal>InputStream</literal> that has methods for reading input from the keyboard. These methods are not convenient to use, but fortunately Java provides other classes that make it easy to handle common input tasks. </para><para><indexterm>
  <primary>class</primary>
<secondary>utility</secondary>
</indexterm><indexterm>
  <primary>utility class</primary>

</indexterm><indexterm>
  <primary>java.util</primary>

</indexterm>For example, <literal>Scanner</literal> is a class that provides methods for inputting words, numbers, and other data. <literal>Scanner</literal> is provided by <literal>java.util</literal>, which is a package that contains various “utility classes”. Before you can use <literal>Scanner</literal>, you have to import it like this: </para><programlisting language="java">
import java.util.Scanner;</programlisting><para><indexterm>
  <primary>import statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>import</secondary>
</indexterm>This <emphasis role="bold">import statement</emphasis> tells the compiler that when you refer to <literal>Scanner</literal>, you mean the one defined in <literal>java.util</literal>. Using an import statement is necessary because there might be another class named <literal>Scanner</literal> in another package. </para><para><indexterm>
  <primary>new</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm>Next you have to initialize the <literal>Scanner</literal>. This line declares a <literal>Scanner</literal> variable named <literal>in</literal> and creates a <literal>Scanner</literal> that reads input from <literal>System.in</literal>: </para><programlisting language="java">
Scanner in = new Scanner(System.in);</programlisting><para><indexterm>
  <primary>Echo.java</primary>

</indexterm>The <literal>Scanner</literal> class provides a method called <literal>nextLine</literal> that reads a line of input from the keyboard and returns a <literal>String</literal>. Here’s a complete example that reads two lines and repeats them back to the user: </para><programlisting language="java">
import java.util.Scanner;

public class Echo {

    public static void main(String[] args) {
        String line;
        Scanner in = new Scanner(System.in);

        System.out.print("Type something: ");
        line = in.nextLine();
        System.out.println("You said: " + line);

        System.out.print("Type something else: ");
        line = in.nextLine();
        System.out.println("You also said: " + line);
    }
}</programlisting><para>Import statements can’t be inside a class definition. By convention, they are usually at the beginning of the file. If you omit the import statement, you get a compiler error like “cannot find symbol”. That means the compiler doesn’t know where to find the definition for <literal>Scanner</literal>. </para><para><indexterm>
  <primary>java.lang</primary>

</indexterm>You might wonder why we can use the <literal>System</literal> class without importing it. <literal>System</literal> belongs to the <literal>java.lang</literal> package, which is imported automatically. According to the documentation, <literal>java.lang</literal> “provides classes that are fundamental to the design of the Java programming language.” The <literal>String</literal> class is also part of <literal>java.lang</literal>. </para>
</sect1><sect1 id="a0000001611" remap="section">
  <title>Language Elements</title>
    <para><indexterm>
  <primary>language</primary>
<secondary>elements</secondary>
</indexterm>At this point, we have seen nearly all of the organizational units that make up Java programs. <xref linkend="fig.package" /> shows how these “language elements” are related. </para>
  
  <figure id="fig.package" float="False">
    <title>Elements of the Java language, from largest to smallest.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/package.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>token</primary>

</indexterm>Java applications are typically organized into packages (like <literal>java.io</literal> and <literal>java.util</literal>) that include multiple classes (like <literal>PrintStream</literal> and <literal>Scanner</literal>). Each class defines its own methods (like <literal>println</literal> and <literal>nextLine</literal>), and each method is a sequence of statements. </para><para>Each statement performs one or more computations, depending on how many expressions it has, and each expression represents a single value to compute. For example, the assignment statement <literal>hours = minutes / 60.0;</literal> contains a single expression: <literal>minutes / 60.0</literal>. </para><para><emphasis role="bold">Tokens</emphasis> are the most basic elements of a program, including numbers, variable names, operators, keywords, parentheses, braces, and semicolons. In the previous example, the tokens are <literal>hours</literal>, <literal>=</literal>, <literal>minutes</literal>, <literal>/</literal>, <literal>60.0</literal>, and <literal>;</literal> (spaces are ignored by the compiler). </para><para>Knowing this terminology is helpful, because error messages often say things like “not a statement” or “illegal start of expression” or “unexpected token”. Comparing Java to English, statements are complete sentences, expressions are phrases, and tokens are individual words and punctuation marks. </para><para>Note there is a big difference between the Java <emphasis>language</emphasis>, which defines the elements in <xref linkend="fig.package" />, and the Java <emphasis>library</emphasis>, which provides the built-in classes that you can import. For example, the keywords <literal>public</literal> and <literal>class</literal> are part of the Java language, but the names <literal>PrintStream</literal> and <literal>Scanner</literal> are not. </para><para>The standard edition of Java comes with <emphasis>several thousand</emphasis> classes you can use, which can be both exciting and intimidating. You can browse this library at <ulink url="https://thinkjava.org/apidoc"></ulink>. Interestingly, most of the Java library is written in Java. </para>
</sect1><sect1 id="a0000001676" remap="section">
  <title>Literals and Constants</title>
    <para>Although most of the world has adopted the metric system for weights and measures, some countries are stuck with Imperial units. For example, when talking with friends in Europe about the weather, people in the United States might have to convert from Celsius to Fahrenheit and back. Or they might want to convert height in inches to centimeters. </para><para>We can write a program to help. We’ll use a <literal>Scanner</literal> to input a measurement in inches, convert to centimeters, and then display the results. The following lines declare the variables and create the <literal>Scanner</literal>: </para><programlisting language="java">
int inch;
double cm;
Scanner in = new Scanner(System.in);</programlisting><para><indexterm>
  <primary>prompt</primary>

</indexterm><indexterm>
  <primary>nextInt</primary>
<secondary>Scanner</secondary>
</indexterm>The next step is to prompt the user for the input. We’ll use <literal>print</literal> instead of <literal>println</literal> so they can enter the input on the same line as the <emphasis role="bold">prompt</emphasis>. And we’ll use the <literal>Scanner</literal> method <literal>nextInt</literal>, which reads input from the keyboard and converts it to an integer: </para><programlisting language="java">
System.out.print("How many inches? ");
inch = in.nextInt();</programlisting><para>Next we multiply the number of inches by 2.54, since that’s how many centimeters there are per inch, and display the results: </para><programlisting language="java">
cm = inch * 2.54;
System.out.print(inch + " in = ");
System.out.println(cm + " cm");</programlisting><para>This code works correctly, but it has a minor problem. If another programmer reads this code, they might wonder where 2.54 comes from. For the benefit of others (and yourself in the future), it would be better to assign this value to a variable with a meaningful name. </para><para><indexterm>
  <primary>literal</primary>

</indexterm>A value that appears in a program, like the number 2.54, is called a <emphasis role="bold">literal</emphasis>. In general, there’s nothing wrong with literals. But when numbers like 2.54 appear in an expression with no explanation, they make the code hard to read. And if the same value appears many times and could change in the future, it makes the code hard to maintain. </para><para><indexterm>
  <primary>magic number</primary>

</indexterm>Values like 2.54 are sometimes called <emphasis role="bold">magic numbers</emphasis> (with the implication that being “magic” is not a good thing). A good practice is to assign magic numbers to variables with meaningful names, like this: </para><programlisting language="java">
double cmPerInch = 2.54;
cm = inch * cmPerInch;</programlisting><para>This version is easier to read and less error-prone, but it still has a problem. Variables can vary (hence the term), but the number of centimeters in an inch does not. Once we assign a value to <literal>cmPerInch</literal>, it should never change. Java provides the keyword <literal>final</literal>, a language feature that enforces this rule. </para><programlisting language="java">
final double CM_PER_INCH = 2.54;</programlisting><para><indexterm>
  <primary>final</primary>

</indexterm><indexterm>
  <primary>constant</primary>

</indexterm>Declaring that a variable is <literal>final</literal> means that it cannot be reassigned once it has been initialized. If you try, the compiler gives an error. </para><para>Variables declared as <literal>final</literal> are called <emphasis role="bold">constants</emphasis>. By convention, names for constants are all uppercase, with the underscore character (<literal>_</literal>) between words. </para>
</sect1><sect1 id="printf" remap="section">
  <title>Formatting Output</title><para>When you output a <literal>double</literal> using <literal>print</literal> or <literal>println</literal>, it displays up to 16 decimal places: </para><programlisting language="java">
System.out.print(4.0 / 3.0);</programlisting><para>The result is: </para><programlisting>1.3333333333333333</programlisting><para><indexterm>
  <primary>printf</primary>

</indexterm>That might be more than you want. <literal>System.out</literal> provides another method, called <literal>printf</literal>, that gives you more control of the format. The “f” in <literal>printf</literal> stands for “formatted”. Here’s an example: </para><programlisting language="java">
System.out.printf("Four thirds = %.3f", 4.0 / 3.0);</programlisting><para><indexterm>
  <primary>format string</primary>

</indexterm><indexterm>
  <primary>format specifier</primary>

</indexterm>The first value in the parentheses is a <emphasis role="bold">format string</emphasis> that specifies how the output should be displayed. This format string contains ordinary text followed by a <emphasis role="bold">format specifier</emphasis>, which is a special sequence that starts with a percent sign. The format specifier <literal>%.3f</literal> indicates that the following value should be displayed as floating-point, rounded to three decimal places. The result is: </para><programlisting>Four thirds = 1.333</programlisting><para>The format string can contain any number of format specifiers; here’s an example with two of them: </para><programlisting language="java">
int inch = 100;
double cm = inch * CM_PER_INCH;
System.out.printf("%d in = %f cm\n", inch, cm);</programlisting><para>The result is: </para><programlisting>100 in = 254.000000 cm</programlisting><para>Like <literal>print</literal>, <literal>printf</literal> does not append a newline. So format strings often end with a newline character. </para><para>The format specifier <literal>%d</literal> displays integer values (“d” stands for “decimal”, meaning base 10 integer). The values are matched up with the format specifiers in order, so <literal>inch</literal> is displayed using <literal>%d</literal>, and <literal>cm</literal> is displayed using <literal>%f</literal>. </para><para><indexterm>
  <primary>hexadecimal</primary>

</indexterm>Learning about format strings is like learning a sub-language within Java. There are many options, and the details can be overwhelming. <xref linkend="tab..format" /> lists a few common uses, to give you an idea of how things work. </para>
   
     <table id="tab..format" remap="tabular">
     <title>Example format specifiers</title>
     <tgroup>
     
     <tbody>
     <row>
     
       
       <entry> </entry>
     
       
       <entry><para> <literal>%d</literal> </para><para> integer in base 10 (“decimal”) </para><para> <literal>12345</literal> </para><para><literal>%,d</literal> </para><para> integer with comma separators </para><para> <literal>12,345</literal> </para><para><literal>%08d</literal> </para><para> padded with zeros, at least 8 digits wide </para><para> <literal>00012345</literal> </para><para><literal>%f</literal> </para><para> floating-point number </para><para> <literal>6.789000</literal> </para><para><literal>%.2f</literal> </para><para> rounded to 2 decimal places </para><para> <literal>6.79</literal> </para><para><literal>%s</literal> </para><para> string of characters </para><para> <literal>"Hello"</literal> </para><para><literal>%x</literal> </para><para> integer in base 16 (“hexadecimal”) </para><para> <literal>bc614e</literal> </para></entry>
     
       
       <entry> </entry>
     
       
       <entry>Example format specifiers</entry>
     
       
       <entry> </entry>
     
       
       <entry></entry>
     
       
       <entry> </entry>
     
     </row>
     </tbody>
     </tgroup>
     </table>
   
   
<para>For more details, refer to the documentation of <literal>java.util.Formatter</literal>. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>
</sect1><sect1 id="a0000001895" remap="section">
  <title>Reading Error Messages</title>
    <para>Notice that the values you pass to <literal>printf</literal> are separated by commas. If you are used to using the <literal>+</literal> operator to concatenate strings, you might write something like this by accident: </para><programlisting language="java">
System.out.printf("inches = %d" + inch);  // error</programlisting><para><indexterm>
  <primary>MissingFormatArgumentException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>MissingFormatArgument</secondary>
</indexterm>This line of code is legal, so the compiler won’t catch the mistake. Instead, when you run the program, it causes an exception: </para><para><programlisting>Exception in thread "main" java.util.MissingFormatArgumentException:
Format specifier '%d'
    at java.util.Formatter.format(Formatter.java:2519)
    at java.io.PrintStream.format(PrintStream.java:970)
    at java.io.PrintStream.printf(PrintStream.java:871)
    at Example.main(Example.java:10)</programlisting></para><para>As we saw in <xref linkend="exception" />, the error message includes the name of the exception, <literal>MissingFormatArgumentException</literal>, followed by additional details, <literal remap="verb">Format specifier '%d'</literal>. That means it doesn’t know what value to substitute for <literal>%d</literal>. </para><para>The problem is that concatenation happens first, before <literal>printf</literal> executes. If the value of <literal>inch</literal> is <literal>100</literal>, the result of concatenation is <literal remap="verb">"inches = %d100"</literal>. So <literal>printf</literal> gets the format string, but it doesn’t get any values to format. </para><para><indexterm>
  <primary>stack trace</primary>

</indexterm>The error message also includes a <emphasis role="bold">stack trace</emphasis> that shows the method that was running when the error was detected, <literal>java.util.Formatter.format</literal>, the method that ran it, <literal>java.io.PrintStream.format</literal>, the method that ran <emphasis>that</emphasis>, <literal>java.io.PrintStream.printf</literal>, and finally the method you actually wrote, <literal>Example.main</literal>. </para><para>Each line also names the source file of the method and the line it was on (e.g., <literal>Example.java:10</literal>). That’s a lot of information, and it includes method names and files names you have no reason to know at this point. But don’t be overwhelmed. </para><para>When you see an error message like this, read the first line carefully to see <emphasis>what</emphasis> happened. Then read the last line to see <emphasis>where</emphasis> it happened. In some IDEs, you can click on the error message and it will take you to the line of code that was running. But remember that where the error is discovered is not always where it was caused. </para>
</sect1><sect1 id="a0000001949" remap="section">
  <title>Type Cast Operators</title>
    <para>Now suppose we have a measurement in centimeters, and we want to round it off to the nearest inch. It is tempting to write: </para><programlisting language="java">
inch = cm / CM_PER_INCH;  // syntax error</programlisting><para>But the result is an error—you get something like, “incompatible types: possible lossy conversion from double to int.” The problem is that the value on the right is floating-point, and the variable on the left is an integer. </para><para><indexterm>
  <primary>automatic conversion</primary>

</indexterm>Java converts an <literal>int</literal> to a <literal>double</literal> automatically, since no information is lost in the process. On the other hand, going from <literal>double</literal> to <literal>int</literal> would lose the decimal places. Java doesn’t perform this operation automatically in order to ensure that you are aware of the loss of the fractional part of the number. </para><para><indexterm>
  <primary>type cast</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>cast</secondary>
</indexterm>The simplest way to convert a floating-point value to an integer is to use a <emphasis role="bold">type cast</emphasis>, so called because it molds or “casts” a value from one type to another. The syntax for type casting is to put the name of the type in parentheses and use it as an operator. </para><programlisting language="java">
double pi = 3.14159;
int x = (int) pi;</programlisting><para>The <literal>(int)</literal> operator has the effect of converting what follows into an integer. In this example, <literal>x</literal> gets the value <literal>3</literal>. Like integer division, casting to an integer always rounds toward zero, even if the fractional part is <literal>0.999999</literal> (or <literal>-0.999999</literal>). In other words, it simply throws away the fractional part. </para><para>In order to use a cast operator, the types must be compatible. For example, you can’t cast a <literal>String</literal> to an <literal>int</literal> because a string is not a number. </para><programlisting language="java">
String str = "3";
int x = (int) str;  // error: incompatible types</programlisting><para>Type casting takes precedence over arithmetic operations. In the following example, the value of <literal>pi</literal> gets converted to an integer before the multiplication. </para><programlisting language="java">
double pi = 3.14159;
double x = (int) pi * 20.0;  // result is 60.0, not 62.0</programlisting><para>Keeping that in mind, here’s how we can convert centimeters to inches: </para><programlisting language="java">
inch = (int) (cm / CM_PER_INCH);
System.out.printf("%f cm = %d in\n", cent, inch);</programlisting><para>The parentheses after the cast operator require the division to happen before the type cast. And the result is rounded toward zero. We will see in the next chapter how to round floating-point numbers to the closest integer. </para>
</sect1><sect1 id="a0000001997" remap="section">
  <title>Remainder Operator</title>
    <para>Let’s take the example one step further: suppose you have a measurement in inches and you want to convert to feet and inches. The goal is divide by 12 (the number of inches in a foot) and keep the remainder. </para><para><indexterm>
  <primary>modulo</primary>

</indexterm><indexterm>
  <primary>% remainder operator</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>remainder</secondary>
</indexterm><indexterm>
  <primary>remainder</primary>

</indexterm>We have already seen the division operation (<literal>/</literal>), which computes the quotient of two numbers. If the numbers are integers, it performs integer division. Java also provides the <emphasis role="bold">modulo</emphasis> operation (<literal>%</literal>), which divides two numbers and computes the remainder. </para><para>Using division and modulo, we can convert to feet and inches like this: </para><programlisting language="java">
feet = 76 / 12;    // quotient
inches = 76 % 12;  // remainder</programlisting><para>The first line yields 6. The second line, which is pronounced “76 mod 12”, yields 4. So 76 inches is 6 feet, 4 inches. </para><para><indexterm>
  <primary>modulus</primary>

</indexterm>Many people (and textbooks) incorrectly refer to <literal>%</literal> as the “modulus operator”. In mathematics, however, <emphasis role="bold">modulus</emphasis> is the number you’re dividing by. In the previous example, the modulus is 12. </para><para>The Java language specification refers to <literal>%</literal> as the “remainder operator”. The remainder operator looks like a percent sign, but you might find it helpful to think of it as a division sign (<emphasis role="math">÷</emphasis>) rotated to the left. </para><para><indexterm>
  <primary>divisible</primary>

</indexterm><indexterm>
  <primary>extract digits</primary>

</indexterm>Modular arithmetic turns out to be surprisingly useful. For example, you can check whether one number is divisible by another: if <literal>x % y</literal> is zero, then <literal>x</literal> is divisible by <literal>y</literal>. You can use remainder to “extract” digits from a number: <literal>x % 10</literal> yields the rightmost digit of <literal>x</literal>, and <literal>x % 100</literal> yields the last two digits. And many encryption algorithms use the remainder operator extensively. </para>
</sect1><sect1 id="a0000002043" remap="section">
  <title>Putting It All Together</title>
    <para><indexterm>
  <primary>Convert.java</primary>

</indexterm>At this point, you have seen enough Java to write useful programs that solve everyday problems. You can (1) import Java library classes, (2) create a <literal>Scanner</literal>, (3) get input from the keyboard, (4) format output with <literal>printf</literal>, and (5) divide and mod integers. Now we will put everything together in a complete program: </para><programlisting language="java">
import java.util.Scanner;

/**
 * Converts centimeters to feet and inches.
 */
public class Convert {

    public static void main(String[] args) {
        double cm;
        int feet, inches, remainder;
        final double CM_PER_INCH = 2.54;
        final int IN_PER_FOOT = 12;
        Scanner in = new Scanner(System.in);

        // prompt the user and get the value
        System.out.print("Exactly how many cm? ");
        cm = in.nextDouble();

        // convert and output the result
        inches = (int) (cm / CM_PER_INCH);
        feet = inches / IN_PER_FOOT;
        remainder = inches % IN_PER_FOOT;
        System.out.printf("%.2f cm = %d ft, %d in\n",
                          cm, feet, remainder);
    }
}</programlisting><para>Although not required, all variables and constants are declared at the top of <literal>main</literal>. This practice makes it easier to find their types later on, and it helps the reader know what data is involved in the algorithm. </para><para><indexterm>
  <primary>documentation</primary>

</indexterm>For readability, each major step of the algorithm is separated by a blank line and begins with a comment. The class also includes a documentation comment (<literal>/**</literal>), which you can learn more about in <xref linkend="javadoc" />. </para><para>Many algorithms, including the <literal>Convert</literal> program, perform division and modulo together. In both steps, you divide by the same number (<literal>IN_PER_FOOT</literal>). </para><para>When statements including <literal>System.out.printf</literal> get long (generally wider than 80 characters), a common style convention is to break them across multiple lines. The reader should never have to scroll horizontally. </para>
</sect1><sect1 id="a0000002069" remap="section">
  <title>The Scanner Bug</title>
    <para>Now that you’ve had some experience with <literal>Scanner</literal>, there is an unexpected behavior we want to warn you about. The following code fragment asks users for their name and age: </para><programlisting language="java">
System.out.print("What is your name? ");
name = in.nextLine();
System.out.print("What is your age? ");
age = in.nextInt();
System.out.printf("Hello %s, age %d\n", name, age);</programlisting><para>The output might look something like this: </para><programlisting>Hello Grace Hopper, age 45</programlisting><para>When you read a <literal>String</literal> followed by an <literal>int</literal>, everything works just fine. But when you read an <literal>int</literal> followed by a <literal>String</literal>, something strange happens. </para><programlisting language="java">
System.out.print("What is your age? ");
age = in.nextInt();
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);</programlisting><para>Try running this example code. It doesn’t let you input your name, and it immediately displays the output: </para><programlisting>What is your name? Hello , age 45</programlisting><para>To understand what is happening, you need to realize that <literal>Scanner</literal> doesn’t see input as multiple lines like we do. Instead, it gets a “stream of characters” as shown in <xref linkend="fig.hopper1" />. </para>
  
  <figure id="fig.hopper1" float="False">
    <title>A stream of characters as seen by a <literal>Scanner</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/hopper1.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The arrow indicates the next character to be read by <literal>Scanner</literal>. When you run <literal>nextInt</literal>, it reads characters until it gets to a non-digit. <xref linkend="fig.hopper2" /> shows the state of the stream after <literal>nextInt</literal> runs. </para>
  
  <figure id="fig.hopper2" float="False">
    <title>A stream of characters after <literal>nextInt</literal> runs.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/hopper2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>At this point, <literal>nextInt</literal> returns <literal>45</literal>. The program then displays the prompt <literal>"What is your name? "</literal> and runs <literal>nextLine</literal>, which reads characters until it gets to a newline. But since the next character is already a newline, <literal>nextLine</literal> returns the empty string <literal>""</literal>. </para><para>To solve this problem, you need an extra <literal>nextLine</literal> after <literal>nextInt</literal>. </para><programlisting language="java">
System.out.print("What is your age? ");
age = in.nextInt();
in.nextLine();  // read the newline
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);</programlisting><para>This technique is common when reading <literal>int</literal> or <literal>double</literal> values that appear on their own line. First you read the number, and then you read the rest of the line, which is just a newline character. </para>
</sect1><sect1 id="a0000002147" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>package:</term>
      <listitem><para><indexterm>
  <primary>package</primary>

</indexterm>A directory of classes that are related to each other. </para></listitem>
  </varlistentry><varlistentry>
    <term>address:</term>
      <listitem><para><indexterm>
  <primary>address</primary>

</indexterm>The location of a value in computer memory, often represented as a hexadecimal integer. </para></listitem>
  </varlistentry><varlistentry>
    <term>library:</term>
      <listitem><para><indexterm>
  <primary>library</primary>

</indexterm>A collection of packages and classes that are available for use in other programs. </para></listitem>
  </varlistentry><varlistentry>
    <term>import statement:</term>
      <listitem><para><indexterm>
  <primary>import statement</primary>

</indexterm>A statement that allows programs to use classes defined in other packages. </para></listitem>
  </varlistentry><varlistentry>
    <term>token:</term>
      <listitem><para><indexterm>
  <primary>token</primary>

</indexterm>The smallest unit of source code, such as an individual word, literal value, or symbol. </para></listitem>
  </varlistentry><varlistentry>
    <term>literal:</term>
      <listitem><para><indexterm>
  <primary>literal</primary>

</indexterm>A value that appears in source code. For example, <literal>"Hello"</literal> is a string literal, and <literal>74</literal> is an integer literal. </para></listitem>
  </varlistentry><varlistentry>
    <term>prompt:</term>
      <listitem><para><indexterm>
  <primary>prompt</primary>

</indexterm>A brief message displayed in a print statement that asks the user for input. </para></listitem>
  </varlistentry><varlistentry>
    <term>magic number:</term>
      <listitem><para><indexterm>
  <primary>magic number</primary>

</indexterm>A number that appears without explanation as part of an expression. It should generally be replaced with a constant. </para></listitem>
  </varlistentry><varlistentry>
    <term>constant:</term>
      <listitem><para><indexterm>
  <primary>constant</primary>

</indexterm>A variable, declared as <literal>final</literal>, whose value cannot be changed. </para></listitem>
  </varlistentry><varlistentry>
    <term>format string:</term>
      <listitem><para><indexterm>
  <primary>format string</primary>

</indexterm>The string in <literal>System.out.printf</literal> that specifies the format of the output. </para></listitem>
  </varlistentry><varlistentry>
    <term>format specifier:</term>
      <listitem><para><indexterm>
  <primary>format specifier</primary>

</indexterm>A special code that begins with a percent sign and specifies the data type and format of the corresponding value. </para></listitem>
  </varlistentry><varlistentry>
    <term>stack trace:</term>
      <listitem><para><indexterm>
  <primary>stack trace</primary>

</indexterm>An error message that shows the methods that were running when an exception occurs. </para></listitem>
  </varlistentry><varlistentry>
    <term>type cast:</term>
      <listitem><para><indexterm>
  <primary>type cast</primary>

</indexterm>An operation that explicitly converts one data type into another. In Java it appears as a type name in parentheses, like <literal>(int)</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>modulo:</term>
      <listitem><para><indexterm>
  <primary>modulo</primary>

</indexterm>An operation that yields the remainder when one integer is divided by another. In Java, it is denoted with a percent sign: <literal>5 % 2</literal> is <literal>1</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>modulus:</term>
      <listitem><para><indexterm>
  <primary>modulus</primary>

</indexterm>The value of <literal>b</literal> in the expression <literal>a % b</literal>. It often represents unit conversions, such as 24 hours in a day, 60 minutes in an hour, etc. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000002200" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch03</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="commandline" />, now might be a good time. It describes the command-line interface, which is a powerful and efficient way to interact with your computer. </para><para><example id="a0000002212" role="exercise">
  <title></title>
  <para>When you use <literal>printf</literal>, the Java compiler does not check your format string. See what happens if you try to display a value with type <literal>int</literal> using <literal>%f</literal>. And what happens if you display a <literal>double</literal> using <literal>%d</literal>? What if you use two format specifiers, but then only provide one value? </para>
</example> </para><para><example id="a0000002227" role="exercise">
  <title></title>
  <para>Write a program that converts a temperature from Celsius to Fahrenheit. It should (1) prompt the user for input, (2) read a <literal>double</literal> value from the keyboard, (3) calculate the result, and (4) format the output to one decimal place. </para><para>When it’s finished, it should work like this: </para><programlisting>Enter a temperature in Celsius: 24
24.0 C = 75.2 F</programlisting><para>Here is the formula to do the conversion: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mo>×</mml:mo><mml:mfrac><mml:mn>9</mml:mn><mml:mn>5</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:math></informalequation><para> HINT: Be careful not to use integer division! </para>
</example> </para><para><example id="a0000002241" role="exercise">
  <title></title>
  <para>Write a program that converts a total number of seconds to hours, minutes, and seconds. It should (1) prompt the user for input, (2) read an integer from the keyboard, (3) calculate the result, and (4) use <literal>printf</literal> to display the output. For example, <literal>"5000 seconds = 1 hours, 23 minutes, and 20 seconds"</literal>. </para><para><emphasis>Hint:</emphasis> Use the remainder operator. </para>
</example> </para><para><example id="guess" role="exercise">
  <title></title><para>The goal of this exercise is to program a “Guess My Number” game. When it’s finished, it should work like this: </para><programlisting>I'm thinking of a number between 1 and 100
(including both). Can you guess what it is?
Type a number: 45
Your guess is: 45
The number I was thinking of is: 14
You were off by: 31</programlisting><para><indexterm>
  <primary>GuessStarter.java</primary>

</indexterm>To choose a random number, you can use the <literal>Random</literal> class in <literal>java.util</literal>. Here’s how it works: </para><programlisting language="java">
import java.util.Random;

public class GuessStarter {

    public static void main(String[] args) {
        // pick a random number
        Random random = new Random();
        int number = random.nextInt(100) + 1;
        System.out.println(number);
    }
}</programlisting><para><indexterm>
  <primary>new</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm>Like the <literal>Scanner</literal> class we saw in this chapter, <literal>Random</literal> has to be imported before we can use it. And as we saw with <literal>Scanner</literal>, we have to use the <literal>new</literal> operator to create a <literal>Random</literal> (number generator). </para><para>Then we can use the method <literal>nextInt</literal> to generate a random number. In this example, the result of <literal>nextInt(100)</literal> will be between 0 and 99, including both. Adding 1 yields a number between 1 and 100, including both. </para><orderedlist>
  
  <listitem><para>The definition of <literal>GuessStarter</literal> is in a file called <literal>GuessStarter.java</literal>, in the directory called <literal>ch03</literal>, in the repository for this book. </para></listitem>
  
  <listitem><para>Compile and run this program. </para></listitem>
  
  <listitem><para>Modify the program to prompt the user, then use a <literal>Scanner</literal> to read a line of user input. Compile and test the program. </para></listitem>
  
  <listitem><para>Read the user input as an integer and display the result. Again, compile and test. </para></listitem>
  
  <listitem><para>Compute and display the difference between the user’s guess and the number that was generated. </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</chapter><chapter id="a0000002301">
  <title>Methods and Testing</title>
  <para>So far we’ve written programs that have only one method named <literal>main</literal>. In this chapter, we’ll show you how to organize programs into multiple methods. We’ll also take a look at the <literal>Math</literal> class, which provides methods for common mathematical operations. Finally, we’ll discuss strategies for incrementally developing and testing your code. </para><sect1 id="adding_methods" remap="section">
  <title>Defining New Methods</title><para>Some methods perform a computation and return a result. For example, <literal>nextDouble</literal> reads input from the keyboard and returns it as a <literal>double</literal>. Other methods, like <literal>println</literal>, carry out a sequence of actions without returning a result. Java uses the keyword <literal>void</literal> to define such methods. </para><programlisting language="java">
public static void newLine() {
    System.out.println();
}

public static void main(String[] args) {
    System.out.println("First line.");
    newLine();
    System.out.println("Second line.");
}</programlisting><para><indexterm>
  <primary>public</primary>

</indexterm><indexterm>
  <primary>invoke</primary>

</indexterm><indexterm>
  <primary>void</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>void</secondary>
</indexterm>In this example, the <literal>newLine</literal> and <literal>main</literal> methods are both <literal>public</literal>, which means they can be <emphasis role="bold">invoked</emphasis> (or “called”) from other classes. And they are both <literal>void</literal>, which means that they don’t return a result (in contrast to <literal>nextDouble</literal>). The output of the program is: </para><programlisting>First line.

Second line.</programlisting><para><indexterm>
  <primary>NewLine.java</primary>

</indexterm>Notice the extra space between the lines. If we wanted more space between them, we could invoke the same method repeatedly. Or we could write yet another method (named <literal>threeLine</literal>) that displays three blank lines. </para><programlisting language="java">
public class NewLine {

    public static void newLine() {
        System.out.println();
    }

    public static void threeLine() {
        newLine();
        newLine();
        newLine();
    }

    public static void main(String[] args) {
        System.out.println("First line.");
        threeLine();
        System.out.println("Second line.");
    }
}</programlisting><para><indexterm>
  <primary>main</primary>

</indexterm><indexterm>
  <primary>case-sensitive</primary>

</indexterm>In this example, the name of the class is <literal>NewLine</literal>. By convention, class names begin with a capital letter. <literal>NewLine</literal> contains three methods, <literal>newLine</literal>, <literal>threeLine</literal>, and <literal>main</literal>. Remember that Java is case-sensitive, so <literal>NewLine</literal> and <literal>newLine</literal> are not the same. </para><para><indexterm>
  <primary>camel case</primary>

</indexterm>By convention, method names begin with a lowercase letter and use “camel case”, which is a cute name for <literal>jammingWordsTogetherLikeThis</literal>. You can use any name you want for methods, except <literal>main</literal> or any of the Java keywords. </para>
</sect1><sect1 id="a0000002364" remap="section">
  <title>Flow of Execution</title>
    <para><indexterm>
  <primary>flow of execution</primary>

</indexterm>When you look at a class definition that contains several methods, it is tempting to read it from top to bottom. But that is <emphasis>not</emphasis> the <emphasis role="bold">flow of execution</emphasis>, or the order the program actually runs. The <literal>NewLine</literal> program runs methods in the opposite order than they are listed. </para><para>Programs always begin at the first statement of <literal>main</literal>, regardless of where it is in the source file. Statements are executed one at a time, in order, until you reach a method invocation, which you can think of as a detour. Instead of going to the next statement, you jump to the first line of the invoked method, execute all the statements there, and then come back and pick up exactly where you left off. </para><para>That sounds simple enough, but remember that one method can invoke another one. In the middle of <literal>main</literal>, the previous example goes off to execute the statements in <literal>threeLine</literal>. While in <literal>threeLine</literal>, it goes off to execute <literal>newLine</literal>. Then <literal>newLine</literal> invokes <literal>println</literal>, which causes yet another detour. </para><para>Fortunately, Java is good at keeping track of which methods are running. So when <literal>println</literal> completes, it picks up where it left off in <literal>newLine</literal>; when <literal>newLine</literal> completes, it goes back to <literal>threeLine</literal>; and when <literal>threeLine</literal> completes, it gets back to <literal>main</literal>. </para><para>Beginners often wonder why it’s worth the trouble to write other methods, when they could just do everything in <literal>main</literal>. The <literal>NewLine</literal> example demonstrates a few reasons: </para><itemizedlist>
  
    <listitem><para>Creating a new method allows you to <emphasis>name a block of statements</emphasis>, which makes the code easier to read and understand. </para></listitem>
  
    <listitem><para>Introducing new methods can <emphasis>make the program shorter</emphasis> by eliminating repetitive code. For example, to display nine consecutive newlines, you could invoke <literal>threeLine</literal> three times. </para></listitem>
  
    <listitem><para>A common problem-solving technique is to <emphasis>break problems down</emphasis> into sub-problems. Methods allow you to focus on each sub-problem in isolation, and then compose them into a complete solution. </para></listitem>
  
</itemizedlist><para>Perhaps most importantly, organizing your code into multiple methods allows you to test individual parts of your program separately. It’s easier to get a complex program working if you know that each method works correctly. </para>
</sect1><sect1 id="a0000002424" remap="section">
  <title>Parameters and Arguments</title>
    <para>Some of the methods we have used require <emphasis role="bold">arguments</emphasis>, which are the values you provide in parentheses when you invoke the method. </para><para>For example, the <literal>println</literal> method takes a <literal>String</literal> argument. To display a message, you have to provide the message: <literal>System.out.println("Hello")</literal>. Similarly, the <literal>printf</literal> method can take multiple arguments. The statement <literal>System.out.printf("%d in = %f cmn", inch, cm)</literal> has three arguments: the format string, the <literal>inch</literal> value, and the <literal>cm</literal> value. </para><para><indexterm>
  <primary>PrintTwice.java</primary>

</indexterm><indexterm>
  <primary>parameter</primary>

</indexterm><indexterm>
  <primary>argument</primary>

</indexterm>When you invoke a method, you provide the arguments. When you define a method, you name the <emphasis role="bold">parameters</emphasis>, which are variables that indicate what arguments are required. The following class shows an example: </para><programlisting language="java">
public class PrintTwice {

    public static void printTwice(String s) {
        System.out.println(s);
        System.out.println(s);
    }

    public static void main(String[] args) {
        printTwice("Don't make me say this twice!");
    }
}</programlisting><para>The <literal>printTwice</literal> method has a parameter named <literal>s</literal> with type <literal>String</literal>. When you invoke <literal>printTwice</literal>, you have to provide an argument with type <literal>String</literal>. </para><para>Before the method executes, the argument gets assigned to the parameter. In the <literal>printTwice</literal> example, the argument <literal>"Don’t make me say this twice!"</literal> gets assigned to the parameter <literal>s</literal>. </para><para><indexterm>
  <primary>parameter passing</primary>

</indexterm>This process is called <emphasis role="bold">parameter passing</emphasis>, because the value gets passed from outside the method to the inside. An argument can be any kind of expression, so if you have a <literal>String</literal> variable, you can use its value as an argument: </para><programlisting language="java">
String message = "Never say never.";
printTwice(message);</programlisting><para>The value you provide as an argument must have the same (or compatible) type as the parameter. For example, if you try: </para><programlisting language="java">
printTwice(17);  // syntax error</programlisting><para>You will get an error message like this: </para><programlisting>File: Test.java  [line: 10]
Error: method printTwice in class Test cannot be applied
       to given types;
  required: java.lang.String
  found: int
  reason: actual argument int cannot be converted to
          java.lang.String by method invocation conversion</programlisting><para>This error message says that it found an <literal>int</literal> argument, but the required parameter should be a <literal>String</literal>. In the case of <literal>printTwice</literal>, Java won’t convert the integer <literal>17</literal> to the string <literal>"17"</literal> automatically. </para><para><indexterm>
  <primary>automatic conversion</primary>

</indexterm>Sometimes Java can convert an argument from one type to another automatically. For example, <literal>Math.sqrt</literal> requires a <literal>double</literal>, but if you invoke <literal>Math.sqrt(25)</literal>, the integer value <literal>25</literal> is automatically converted to the floating-point value <literal>25.0</literal>. </para><para><indexterm>
  <primary>local variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>local</secondary>
</indexterm>Parameters and other variables only exist inside their own methods. In the <literal>printTwice</literal> example, there is no such thing as <literal>s</literal> in the <literal>main</literal> method. If you try to use it there, you’ll get a compiler error. </para><para>Similarly, inside <literal>printTwice</literal> there is no such thing as <literal>message</literal>. That variable belongs to <literal>main</literal>. Because variables only exist inside the methods where they are defined, they are often called <emphasis role="bold">local variables</emphasis>. </para>
</sect1><sect1 id="multparam" remap="section">
  <title>Multiple Parameters</title><para><indexterm>
  <primary>parameter</primary>
<secondary>multiple</secondary>
</indexterm><indexterm>
  <primary>method</primary>
<secondary>parameters</secondary>
</indexterm>Here is an example of a method that takes two parameters: </para><programlisting language="java">
public static void printTime(int hour, int minute) {
    System.out.print(hour);
    System.out.print(":");
    System.out.println(minute);
}</programlisting><para>To invoke this method, we have to provide two integers as arguments: </para><programlisting language="java">
int hour = 11;
int minute = 59;
printTime(hour, minute);</programlisting><para>Beginners sometimes make the mistake of “declaring” the arguments: </para><programlisting language="java">
int hour = 11;
int minute = 59;
printTime(int hour, int minute);  // syntax error</programlisting><para>That’s a syntax error, because the compiler sees <literal>int hour</literal> and <literal>int minute</literal> as variable declarations, not expressions that represent values. You wouldn’t declare the types of the arguments if they were simply integers: </para><programlisting language="java">
printTime(int 11, int 59);  // syntax error</programlisting><para><indexterm>
  <primary>PrintTime.java</primary>

</indexterm>Pulling together the code fragments, here is the complete program: </para><programlisting language="java">
public class PrintTime {

    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }

    public static void main(String[] args) {
        int hour = 11;
        int minute = 59;
        printTime(hour, minute);
    }
}</programlisting><para><literal>printTime</literal> has two parameters, named <literal>hour</literal> and <literal>minute</literal>. And <literal>main</literal> has two variables, also named <literal>hour</literal> and <literal>minute</literal>. Although they have the same names, these variables are <emphasis>not</emphasis> the same. The <literal>hour</literal> in <literal>printTime</literal> and the <literal>hour</literal> in <literal>main</literal> refer to different memory locations, and they can have different values. For example, you could invoke <literal>printTime</literal> like this: </para><programlisting language="java">
int hour = 11;
int minute = 59;
printTime(hour + 1, 0);</programlisting><para>Before the method is invoked, Java evaluates the arguments; in this example, the results are <literal>12</literal> and <literal>0</literal>. Then it assigns those values to the parameters. Inside <literal>printTime</literal>, the value of <literal>hour</literal> is <literal>12</literal>, not <literal>11</literal>, and the value of <literal>minute</literal> is <literal>0</literal>, not <literal>59</literal>. Furthermore, if <literal>printTime</literal> modifies one of its parameters, that change has no effect on the variables in <literal>main</literal>. </para>
</sect1><sect1 id="stack" remap="section">
  <title>Stack Diagrams</title><para><indexterm>
  <primary>stack diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>stack</secondary>
</indexterm><indexterm>
  <primary>frame</primary>

</indexterm>One way to keep track of variables is to draw a <emphasis role="bold">stack diagram</emphasis>, which is a memory diagram (see <xref linkend="state" />) that shows currently running methods. For each method there is a box, called a <emphasis role="bold">frame</emphasis>, that contains the method’s parameters and local variables. The name of the method appears outside the frame; the variables and parameters appear inside. </para>
  
  <figure id="fig.stack" float="False">
    <title>Stack diagram for <literal>printTime(hour + 1, 0)</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack1.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>As with memory diagrams, stack diagrams show variables and methods at a particular point in time. <xref linkend="fig.stack" /> is a stack diagram at the beginning of the <literal>printTime</literal> method. Notice that <literal>main</literal> is on top, because it executed first. </para><para><indexterm>
  <primary>scope</primary>

</indexterm>Stack diagrams help you to visualize the <emphasis role="bold">scope</emphasis> of a variable, which is the area of a program where a variable can be used. </para><para><indexterm>
  <primary>Java Tutor</primary>

</indexterm><indexterm>
  <primary>tracing</primary>

</indexterm>Stack diagrams are a good mental model for how variables and methods work at run-time. Learning to trace the execution of a program on paper (or on a whiteboard) is a useful skill for communicating with other programmers. </para><para>There are educational tools that automatically draw stack diagrams for you. For example, Java Tutor (<ulink url="https://thinkjava.org/javatutor"></ulink>) allows you to step through an entire program, both forwards and backwards, and see the stack frames and variables at each step. If you haven’t already, you should check out the Java examples on that website. </para>
</sect1><sect1 id="mathmeth" remap="section">
  <title>Math Methods</title><para><indexterm>
  <primary>Math class</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Math</secondary>
</indexterm>You don’t always have to write new methods to get work done. As a reminder, the Java library contains thousands of classes you can use. For example, the <literal>Math</literal> class provides common mathematical operations. </para><programlisting language="java">
double root = Math.sqrt(17.0);
double angle = 1.5;
double height = Math.sin(angle);</programlisting><para>The first line sets <literal>root</literal> to the square root of 17. The third line finds the sine of 1.5 (the value of <literal>angle</literal>). <literal>Math</literal> is in the <literal>java.lang</literal> package, so you don’t have to import it. </para><para><indexterm>
  <primary>degrees</primary>

</indexterm><indexterm>
  <primary>radians</primary>

</indexterm><indexterm>
  <primary>pi</primary>

</indexterm>Values for the trigonometric functions—<literal>sin</literal>, <literal>cos</literal>, and <literal>tan</literal>—must be in <emphasis>radians</emphasis>. To convert from degrees to radians, you can divide by 180 and multiply by <emphasis role="math">π</emphasis>. Conveniently, the <literal>Math</literal> class provides a constant named <literal>PI</literal> that contains an approximation of <emphasis role="math">π</emphasis>: </para><programlisting language="java">
double degrees = 90;
double angle = degrees / 180.0 * Math.PI;</programlisting><para>Notice that <literal>PI</literal> is in capital letters. Java does not recognize <literal>Pi</literal>, <literal>pi</literal>, or <literal>pie</literal>. Also, <literal>PI</literal> is the name of a constant, not a method, so it doesn’t have parentheses. The same is true for the constant <literal>Math.E</literal>, which approximates Euler’s number. </para><para>Converting to and from radians is a common operation, so the <literal>Math</literal> class provides methods that do that for you. </para><programlisting language="java">
double radians = Math.toRadians(180.0);
double degrees = Math.toDegrees(Math.PI);</programlisting><para><indexterm>
  <primary>long</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>long</secondary>
</indexterm>Another useful method is <literal>round</literal>, which rounds a floating-point value to the nearest integer and returns a <literal>long</literal>. The following result is 63 (rounded up from 62.8319). </para><programlisting language="java">
long x = Math.round(Math.PI * 20.0);</programlisting><para>A <literal>long</literal> is like an <literal>int</literal>, but bigger. More specifically, an <literal>int</literal> uses 32 bits of memory; the largest value it can hold is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>31</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 2 billion. A <literal>long</literal> uses 64 bits, so the largest value is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>63</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 9 quintillion. </para><para>Take a minute to read the documentation for these and other methods in the <literal>Math</literal> class. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>
</sect1><sect1 id="a0000002710" remap="section">
  <title>Composition</title>
    <para><indexterm>
  <primary>expression</primary>

</indexterm><indexterm>
  <primary>argument</primary>

</indexterm>You have probably learned how to evaluate simple expressions like <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First, you evaluate the expression in parentheses, which is the argument of the function. Then you can evaluate the function itself, either by hand or by punching it into a calculator. </para><para>This process can be applied repeatedly to evaluate more complex expressions like <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. First we evaluate the argument of the innermost function (<inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn></mml:mrow></mml:math></inlineequation>), then evaluate the function itself (<inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>57</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inlineequation>), and so on. </para><para><indexterm>
  <primary>composition</primary>

</indexterm><indexterm>
  <primary>expression</primary>

</indexterm>Just as with mathematical functions, Java methods can be <emphasis role="bold">composed</emphasis> to solve complex problems. That means you can use one method as part of another. In fact, you can use any expression as an argument to a method, as long as the resulting value has the correct type: </para><programlisting language="java">
double x = Math.cos(angle + Math.PI / 2.0);</programlisting><para>This statement divides <literal>Math.PI</literal> by two, adds the result to <literal>angle</literal>, and computes the cosine of the sum. You can also take the result of one method and pass it as an argument to another: </para><programlisting language="java">
double x = Math.exp(Math.log(10.0));</programlisting><para>In Java, the <literal>log</literal> method always uses base <emphasis role="math">e</emphasis>. So this statement finds the log base <emphasis role="math">e</emphasis> of 10, and then raises <emphasis role="math">e</emphasis> to that power. The result gets assigned to <literal>x</literal>. </para><para>Some math methods take more than one argument. For example, <literal>Math.pow</literal> takes two arguments and raises the first to the power of the second. This line computes <emphasis role="math">2<superscript>10</superscript></emphasis> and assigns the value <literal>1024.0</literal> to the variable <literal>x</literal>: </para><programlisting language="java">
double x = Math.pow(2.0, 10.0);</programlisting><para>When using <literal>Math</literal> methods, beginners often forget the word <literal>Math</literal>. For example, if you just write <literal>x = pow(2.0, 10.0)</literal>, you will get a compiler error: </para><programlisting>File: Test.java  [line: 5]
Error: cannot find symbol
  symbol:   method pow(double,double)
  location: class Test</programlisting><para>The message “cannot find symbol” is confusing, but the last two lines provide a useful hint. The compiler is looking for a method named <literal>pow</literal> in the file <literal>Test.java</literal> (the file for this example). If you don’t specify a class name when referring to a method, the compiler looks in the current class by default. </para>
</sect1><sect1 id="a0000002773" remap="section">
  <title>Return Values</title>
    <para><indexterm>
  <primary>void</primary>

</indexterm>When you invoke a <literal>void</literal> method, the invocation is usually on a line all by itself. For example: </para><programlisting language="java">
printTime(hour + 1, 0);</programlisting><para>On the other hand, when you invoke a value-returning method, you have to do something with the return value. We usually assign it to a variable or use it as part of an expression, like this: </para><programlisting language="java">
double error = Math.abs(expect - actual);
double height = radius * Math.sin(angle);</programlisting><para><indexterm>
  <primary>return type</primary>

</indexterm><indexterm>
  <primary>return value</primary>

</indexterm><indexterm>
  <primary>value method</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>value</secondary>
</indexterm>Compared to <literal>void</literal> methods, value-returning methods differ in two ways: </para><itemizedlist>
  
    <listitem><para>They declare the type of the return value (the <emphasis role="bold">return type</emphasis>); </para></listitem>
  
    <listitem><para>They use at least one <literal>return</literal> statement to provide a <emphasis role="bold">return value</emphasis>. </para></listitem>
  
</itemizedlist><para>Here’s an example from a program named <literal>Circle.java</literal>. The <literal>calculateArea</literal> method takes a <literal>double</literal> as a parameter and returns the area of a circle with that radius (i.e., <emphasis role="math">πr<superscript>2</superscript></emphasis>). </para><programlisting language="java">
public static double calculateArea(double radius) {
    double result = Math.PI * radius * radius;
    return result;
}</programlisting><para>As usual, this method is <literal>public</literal> and <literal>static</literal>. But in the place where we are used to seeing <literal>void</literal>, we see <literal>double</literal>, which means that the return value from this method is a <literal>double</literal>. </para><para><indexterm>
  <primary>return</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>The last line is a new form of the <literal>return</literal> statement that means, “return immediately from this method, and use the following expression as the return value.” The expression you provide can be arbitrarily complex, so we could have written this method more concisely: </para><programlisting language="java">
public static double calculateArea(double radius) {
    return Math.PI * radius * radius;
}</programlisting><para><indexterm>
  <primary>temporary variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>temporary</secondary>
</indexterm>On the other hand, <emphasis role="bold">temporary variables</emphasis> like <literal>result</literal> often make debugging easier, especially when you are stepping through code using an interactive debugger (see <xref linkend="debugger" />). </para><para><xref linkend="fig.param" /> illustrates how data values flows through the program. When the <literal>main</literal> method invokes <literal>calculateArea</literal>, the value <literal>5.0</literal> is assigned to the parameter <literal>radius</literal>. <literal>calculateArea</literal> then returns the value <literal>78.54</literal>, which is assigned to the variable <literal>area</literal>. </para>
  
  <figure id="fig.param" float="False">
    <title>Passing a parameter and saving the return value.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/param.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The type of the expression in the <literal>return</literal> statement must match the return type of the method itself. When you declare that the return type is <literal>double</literal>, you are making a promise that this method will eventually produce a <literal>double</literal> value. If you try to <literal>return</literal> with no expression, or <literal>return</literal> an expression with the wrong type, the compiler will give an error. </para>
</sect1><sect1 id="distance" remap="section">
  <title>Incremental Development</title><para><indexterm>
  <primary>incremental development</primary>

</indexterm><indexterm>
  <primary>design process</primary>

</indexterm>People often make the mistake of writing a lot of code before they try to compile and run it. Then they spend way too much time debugging. A better approach is what we call <emphasis role="bold">incremental development</emphasis>. The key aspects of incremental development are: </para><itemizedlist>
  
    <listitem><para>Start with a working program and make small, incremental changes. At any point, if there is an error, you will know where to look. </para></listitem>
  
    <listitem><para>Use variables to hold intermediate values so you can check them, either with print statements or by using a debugger. </para></listitem>
  
    <listitem><para>Once the program is working, you can consolidate multiple statements into compound expressions (but only if it does not make the program more difficult to read). </para></listitem>
  
</itemizedlist><para>As an example, suppose you want to find the distance between two points, given by the coordinates <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. By the usual definition: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></informalequation><para>The first step is to consider what a <literal>distance</literal> method should look like in Java. In other words, what are the inputs (parameters) and what is the output (return value)? For this method, the parameters are the two points, and it is natural to represent them using four <literal>double</literal> values. The return value is the distance, which should also have type <literal>double</literal>. </para><para><indexterm>
  <primary>stub</primary>

</indexterm>Already we can write an outline for the method, which is sometimes called a <emphasis role="bold">stub</emphasis>. The stub includes the method declaration and a <literal>return</literal> statement: </para><programlisting language="java">
public static double distance
        (double x1, double y1, double x2, double y2) {
    return 0.0;  // stub
}</programlisting><para>The return statement is a placeholder that is only necessary for the program to compile. At this stage the program doesn’t do anything useful, but it is good to compile it so we can find any syntax errors before we add more code. </para><para><indexterm>
  <primary>testing</primary>

</indexterm>It’s usually a good idea to think about testing <emphasis>before</emphasis> you develop new methods; doing so can help you figure out how to implement them. To test the method, we can invoke it from <literal>main</literal> using the sample values: </para><programlisting language="java">
double dist = distance(1.0, 2.0, 4.0, 6.0);</programlisting><para>With these values, the horizontal distance is 3.0 and the vertical distance is 4.0. So the result should be 5.0, the hypotenuse of a 3-4-5 triangle. When you are testing a method, it is necessary to know the right answer. </para><para>Once we have compiled the stub, we can start adding code one line at a time. After each incremental change, we recompile and run the program. If there is an error, we have a good idea where to look: the lines we just added. </para><para>The next step is to find the differences <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inlineequation>. We store those values in temporary variables named <literal>dx</literal> and <literal>dy</literal>, so that we can examine them with print statements before proceeding. They should be 3.0 and 4.0. </para><programlisting language="java">
public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    System.out.println("dx is " + dx);
    System.out.println("dy is " + dy);
    return 0.0;  // stub
}</programlisting><para><indexterm>
  <primary>scaffolding</primary>

</indexterm>We will remove the print statements when the method is finished. Code like that is called <emphasis role="bold">scaffolding</emphasis>, because it is helpful for building the program, but it is not part of the final product. </para><para>The next step is to square <literal>dx</literal> and <literal>dy</literal>. We could use the <literal>Math.pow</literal> method, but it is simpler (and more efficient) to multiply each term by itself. </para><para>Then we add the squares and print the result so far. </para><programlisting language="java">
public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    System.out.println("dsquared is " + dsquared);
    return 0.0;  // stub
}</programlisting><para>Again, you should compile and run the program at this stage and check the intermediate value, which should be 25.0. Finally, we can use <literal>Math.sqrt</literal> to compute and return the result. </para><programlisting language="java">
public static double distance
        (double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    double result = Math.sqrt(dsquared);
    return result;
}</programlisting><para>As you gain more experience programming, you might write and debug more than one line at a time. But if you find yourself spending a lot of time debugging, consider taking smaller steps. </para>
</sect1><sect1 id="a0000002961" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>void:</term>
      <listitem><para><indexterm>
  <primary>void</primary>

</indexterm>A special return type indicating the method does not return a value. </para></listitem>
  </varlistentry><varlistentry>
    <term>invoke:</term>
      <listitem><para><indexterm>
  <primary>invoke</primary>

</indexterm>To cause a method to execute. Also known as “calling” a method. </para></listitem>
  </varlistentry><varlistentry>
    <term>flow of execution:</term>
      <listitem><para><indexterm>
  <primary>flow of execution</primary>

</indexterm>The order in which Java executes methods and statements. It may not necessarily be from top to bottom in the source file. </para></listitem>
  </varlistentry><varlistentry>
    <term>argument:</term>
      <listitem><para><indexterm>
  <primary>argument</primary>

</indexterm>A value that you provide when you call a method. This value must have the type that the method expects. </para></listitem>
  </varlistentry><varlistentry>
    <term>parameter:</term>
      <listitem><para><indexterm>
  <primary>parameter</primary>

</indexterm>A piece of information that a method requires before it can run. Parameters are variables: they contain values and have types. </para></listitem>
  </varlistentry><varlistentry>
    <term>parameter passing:</term>
      <listitem><para><indexterm>
  <primary>parameter passing</primary>

</indexterm>The process of assigning an argument value to a parameter variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>local variable:</term>
      <listitem><para><indexterm>
  <primary>local variable</primary>

</indexterm>A variable declared inside a method. Local variables cannot be accessed from outside their method. </para></listitem>
  </varlistentry><varlistentry>
    <term>stack diagram:</term>
      <listitem><para><indexterm>
  <primary>stack diagram</primary>

</indexterm>A graphical representation of the variables belonging to each method. The method calls are “stacked” from top to bottom, in the flow of execution. </para></listitem>
  </varlistentry><varlistentry>
    <term>frame:</term>
      <listitem><para><indexterm>
  <primary>frame</primary>

</indexterm>In a stack diagram, a representation of the variables and parameters for a method, along with their current values. </para></listitem>
  </varlistentry><varlistentry>
    <term>scope:</term>
      <listitem><para><indexterm>
  <primary>scope</primary>

</indexterm>The area of a program where a variable can be used. </para></listitem>
  </varlistentry><varlistentry>
    <term>composition:</term>
      <listitem><para><indexterm>
  <primary>composition</primary>

</indexterm>The ability to combine simple expressions and statements into compound expressions and statements. </para></listitem>
  </varlistentry><varlistentry>
    <term>return type:</term>
      <listitem><para><indexterm>
  <primary>return type</primary>

</indexterm>The type of value a method returns. </para></listitem>
  </varlistentry><varlistentry>
    <term>return value:</term>
      <listitem><para><indexterm>
  <primary>return value</primary>

</indexterm>The value provided as the result of a method invocation. </para></listitem>
  </varlistentry><varlistentry>
    <term>temporary variable:</term>
      <listitem><para><indexterm>
  <primary>temporary variable</primary>

</indexterm>A short-lived variable, often used for debugging. </para></listitem>
  </varlistentry><varlistentry>
    <term>incremental development:</term>
      <listitem><para><indexterm>
  <primary>incremental development</primary>

</indexterm>A process for creating programs by writing a few lines at a time, compiling, and testing. </para></listitem>
  </varlistentry><varlistentry>
    <term>stub:</term>
      <listitem><para><indexterm>
  <primary>stub</primary>

</indexterm>A placeholder for an incomplete method so that the class will compile. </para></listitem>
  </varlistentry><varlistentry>
    <term>scaffolding:</term>
      <listitem><para><indexterm>
  <primary>scaffolding</primary>

</indexterm>Code that is used during program development but is not part of the final version. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000002998" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch04</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="cltesting" />, now might be a good time. It describes an efficient way to test programs that take input from the user and display specific output. </para><para><example id="a0000003010" role="exercise">
  <title></title>
  <para>The purpose of this exercise is to take code from a previous exercise and redesign it as a method that takes parameters. You should start with a working solution to <xref linkend="ex..date" />. </para><orderedlist>
  
  <listitem><para>Write a method called <literal>printAmerican</literal> that takes the day, date, month and year as parameters and that displays them in American format. </para></listitem>
  
  <listitem><para>Test your method by invoking it from <literal>main</literal> and passing appropriate arguments. The output should look something like this (except that the date might be different): </para><programlisting>Saturday, July 22, 2015</programlisting></listitem>
  
  <listitem><para>Once you have debugged <literal>printAmerican</literal>, write another method called <literal>printEuropean</literal> that displays the date in European format. </para></listitem>
  
</orderedlist></example> </para><para><example id="a0000003037" role="exercise">
  <title></title>
  <para>This exercise reviews the flow of execution through a program with multiple methods. Read the following code and answer the questions. </para><programlisting language="java">
public static void main(String[] args) {
    zippo("rattle", 13);
}</programlisting><programlisting language="java">
public static void baffle(String blimp) {
    System.out.println(blimp);
    zippo("ping", -5);
}</programlisting><programlisting language="java">
public static void zippo(String quince, int flag) {
    if (flag &lt; 0) {
        System.out.println(quince + " zoop");
    } else {
        System.out.println("ik");
        baffle(quince);
        System.out.println("boo-wa-ha-ha");
    }
}</programlisting><orderedlist>
  
  <listitem><para>Write the number <literal>1</literal> next to the first line of code in this program that will execute. </para></listitem>
  
  <listitem><para>Write the number <literal>2</literal> next to the second line of code, and so on until the end of the program. If a line is executed more than once, it might end up with more than one number next to it. </para></listitem>
  
  <listitem><para>What is the value of the parameter <literal>blimp</literal> when <literal>baffle</literal> gets invoked? </para></listitem>
  
  <listitem><para>What is the output of this program? </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000003064" role="exercise">
  <title></title>
  <para>Answer the following questions without running the program on a computer. </para><orderedlist>
  
  <listitem><para>Draw a stack diagram that shows the state of the program the first time <literal>ping</literal> is invoked. </para></listitem>
  
  <listitem><para>What is output by the following program? Be precise about where there are spaces and where there are newlines. </para></listitem>
  
</orderedlist><programlisting language="java">
public static void zoop() {
    baffle();
    System.out.print("You wugga ");
    baffle();
}</programlisting><programlisting language="java">
public static void main(String[] args) {
    System.out.print("No, I ");
    zoop();
    System.out.print("I ");
    baffle();
}</programlisting><programlisting language="java">
public static void baffle() {
    System.out.print("wug");
    ping();
}</programlisting><programlisting language="java">
public static void ping() {
    System.out.println(".");
}</programlisting></example> </para><para><example id="a0000003083" role="exercise">
  <title></title>
  <para>If you have a question about whether something is legal, and what happens if it is not, a good way to find out is to ask the compiler. Answer the following questions by trying them out. </para><orderedlist>
  
  <listitem><para>What happens if you invoke a value method and don’t do anything with the result; that is, if you don’t assign it to a variable or use it as part of a larger expression? </para></listitem>
  
  <listitem><para>What happens if you use a void method as part of an expression? For example, try <literal>System.out.println("boo!") + 7;</literal> </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000003094" role="exercise">
  <title></title>
  <para>Draw a stack diagram that shows the state of the program the <emphasis>second</emphasis> time <literal>zoop</literal> is invoked. What is the complete output? </para><programlisting language="java">
public static void zoop(String fred, int bob) {
    System.out.println(fred);
    if (bob == 5) {
        ping("not ");
    } else {
        System.out.println("!");
    }
}</programlisting><programlisting language="java">
public static void main(String[] args) {
    int bizz = 5;
    int buzz = 2;
    zoop("just for", bizz);
    clink(2 * buzz);
}</programlisting><programlisting language="java">
public static void clink(int fork) {
    System.out.print("It's ");
    zoop("breakfast ", fork);
}</programlisting><programlisting language="java">
public static void ping(String strangStrung) {
    System.out.println("any " + strangStrung + "more ");
}</programlisting></example> </para><para><example id="a0000003109" role="exercise">
  <title></title>
  <para>Many computations can be expressed more concisely using the “multadd” operation, which takes three operands and computes <literal>a * b + c</literal>. Some processors even provide a hardware implementation of this operation for floating-point numbers. </para><orderedlist>
  
  <listitem><para>Create a new program called <literal>Multadd.java</literal>. </para></listitem>
  
  <listitem><para>Write a method called <literal>multadd</literal> that takes three <literal>doubles</literal> as parameters and that returns <literal>a * b + c</literal>. </para></listitem>
  
  <listitem><para>Write a <literal>main</literal> method that tests <literal>multadd</literal> by invoking it with a few simple parameters, like <literal>1.0, 2.0, 3.0</literal>. </para></listitem>
  
  <listitem><para>Also in <literal>main</literal>, use <literal>multadd</literal> to compute the following values: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo form="prefix">cos</mml:mo><mml:mfrac><mml:mi>π</mml:mi><mml:mn>4</mml:mn></mml:mfrac></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:mtd><mml:mtd></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mo form="prefix">log</mml:mo><mml:mn>10</mml:mn><mml:mo>+</mml:mo><mml:mo form="prefix">log</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation></listitem>
  
  <listitem><para>Write a method called <literal>expSum</literal> that takes a double as a parameter and that uses <literal>multadd</literal> to calculate: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>x</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>-</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para> <emphasis>Hint:</emphasis> The method for raising <emphasis role="math">e</emphasis> to a power is <literal>Math.exp</literal>. </para></listitem>
  
</orderedlist><para>In the last part of this exercise, you need to write a method that invokes another method you wrote. Whenever you do that, it is a good idea to test the first method carefully before working on the second. Otherwise, you might find yourself debugging two methods at the same time, which can be difficult. </para><para>One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000003185">
  <title>Conditionals and Logic</title>
  <para><indexterm>
  <primary>boolean</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>boolean</secondary>
</indexterm>The programs we’ve seen in previous chapters do pretty much the same thing every time, regardless of the input. For more complex computations, programs usually react to inputs, check for certain conditions, and generate applicable results. This chapter introduces Java language features for expressing logic and making decisions. </para><sect1 id="a0000003188" remap="section">
  <title>Relational Operators</title>
    <para><indexterm>
  <primary>operator</primary>
<secondary>relational</secondary>
</indexterm><indexterm>
  <primary>relational operator</primary>

</indexterm><indexterm>
  <primary>comparison operator</primary>

</indexterm>Java has six <emphasis role="bold">relational operators</emphasis> that test the relationship between two values (e.g., whether they are equal, or whether one is greater than the other). The following expressions show how they are used: </para><programlisting language="java">
x == y          // x is equal to y
x != y          // x is not equal to y
x &gt; y           // x is greater than y
x &lt; y           // x is less than y
x &gt;= y          // x is greater than or equal to y
x &lt;= y          // x is less than or equal to y</programlisting><para><indexterm>
  <primary>Boole, George</primary>

</indexterm>The result of a relational operator is one of two special values: <literal>true</literal> or <literal>false</literal>. These values belong to the data type <literal>boolean</literal>, named after the mathematician George Boole. He developed an algebraic way of representing logic. </para><para><indexterm>
  <primary>assignment</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>assignment</secondary>
</indexterm><indexterm>
  <primary>== equals operator</primary>

</indexterm>You are probably familiar with these operators, but notice how Java is different from mathematical symbols like <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mo>=</mml:mo></mml:math></inlineequation>, <emphasis role="math">≠</emphasis>, and <emphasis role="math">≥</emphasis>. A common error is to use a single <literal>=</literal> instead of a double <literal>==</literal> when comparing values. Remember that <literal>=</literal> is the <emphasis>assignment</emphasis> operator, and <literal>==</literal> is a <emphasis>relational</emphasis> operator. Also, the operators <literal>=&lt;</literal> and <literal>=&gt;</literal> do not exist. </para><para><indexterm>
  <primary>automatic conversion</primary>

</indexterm>The two sides of a relational operator have to be compatible. For example, the expression <literal>5 &lt; "6"</literal> is invalid because <literal>5</literal> is an <literal>int</literal> and <literal>"6"</literal> is a <literal>String</literal>. When comparing values of different numeric types, Java applies the same conversion rules we saw previously with the assignment operator. For example, when evaluating the expression <literal>5 &lt; 6.0</literal>, Java automatically converts the <literal>5</literal> to <literal>5.0</literal>. </para>
</sect1><sect1 id="a0000003244" remap="section">
  <title>The if-else Statement</title>
    <para><indexterm>
  <primary>conditional statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>conditional</secondary>
</indexterm><indexterm>
  <primary>if statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>if</secondary>
</indexterm>To write useful programs, we almost always need to check conditions and react accordingly. <emphasis role="bold">Conditional statements</emphasis> give us this ability. The simplest conditional statement in Java is the <literal>if</literal> statement: </para><programlisting language="java">
if (x &gt; 0) {
    System.out.println("x is positive");
}</programlisting><para><indexterm>
  <primary>block</primary>

</indexterm>The expression in parentheses is called the condition. If it is true, the statements in braces get executed. If the condition is false, execution skips over that <emphasis role="bold">block</emphasis> of code. The condition in parentheses can be any <literal>boolean</literal> expression. </para><para><indexterm>
  <primary>branch</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>else</secondary>
</indexterm>A second form of conditional statement has two possibilities, indicated by <literal>if</literal> and <literal>else</literal>. The possibilities are called <emphasis role="bold">branches</emphasis>, and the condition determines which branch gets executed: </para><programlisting language="java">
if (x % 2 == 0) {
    System.out.println("x is even");
} else {
    System.out.println("x is odd");
}</programlisting><para>If the remainder when <literal>x</literal> is divided by 2 is zero, we know that <literal>x</literal> is even, and the program displays a message to that effect. If the condition is false, the second print statement is executed instead. Since the condition must be true or false, exactly one of the branches will run. </para><para>The braces are optional for branches that have only one statement. So we could have written the previous example this way: </para><programlisting language="java">
if (x % 2 == 0)
    System.out.println("x is even");
else
    System.out.println("x is odd");</programlisting><para>However, it’s better to use braces—even when they are optional—to avoid making the mistake of adding statements to an <literal>if</literal> or <literal>else</literal> block and forgetting to add the braces. This code is misleading because it’s not indented correctly: </para><programlisting language="java">
if (x &gt; 0)
    System.out.println("x is positive");
    System.out.println("x is not zero");</programlisting><para>Since there are no braces, only the first <literal>println</literal> is part of the <literal>if</literal> statement. Here is what the compiler actually sees: </para><programlisting language="java">
if (x &gt; 0) {
    System.out.println("x is positive");
}
    System.out.println("x is not zero");</programlisting><para>As a result, the second <literal>println</literal> runs no matter what. Even experienced programmers make this mistake; search the web for Apple’s “goto fail” bug. </para><para><indexterm>
  <primary>{} curly braces</primary>

</indexterm>In all previous examples, notice how there is no semicolon at the end of the <literal>if</literal> or <literal>else</literal> lines. Instead, a new block should be defined using curly braces. Another common mistake is to put a semicolon after the condition, like this: </para><programlisting language="java">
int x = 1;
if (x % 2 == 0); {  // incorrect semicolon
    System.out.println("x is even");
}</programlisting><para>This code will compile, but the program will output <literal>"x is even"</literal> regardless what value <literal>x</literal> is. Here is the same incorrect code with better formatting: </para><programlisting language="java">
int x = 1;
if (x % 2 == 0)
    ;  // empty statement
{
    System.out.println("x is even");
}</programlisting><para>Because of the semicolon, the <literal>if</literal> statement compiles as if there are no braces, and the subsequent block runs independently. As a general rule, each line of Java code should end with a semicolon or brace—but not both. </para><para>The compiler won’t complain if you omit optional braces or write empty statements. Doing so is allowed by the Java language, but it often results in bugs that are difficult to find. Development tools like Checkstyle (see <xref linkend="checkstyle" />) can warn you about these and other kinds of programming mistakes. </para>
</sect1><sect1 id="a0000003317" remap="section">
  <title>Chaining and Nesting</title>
    <para><indexterm>
  <primary>chaining</primary>

</indexterm>Sometimes you want to check related conditions and choose one of several actions. One way to do this is by <emphasis role="bold">chaining</emphasis> a series of <literal>if</literal> and <literal>else</literal> blocks: </para><programlisting language="java">
if (x &gt; 0) {
    System.out.println("x is positive");
} else if (x &lt; 0) {
    System.out.println("x is negative");
} else {
    System.out.println("x is zero");
}</programlisting><para>These chains can be as long as you want, although they can be difficult to read if they get out of hand. One way to make them easier to read is to use standard indentation, as demonstrated in these examples. If you keep all the statements and braces lined up, you are less likely to make syntax errors. </para><para>Notice that the last branch is simply <literal>else</literal>, not <literal>else if (x == 0)</literal>. At this point in the chain, we know that <literal>x</literal> is not positive and <literal>x</literal> is not negative. There is no need to test whether <literal>x</literal> is zero, because there is no other possibility. </para><para><indexterm>
  <primary>nesting</primary>

</indexterm>In addition to chaining, you can also make complex decisions by <emphasis role="bold">nesting</emphasis> one conditional statement inside another. We could have written the previous example as: </para><programlisting language="java">
if (x &gt; 0) {
    System.out.println("x is positive");
} else {
    if (x &lt; 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
}</programlisting><para>The outer conditional has two branches. The first branch contains a <literal>print</literal> statement, and the second branch contains another conditional statement, which has two branches of its own. These two branches are also <literal>print</literal> statements, but they could have been conditional statements as well. </para><para><indexterm>
  <primary>nested</primary>
<secondary>conditions</secondary>
</indexterm>These kinds of nested structures are common, but they can become difficult to read very quickly. Good indentation is essential to make the structure (or intended structure) apparent to the reader. </para>
</sect1><sect1 id="a0000003353" remap="section">
  <title>The switch Statement</title>
    <para>If you need to make a series of decisions, chaining <literal>else if</literal> blocks can get long and redundant. For example, consider a program that converts integers like <literal>1</literal>, <literal>2</literal>, and <literal>3</literal> into words like <literal>"one"</literal>, <literal>"two"</literal>, and <literal>"three"</literal>: </para><programlisting language="java">
if (number == 1) {
    word = "one";
} else if (number == 2) {
    word = "two";
} else if (number == 3) {
    word = "three";
} else {
    word = "unknown";
}</programlisting><para><indexterm>
  <primary>switch statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>switch</secondary>
</indexterm>This chain could go on and on, especially for banking programs that write numbers in long form (e.g., “one hundred twenty-three and 45/100 dollars”). An alternative way to evaluate many possible values of an expression is to use a <literal>switch</literal> statement: </para><programlisting language="java">
switch (number) {
    case 1:
        word = "one";
        break;
    case 2:
        word = "two";
        break;
    case 3:
        word = "three";
        break;
    default:
        word = "unknown";
        break;
}</programlisting><para>The body of a <literal>switch</literal> statement is organized into one or more <literal>case</literal> blocks. Each <literal>case</literal> ends with a <literal>break</literal> statement, which exits the <literal>switch</literal> body. The <literal>default</literal> block is optional and executed only if none of the cases apply. </para><para>Although <literal>switch</literal> statements appear longer than chained <literal>else if</literal> blocks, they are particularly useful when multiple cases can be grouped: </para><programlisting language="java">
switch (food) {
    case "apple":
    case "banana":
    case "cherry":
        System.out.println("Fruit!");
        break;
    case "asparagus":
    case "broccoli":
    case "carrot":
        System.out.println("Vegetable!");
        break;
}</programlisting></sect1><sect1 id="shortcircuit" remap="section">
  <title>Logical Operators</title>
    <para><indexterm>
  <primary>logical operator</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>logical</secondary>
</indexterm><indexterm>
  <primary>and operator</primary>

</indexterm><indexterm>
  <primary>or operator</primary>

</indexterm><indexterm>
  <primary>not operator</primary>

</indexterm>In addition to the relational operators, Java also has three <emphasis role="bold">logical operators</emphasis>: <literal></literal>, <literal>||</literal>, and <literal>!</literal>, which respectively stand for <emphasis>and</emphasis>, <emphasis>or</emphasis>, and <emphasis>not</emphasis>. The results of these operators are similar to their meanings in English. </para><para>For example, <literal>x &gt; 0  x &lt; 10</literal> is true when <literal>x</literal> is both greater than zero <emphasis>and</emphasis> less than 10. </para><para>The expression <literal>x &lt; 0 || x &gt; 10</literal> is true if either condition is true, that is, if <literal>x</literal> is less than 0 <emphasis>or</emphasis> greater than 10. </para><para>Finally, <literal>!(x &gt; 0)</literal> is true if <literal>x</literal> is <emphasis>not</emphasis> greater than 0. The parentheses are necessary in this example because in the order of operations <literal>!</literal> comes before <literal>&gt;</literal>. </para><para>In order for an expression with <literal></literal> to be true, both sides of the <literal></literal> operator must be true. And in order for an expression with <literal>||</literal> to be false, both sides of the <literal>||</literal> operator must be false. </para><para>The <literal></literal> operator can be used to simplify nested <literal>if</literal> statements. For example, following code can be rewritten with a single condition. </para><programlisting language="java">
if (x == 0) {
    if (y == 0) {
        System.out.println("Both x and y are zero");
    }
}</programlisting><programlisting language="java">
// combined
if (x == 0 &amp;&amp; y == 0) {
    System.out.println("Both x and y are zero");
}</programlisting><para>Likewise, the <literal>||</literal> operator can simplify chained <literal>if</literal> statements. Since the branches are the same, there is no need to duplicate that code. </para><programlisting language="java">
if (x == 0) {
    System.out.println("Either x or y is zero");
} else if (y == 0) {
    System.out.println("Either x or y is zero");
}</programlisting><programlisting language="java">
// combined
if (x == 0 || y == 0) {
    System.out.println("Either x or y is zero");
}</programlisting><para>Then again, if the statements in the branches were different, we could not combine them into one block. But it’s useful to explore different ways of representing the same logic, especially when it’s complex. </para><para><indexterm>
  <primary>short circuit</primary>

</indexterm>Logical operators evaluate the second expression only when necessary. For example, <literal>true || anything</literal> is always true, so Java does not need to evaluate the expression <literal>anything</literal>. Likewise, <literal>false  anything</literal> is always false. </para><para>Ignoring the second operand, when possible, is called <emphasis role="bold">short circuit</emphasis> evaluation, by analogy with an electrical circuit. Short circuit evaluation can save time, especially if <literal>anything</literal> takes a long time to evaluate. It can also avoid unnecessary errors, if <literal>anything</literal> might fail. </para>
</sect1><sect1 id="a0000003494" remap="section">
  <title>De Morgan’s Laws</title>
    <para>Sometimes you need to negate an expression containing a mix of relational and logical operators. For example, to test if <literal>x</literal> and <literal>y</literal> are both nonzero, you could write: </para><programlisting language="java">
if (!(x == 0 || y == 0)) {
    System.out.println("Neither x nor y is zero");
}</programlisting><para><indexterm>
  <primary>De Morgan’s laws</primary>

</indexterm>This condition is difficult to read because of the <literal>!</literal> and parentheses. A better way to negate logic expressions is to apply <emphasis role="bold">De Morgan’s laws</emphasis>: </para><itemizedlist>
  
    <listitem><para><literal>!(A  B)</literal>  is the same as  <literal>!A || !B</literal> </para></listitem>
  
    <listitem><para><literal>!(A || B)</literal>  is the same as  <literal>!A  !B</literal> </para></listitem>
  
</itemizedlist><para>In words, negating a logical expression is the same as negating each term and changing the operator. The <literal>!</literal> operator takes precedence over <literal></literal> and <literal>||</literal>, so you don’t have to put parentheses around the individual terms <literal>!A</literal> and <literal>!B</literal>. </para><para>De Morgan’s laws also apply to the relational operators. In this case, negating each term means using the “opposite” relational operator. </para><itemizedlist>
  
    <listitem><para><literal>!(x &lt; 5  y == 3)</literal>  is the same as  <literal>x &gt;= 5 || y != 3</literal> </para></listitem>
  
    <listitem><para><literal>!(x &gt;= 1 || y != 7)</literal>  is the same as  <literal>x &lt; 1  y == 7</literal> </para></listitem>
  
</itemizedlist><para>It may help to read these examples out loud in English. For instance, “If I don’t want the case where <emphasis role="math">x</emphasis> is less than 5 and <emphasis role="math">y</emphasis> is 3, then I need <emphasis role="math">x</emphasis> to be greater than or equal to 5, or I need <emphasis role="math">y</emphasis> to be anything but 3.” </para><para>Returning to the previous example, here is the revised condition. In English, it reads “if <emphasis role="math">x</emphasis> is not zero and <emphasis role="math">y</emphasis> is not zero.” The logic is the same, and the source code is easier to read. </para><programlisting language="java">
if (x != 0 &amp;&amp; y != 0) {
    System.out.println("Neither x nor y is zero");
}</programlisting></sect1><sect1 id="a0000003576" remap="section">
  <title>Boolean Variables</title>
    <para><indexterm>
  <primary>expression</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>boolean</secondary>
</indexterm>To store a <literal>true</literal> or <literal>false</literal> value, you need a <literal>boolean</literal> variable. You can declare and assign them like other variables. In this example, the first line is a variable declaration, the second is an assignment, and the third is both: </para><programlisting language="java">
boolean flag;
flag = true;
boolean testResult = false;</programlisting><para><indexterm>
  <primary>initialize</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>initialization</secondary>
</indexterm>Since relational and logical operators evaluate to a <literal>boolean</literal> value, you can store the result of a comparison in a variable: </para><programlisting language="java">
boolean evenFlag = (n % 2 == 0);    // true if n is even
boolean positiveFlag = (x &gt; 0);     // true if x is positive</programlisting><para><indexterm>
  <primary>flag</primary>

</indexterm>The parentheses are unnecessary, but they make the code easier to understand. A variable defined in this way is called a <emphasis role="bold">flag</emphasis>, because it signals or “flags” the presence or absence of a condition. </para><para>You can use flag variables as part of a conditional statement: </para><programlisting language="java">
if (evenFlag) {
    System.out.println("n was even when I checked it");
}</programlisting><para>Flags may not seem that useful at this point, but they will help simplify complex conditions later on. Each part of a condition can be stored in a separate flag, and these flags can be combined with logical operators. </para><para>Notice that we didn’t have to write  <literal>if (evenFlag == true)</literal>. Since <literal>evenFlag</literal> is a <literal>boolean</literal>, it’s already a condition. To check if a flag is <literal>false</literal>, we simply negate the flag: </para><programlisting language="java">
if (!evenFlag) {
    System.out.println("n was odd when I checked it");
}</programlisting><para>In general, you should never compare anything to true or false. Doing so makes the code more verbose and awkward to read out loud. </para>
</sect1><sect1 id="boolmeth" remap="section">
  <title>Boolean Methods</title><para><indexterm>
  <primary>boolean</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>boolean</secondary>
</indexterm>Methods can return <literal>boolean</literal> values, just like any other type, which is often convenient for hiding tests inside methods. For example: </para><programlisting language="java">
public static boolean isSingleDigit(int x) {
    if (x &gt; -10 &amp;&amp; x &lt; 10) {
        return true;
    } else {
        return false;
    }
}</programlisting><para>The name of this method is <literal>isSingleDigit</literal>. It is common to give <literal>boolean</literal> methods names that sound like yes/no questions. Since the return type is <literal>boolean</literal>, the return statement has to provide a boolean expression. </para><para>The code itself is straightforward, although it is longer than it needs to be. Remember that the expression <literal>x &gt; -10  x &lt; 10</literal> has type <literal>boolean</literal>, so there is nothing wrong with returning it directly (without the <literal>if</literal> statement): </para><programlisting language="java">
public static boolean isSingleDigit(int x) {
    return x &gt; -10 &amp;&amp; x &lt; 10;
}</programlisting><para>In <literal>main</literal>, you can invoke the method in the usual ways: </para><programlisting language="java">
System.out.println(isSingleDigit(2));
boolean bigFlag = !isSingleDigit(17);</programlisting><para>The first line displays <literal>true</literal> because 2 is a single-digit number. The second line sets <literal>bigFlag</literal> to <literal>true</literal>, because 17 is <emphasis>not</emphasis> a single-digit number. </para><para>Conditional statements often invoke <literal>boolean</literal> methods and use the result as the condition: </para><programlisting language="java">
if (isSingleDigit(z)) {
    System.out.println("z is small");
} else {
    System.out.println("z is big");
}</programlisting><para>Examples like this one almost read like English: “If is single digit z, print z is small else print z is big.” </para>
</sect1><sect1 id="validate" remap="section">
  <title>Validating Input</title><para><indexterm>
  <primary>validate</primary>

</indexterm><indexterm>
  <primary>hacker</primary>

</indexterm>One of the most important tasks in any computer program is to <emphasis role="bold">validate</emphasis> input from the user. People often make mistakes while typing, especially on smartphones, and incorrect inputs may cause your program to fail. </para><para>Even worse, someone (i.e., a <emphasis role="bold">hacker</emphasis>) may intentionally try to break into your system by entering unexpected inputs. You should never assume that users will input the right kind of data. </para><para>Consider this simple program that prompts the user for a number and computes its logarithm: </para><programlisting language="java">
Scanner in = new Scanner(System.in);
System.out.print("Enter a number: ");
double x = in.nextDouble();
double y = Math.log(x);
System.out.println("The log is " + y);</programlisting><para>In mathematics, the natural logarithm (base <emphasis role="math">e</emphasis>) is undefined when <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>≤</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inlineequation>. In Java, if you ask for <literal>Math.log(-1)</literal>, it returns <emphasis role="bold">NaN</emphasis>, which stands for “not a number”. We can check for this condition and print an appropriate message: </para><programlisting language="java">
if (x &gt; 0) {
    double y = Math.log(x);
    System.out.println("The log is " + y);
} else {
    System.out.println("The log is undefined");
}</programlisting><para><indexterm>
  <primary>InputMismatchException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>InputMismatch</secondary>
</indexterm>The output is better now, but there is another problem. What if the user doesn’t enter a number at all? What would happen if they typed the word “hello”, either on accident or on purpose? </para><para><programlisting>Exception in thread "main" java.util.InputMismatchException
    at java.util.Scanner.throwFor(Scanner.java:864)
    at java.util.Scanner.next(Scanner.java:1485)
    at java.util.Scanner.nextDouble(Scanner.java:2413)
    at Logarithm.main(Logarithm.java:8)</programlisting></para><para><indexterm>
  <primary>run-time error</primary>

</indexterm><indexterm>
  <primary>testing</primary>

</indexterm>If the user inputs a <literal>String</literal> when we expect a <literal>double</literal>, Java reports an “input mismatch” exception. We can prevent this run-time error from happening by testing the input first. </para><para>The <literal>Scanner</literal> class provides <literal>hasNextDouble</literal>, which checks whether the next input can be interpreted as a <literal>double</literal>. If not, we can display an error message. </para><programlisting language="java">
if (!in.hasNextDouble()) {
    String word = in.next();
    System.err.println(word + "is not a number");
}</programlisting><para><indexterm>
  <primary>next</primary>
<secondary>Scanner</secondary>
</indexterm>In contrast to <literal>in.nextLine</literal>, which returns an entire line of input, the <literal>in.next</literal> method returns only the next token of input. We can use <literal>in.next</literal> to show the user exactly which word they typed was not a number. </para><para><indexterm>
  <primary>System.err</primary>

</indexterm>This example also uses <literal>System.err</literal>, which is an <literal>OutputStream</literal> for error messages and warnings. Some development environments display output to <literal>System.err</literal> with a different color or in a separate window. </para>
</sect1><sect1 id="a0000003718" remap="section">
  <title>Example Program</title>
    <para><indexterm>
  <primary>Logarithm.java</primary>

</indexterm>In this chapter we have seen relational and logical operators, <literal>if</literal> statements, boolean methods, and validating input. The following program shows how the individual code examples in the previous section fit together. </para><programlisting language="java">
import java.util.Scanner;

/**
 * Demonstrates input validation using if statements.
 */
public class Logarithm {

    public static void main(String[] args) {

        // prompt for input
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");

        // check the format
        if (!in.hasNextDouble()) {
            String word = in.next();
            System.err.println(word + " is not a number");
            return;
        }

        // check the range
        double x = in.nextDouble();
        if (x &gt; 0) {
            double y = Math.log(x);
            System.out.println("The log is " + y);
        } else {
            System.out.println("The log is undefined");
        }
    }
}</programlisting><para><indexterm>
  <primary>return</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>Notice how the <literal>return</literal> statement allows you to exit a method before you reach the end of it. Returning from <literal>main</literal> terminates the program. </para><para>What started as five lines of code at the beginning of <xref linkend="validate" /> is now a 30-line program. Making programs robust (and secure) often requires a lot of additional checking, as shown in this example. </para><para><indexterm>
  <primary>comment</primary>

</indexterm>It’s important to write comments every few lines to make your code easier to understand. Comments not only help other people read your code, they also help you document what you’re trying to do. If there’s a mistake the code, it’s a lot easier to find when there are good comments. </para>
</sect1><sect1 id="a0000003736" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>boolean:</term>
      <listitem><para><indexterm>
  <primary>boolean</primary>

</indexterm>A data type with only two possible values, <literal>true</literal> and <literal>false</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>relational operator:</term>
      <listitem><para><indexterm>
  <primary>relational operator</primary>

</indexterm>An operator that compares two values and produces a <literal>boolean</literal> indicating the relationship between them. </para></listitem>
  </varlistentry><varlistentry>
    <term>conditional statement:</term>
      <listitem><para><indexterm>
  <primary>conditional statement</primary>

</indexterm>A statement that uses a condition to determine which statements to execute. </para></listitem>
  </varlistentry><varlistentry>
    <term>block:</term>
      <listitem><para><indexterm>
  <primary>block</primary>

</indexterm>A sequence of statements, surrounded by braces, that generally runs as the result of a condition. </para></listitem>
  </varlistentry><varlistentry>
    <term>branch:</term>
      <listitem><para><indexterm>
  <primary>branch</primary>

</indexterm>One of the alternative blocks after a conditional statement. For example, an <literal>if</literal>-<literal>else</literal> statement has two branches. </para></listitem>
  </varlistentry><varlistentry>
    <term>chaining:</term>
      <listitem><para><indexterm>
  <primary>chaining</primary>

</indexterm>A way of joining several conditional statements in sequence. </para></listitem>
  </varlistentry><varlistentry>
    <term>nesting:</term>
      <listitem><para><indexterm>
  <primary>nesting</primary>

</indexterm>Putting a conditional statement inside one or both branches of another conditional statement. </para></listitem>
  </varlistentry><varlistentry>
    <term>logical operator:</term>
      <listitem><para><indexterm>
  <primary>logical operator</primary>

</indexterm>An operator that combines boolean values and produces a boolean value. </para></listitem>
  </varlistentry><varlistentry>
    <term>short circuit:</term>
      <listitem><para><indexterm>
  <primary>short circuit</primary>

</indexterm>A way of evaluating logical operators that only evaluates the second operand if necessary. </para></listitem>
  </varlistentry><varlistentry>
    <term>De Morgan’s laws:</term>
      <listitem><para><indexterm>
  <primary>De Morgan’s laws</primary>

</indexterm>Mathematical rules that show how to negate a logical expression. </para></listitem>
  </varlistentry><varlistentry>
    <term>flag:</term>
      <listitem><para><indexterm>
  <primary>flag</primary>

</indexterm>A variable (usually <literal>boolean</literal>) that represents a condition or status. </para></listitem>
  </varlistentry><varlistentry>
    <term>validate:</term>
      <listitem><para><indexterm>
  <primary>validate</primary>

</indexterm>To confirm that an input value is of the correct type and within the expected range. </para></listitem>
  </varlistentry><varlistentry>
    <term>hacker:</term>
      <listitem><para><indexterm>
  <primary>hacker</primary>

</indexterm>A programmer who breaks into computer systems. The term hacker may also apply to someone who enjoys writing code. </para></listitem>
  </varlistentry><varlistentry>
    <term>NaN:</term>
      <listitem><para><indexterm>
  <primary>NaN</primary>

</indexterm>A special floating-point value that stands for “not a number”. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000003779" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch05</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="checkstyle" />, now might be a good time. It describes Checkstyle, a tool that analyzes many aspects of your source code. </para><para><example id="a0000003791" role="exercise">
  <title></title>
  <para>Rewrite the following code using a single <literal>if</literal> statement. </para><programlisting language="java">
if (x &gt; 0) {
    if (x &lt; 10) {
        System.out.println("positive single digit number.");
    }
}</programlisting></example> </para><para><example id="a0000003798" role="exercise">
  <title></title>
  <para>Now that we have conditional statements, we can get back to the “Guess My Number” game from <xref linkend="guess" />. </para><para>You should already have a program that chooses a random number, prompts the user to guess it, and displays the difference between the guess and the chosen number. </para><para>Adding a small amount of code at a time, and testing as you go, modify the program so it tells the user whether the guess is too high or too low, and then prompts the user for another guess. </para><para>The program should continue until the user gets it right or guesses incorrectly three times. If the user guesses the correct number, display a message and terminate the program. </para>
</example> </para><para><example id="a0000003806" role="exercise">
  <title></title>
  <para>Fermat’s Last Theorem says that there are no integers <emphasis role="math">a</emphasis>, <emphasis role="math">b</emphasis>, <emphasis role="math">c</emphasis>, and <emphasis role="math">n</emphasis> such that <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inlineequation>, except when <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inlineequation>. </para><para>Write a program named <literal>Fermat.java</literal> that inputs four integers (<literal>a</literal>, <literal>b</literal>, <literal>c</literal>, and <literal>n</literal>) and checks to see if Fermat’s theorem holds. If <emphasis role="math">n</emphasis> is greater than 2 and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mi>c</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inlineequation>, the program should display “Holy smokes, Fermat was wrong!” Otherwise the program should display “No, that doesn’t work.” </para><para><emphasis>Hint:</emphasis> You might want to use <literal>Math.pow</literal>. </para>
</example> </para><para><example id="a0000003840" role="exercise">
  <title></title>
  <para>Using the following variables, evaluate the logic expressions in the table below. Write your answers as true, false, or error. </para><programlisting language="java">
boolean yes = true;
boolean no = false;
int loVal = -999;
int hiVal = 999;
double grade = 87.5;
double amount = 50.0;
String hello = "world";</programlisting><informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="2">
     
     <tbody>
     <row>
     
       
       <entry><para> Expression </para></entry>
     
       
       <entry><para> Result </para></entry>
     
     </row><row>
     
       
       <entry><para><literal>yes == no || grade &gt; amount</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>amount == 40.0 || 50.0</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>hiVal != loVal || loVal &lt; 0</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>True || hello.length() &gt; 0</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>hello.isEmpty() </literal><para> yes</para> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>grade &lt;= 100 </literal><para> !false</para> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>!yes || no</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>grade &gt; 75 &gt; amount</literal> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>amount &lt;= hiVal </literal><para> amount &gt;= loVal</para> </para></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para><literal>no </literal><para> !no || yes </para><para> !yes</para> </para></entry>
     
       
       <entry></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 
</example> </para><para><example id="a0000003948" role="exercise">
  <title></title>
  <para>What is the output of the following program? Determine the answer without using a computer. </para><programlisting language="java">
public static void main(String[] args) {
    boolean flag1 = isHoopy(202);
    boolean flag2 = isFrabjuous(202);
    System.out.println(flag1);
    System.out.println(flag2);
    if (flag1 &amp;&amp; flag2) {
        System.out.println("ping!");
    }
    if (flag1 || flag2) {
        System.out.println("pong!");
    }
}</programlisting><programlisting language="java">
public static boolean isHoopy(int x) {
    boolean hoopyFlag;
    if (x % 2 == 0) {
        hoopyFlag = true;
    } else {
        hoopyFlag = false;
    }
    return hoopyFlag;
}</programlisting><programlisting language="java">
public static boolean isFrabjuous(int x) {
    boolean frabjuousFlag;
    if (x &gt; 0) {
        frabjuousFlag = true;
    } else {
        frabjuousFlag = false;
    }
    return frabjuousFlag;
}</programlisting><para>The purpose of this exercise is to make sure you understand logical operators and the flow of execution through methods. </para>
</example> </para><para><example id="a0000003958" role="exercise">
  <title></title>
  <para>Write a program named <literal>Quadratic.java</literal> that finds the roots of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inlineequation> using the quadratic formula: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>-</mml:mo><mml:mi>b</mml:mi><mml:mo>±</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>-</mml:mo><mml:mn>4</mml:mn><mml:mi>a</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>a</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></informalequation><para> Prompt the user to input integers for <emphasis role="math">a</emphasis>, <emphasis role="math">b</emphasis>, and <emphasis role="math">c</emphasis>. Compute the two solutions for <emphasis role="math">x</emphasis>, and display the results. </para><para>Your program should be able to handle inputs for which there is only one or no solution. Specifically, it should not divide by zero or take the square root of a negative number. </para><para>Be sure to validate all inputs. The user should never see an input mismatch exception. Display specific error messages that include the invalid input. </para>
</example> </para><para><example id="a0000003979" role="exercise">
  <title></title>
  <para>If you are given three sticks, you may or may not be able to arrange them in a triangle. For example, if one of the sticks is 12 inches long and the other two are one inch long, you will not be able to get the short sticks to meet in the middle. For any three lengths, there is a simple test to see if it is possible to form a triangle: </para><blockquote remap="quotation"><para> If any of the three lengths is greater than the sum of the other two, you cannot form a triangle. </para></blockquote><para>Write a program named <literal>Triangle.java</literal> that inputs three integers, and then outputs whether you can (or cannot) form a triangle from the given lengths. Reuse your code from the previous exercise to validate the inputs. Display an error if any of the lengths are negative or zero. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000003987">
  <title>Loops and Strings</title>
  <para>Computers are often used to automate repetitive tasks, such as searching for text in documents. Repeating tasks without making errors is something that computers do well and people do poorly. </para><para>In this chapter, we’ll learn how to use <literal>while</literal> and <literal>for</literal> loops to add repetition to your code. We’ll also take a first look at <literal>String</literal> methods and solve some interesting problems. </para><sect1 id="a0000003996" remap="section">
  <title>The while Statement</title>
    <para><indexterm>
  <primary>while</primary>

</indexterm><indexterm>
  <primary>loop</primary>
<secondary>while</secondary>
</indexterm><indexterm>
  <primary>statement</primary>
<secondary>while</secondary>
</indexterm>Using a <literal>while</literal> statement, we can repeat the same code multiple times: </para><programlisting language="java">
int n = 3;
while (n &gt; 0) {
    System.out.println(n);
    n = n - 1;
}
System.out.println("Blastoff!");</programlisting><para>Reading the code in English sounds like: “Start with <literal>n</literal> set to 3. While <literal>n</literal> is greater than zero, print the value of <literal>n</literal>, and reduce the value of <literal>n</literal> by 1. When you get to zero, print Blastoff!” So the output is: </para><programlisting>3
2
1
Blastoff!</programlisting><para>The flow of execution for a <literal>while</literal> statement is: </para><orderedlist>
  
  <listitem><para>Evaluate the condition in parentheses, yielding <literal>true</literal> or <literal>false</literal>. </para></listitem>
  
  <listitem><para>If the condition is <literal>false</literal>, skip the following statements in braces. </para></listitem>
  
  <listitem><para>If the condition is <literal>true</literal>, execute the statements and go back to step 1. </para></listitem>
  
</orderedlist><para><indexterm>
  <primary>loop</primary>

</indexterm>This type of flow is called a <emphasis role="bold">loop</emphasis>, because the last step “loops back around” to the first. <xref linkend="fig.while" /> shows this idea using a flowchart. </para>
  
  <figure id="fig.while" float="False">
    <title>Flow of execution for a <literal>while</literal> loop.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/while.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>loop body</primary>

</indexterm><indexterm>
  <primary>infinite loop</primary>

</indexterm><indexterm>
  <primary>loop</primary>
<secondary>infinite</secondary>
</indexterm>The <emphasis role="bold">body</emphasis> of the loop should change the value of one or more variables so that, eventually, the condition becomes <literal>false</literal> and the loop terminates. Otherwise the loop will repeat forever, which is called an <emphasis role="bold">infinite loop</emphasis>. </para><programlisting language="java">
int n = 3;
while (n &gt; 0) {
    System.out.println(n);
    // n never changes
}</programlisting><para>This example will print the number <literal>3</literal> forever, or at least until you terminate the program. An endless source of amusement for computer scientists is the observation that the directions on shampoo, “Lather, rinse, repeat,” are an infinite loop. </para><para>In the first example, we can prove that the loop terminates when <literal>n</literal> is positive. But in general, it is not so easy to tell whether a loop terminates. For example, this loop continues until <literal>n</literal> is 1 (which makes the condition <literal>false</literal>): </para><programlisting language="java">
while (n != 1) {
    System.out.println(n);
    if (n % 2 == 0) {         // n is even
        n = n / 2;
    } else {                  // n is odd
        n = 3 * n + 1;
    }
}</programlisting><para>Each time through the loop, the program displays the value of <literal>n</literal> and then checks whether it is even or odd. If it is even, the value of <literal>n</literal> is divided by two. If it is odd, the value is replaced by <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>3</mml:mn><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>. For example, if the starting value is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1. </para><para>Since <literal>n</literal> sometimes increases and sometimes decreases, there is no obvious proof that <literal>n</literal> will ever reach 1 and that the program will ever terminate. For some values of <literal>n</literal>, such as the powers of two, we can prove that it terminates. The previous example ends with such a sequence, starting when <literal>n</literal> is 16 (or <emphasis role="math">2<superscript>4</superscript></emphasis>). </para><para>The hard question is whether this program terminates for <emphasis>all</emphasis> values of n. So far, no one has been able to prove it <emphasis>or</emphasis> disprove it! For more information, see <ulink url="https://en.wikipedia.org/wiki/Collatz_conjecture"></ulink>. </para>
</sect1><sect1 id="a0000004092" remap="section">
  <title>Increment and Decrement</title>
    <para>Here is another <literal>while</literal> loop example; this one displays the numbers 1 to 5. </para><programlisting language="java">
int i = 1;
while (i &lt;= 5) {
    System.out.println(i);
    i++;  // add 1 to i
}</programlisting><para><indexterm>
  <primary>increment</primary>

</indexterm><indexterm>
  <primary>decrement</primary>

</indexterm>Assignments like <literal>i = i + 1</literal> don’t often appear in loops, because Java provides a more concise way to add and subtract by one. Specifically, <literal>++</literal> is the <emphasis role="bold">increment</emphasis> operator; it has the same effect as <literal>i = i + 1</literal>. And <literal>–</literal> is the <emphasis role="bold">decrement</emphasis> operator; it has the same effect as <literal>i = i - 1</literal>. </para><para>If you want to increment or decrement a variable by an amount other than <literal>1</literal>, you can use <literal>+=</literal> and <literal>-=</literal>. For example, <literal>i += 2</literal> increments <literal>i</literal> by <literal>2</literal>. </para><programlisting language="java">
int i = 2;
while (i &lt;= 8) {
    System.out.print(i + ", ");
    i += 2;  // add 2 to i
}
System.out.println("Who do we appreciate?");</programlisting><para>And the output is: </para><programlisting>2, 4, 6, 8, Who do we appreciate?</programlisting></sect1><sect1 id="a0000004132" remap="section">
  <title>The for Statement</title>
    <para><indexterm>
  <primary>for</primary>

</indexterm><indexterm>
  <primary>loop</primary>
<secondary>for</secondary>
</indexterm><indexterm>
  <primary>statement</primary>
<secondary>for</secondary>
</indexterm>The loops we have written so far have three parts in common. They start by initializing a variable, they have a condition that depends on that variable, and they do something inside the loop to update that variable. </para><para><indexterm>
  <primary>iteration</primary>

</indexterm>Running the same code multiple times is called <emphasis role="bold">iteration</emphasis>. It’s so common that there is another statement, the <literal>for</literal> loop, that expresses it more concisely. For example, we can rewrite the 2-4-6-8 loop this way: </para><programlisting language="java">
for (int i = 2; i &lt;= 8; i += 2) {
    System.out.print(i + ", ");
}
System.out.println("Who do we appreciate?");</programlisting><para><literal>for</literal> loops have three components in parentheses, separated by semicolons: the initializer, the condition, and the update. </para><orderedlist>
  
  <listitem><para>The <emphasis>initializer</emphasis> runs once at the very beginning of the loop. It is equivalent to the line before the <literal>while</literal> statement. </para></listitem>
  
  <listitem><para>The <emphasis>condition</emphasis> is checked each time through the loop. If it is <literal>false</literal>, the loop ends. Otherwise, the body of the loop is executed (again). </para></listitem>
  
  <listitem><para>At the end of each iteration, the <emphasis>update</emphasis> runs, and we go back to step 2. </para></listitem>
  
</orderedlist><para>The <literal>for</literal> loop is often easier to read because it puts all the loop-related statements at the top of the loop. Doing so allows you to focus on the statements inside the loop body. <xref linkend="fig.for" /> illustrates <literal>for</literal> loops with a flowchart. </para>
  
  <figure id="fig.for" float="False">
    <title>Flow of execution for a <literal>for</literal> loop.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/for.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>There is another difference between <literal>for</literal> loops and <literal>while</literal> loops: if you declare a variable in the initializer, it only exists <emphasis>inside</emphasis> the <literal>for</literal> loop. For example: </para><programlisting language="java">
for (int n = 3; n &gt; 0; n--) {
    System.out.println(n);
}
System.out.println("n is now " + n);  // compiler error</programlisting><para>The last line tries to display <literal>n</literal> (for no reason other than demonstration), but it won’t work. If you need to use a loop variable outside the loop, you have to declare it <emphasis>outside</emphasis> the loop, like this: </para><programlisting language="java">
int n;
for (n = 3; n &gt; 0; n--) {
    System.out.println(n);
}
System.out.println("n is now " + n);</programlisting><para>Notice that the <literal>for</literal> statement does not say <literal>int n = 3</literal>. Rather, it simply initializes the existing variable <literal>n</literal>. </para>
</sect1><sect1 id="nested" remap="section">
  <title>Nested Loops</title><para><indexterm>
  <primary>loop</primary>
<secondary>nested</secondary>
</indexterm><indexterm>
  <primary>nested</primary>
<secondary>loops</secondary>
</indexterm>Like conditional statements, loops can be nested one inside the other. Nested loops allow you to iterate over two variables. For example, we can generate a “multiplication table” like this: </para><programlisting language="java">
for (int x = 1; x &lt;= 10; x++) {
    for (int y = 1; y &lt;= 10; y++) {
        System.out.printf("%4d", x * y);
    }
    System.out.println();
}</programlisting><para><indexterm>
  <primary>loop variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>loop</secondary>
</indexterm><indexterm>
  <primary>inner loop</primary>

</indexterm><indexterm>
  <primary>outer loop</primary>

</indexterm>Variables like <literal>x</literal> and <literal>y</literal> are called <emphasis role="bold">loop variables</emphasis>, because they control the execution of a loop. In this example, the first loop (<literal>for x</literal>) is known as the “outer loop”, and the second loop (<literal>for y</literal>) is known as the “inner loop”. </para><para>Each loop repeats their corresponding statements 10 times. The outer loop iterates from 1 to 10 only once, but the inner loop iterates from 1 to 10 each of those 10 times. As a result, the <literal>printf</literal> method is invoked 100 times. </para><para><indexterm>
  <primary>format specifier</primary>

</indexterm>The format specifier <literal>%4d</literal> displays the value of <literal>x * y</literal> padded with spaces so it’s four characters wide. Doing so causes the output to align vertically, regardless of how many digits the numbers have: </para><programlisting>   1   2   3   4   5   6   7   8   9  10
   2   4   6   8  10  12  14  16  18  20
   3   6   9  12  15  18  21  24  27  30
   4   8  12  16  20  24  28  32  36  40
   5  10  15  20  25  30  35  40  45  50
   6  12  18  24  30  36  42  48  54  60
   7  14  21  28  35  42  49  56  63  70
   8  16  24  32  40  48  56  64  72  80
   9  18  27  36  45  54  63  72  81  90
  10  20  30  40  50  60  70  80  90 100</programlisting><para>It’s important to realize that the output is displayed row by row. The inner loop displays a single row of output, followed by a newline. The outer loop iterates over the rows themselves. Another way to read nested loops, like the ones in this example, is “for each row <literal>x</literal>, and for each column <literal>y</literal>, …” </para>
</sect1><sect1 id="a0000004241" remap="section">
  <title>Characters</title>
    <para>Some of the most interesting problems in computer science involve searching and manipulating text. In the next few sections, we’ll discuss how to apply loops to strings. Although the examples are short, the techniques work the same whether you have one word or one million words. </para><para><indexterm>
  <primary>charAt</primary>

</indexterm><indexterm>
  <primary>char</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>char</secondary>
</indexterm>Strings provide a method named <literal>charAt</literal>. It returns a <literal>char</literal>, a data type that stores an individual character (as opposed to strings of them). </para><programlisting language="java">
String fruit = "banana";
char letter = fruit.charAt(0);</programlisting><para>The argument <literal>0</literal> means that we want the character at <emphasis role="bold">index</emphasis> 0. String indexes range from 0 to <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, where <emphasis role="math">n</emphasis> is the length of the string. So the character assigned to <literal>letter</literal> is <literal>’b’</literal>. </para> 
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="6">
     
       <colspec colname="c1" />
     
       <colspec colname="c2" />
     
       <colspec colname="c3" />
     
       <colspec colname="c4" />
     
       <colspec colname="c5" />
     
       <colspec colname="c6" />
     
     <tbody>
     <row>
     
       
       <entry><para> b </para></entry>
     
       
       <entry><para> a </para></entry>
     
       
       <entry><para> n </para></entry>
     
       
       <entry><para> a </para></entry>
     
       
       <entry><para> n </para></entry>
     
       
       <entry><para> a </para></entry>
     
     </row><row>
     
       
       <entry><para>0 </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
       
       <entry><para> 2 </para></entry>
     
       
       <entry><para> 3 </para></entry>
     
       
       <entry><para> 4 </para></entry>
     
       
       <entry><para> 5 </para></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 <para>Characters work like the other data types we have seen. You can compare them using relational operators: </para><programlisting language="java">
if (letter == 'A') {
    System.out.println("It's an A!");
}</programlisting><para><indexterm>
  <primary>quote mark</primary>

</indexterm><indexterm>
  <primary>escape sequence</primary>

</indexterm>Character literals, like <literal>’A’</literal>, appear in single quotes. Unlike string literals, which appear in double quotes, character literals can only contain a single character. Escape sequences, like <literal>’t’</literal>, are legal because they represent a single character. </para><para>The increment and decrement operators also work with characters. So this loop displays the letters of the alphabet: </para><programlisting language="java">
System.out.print("Roman alphabet: ");
for (char c = 'A'; c &lt;= 'Z'; c++) {
    System.out.print(c);
}
System.out.println();</programlisting><para>The output is: </para><programlisting>ABCDEFGHIJKLMNOPQRSTUVWXYZ</programlisting><para><indexterm>
  <primary>Unicode</primary>

</indexterm>Java uses <emphasis role="bold">Unicode</emphasis> to represent characters, so strings can store text in other alphabets like Cyrillic and Greek, and non-alphabetic languages like Chinese. You can read more about it at <ulink url="https://unicode.org/"></ulink>. </para><para>In Unicode, each character is represented by a “code point”, which you can think of as an integer. The code points for uppercase Greek letters run from 913 to 937, so we can display the Greek alphabet like this: </para><programlisting language="java">
System.out.print("Greek alphabet: ");
for (int i = 913; i &lt;= 937; i++) {
    System.out.print((char) i);
}
System.out.println();</programlisting><para>This example uses a type cast to convert each integer (in the range) to the corresponding character. Try running the code and see what happens. </para>
</sect1><sect1 id="a0000004325" remap="section">
  <title>Which Loop to Use</title>
    <para><literal>for</literal> and <literal>while</literal> loops have the same capabilities; any <literal>for</literal> loop can be rewritten as a <literal>while</literal> loop, and vice versa. For example, we could have printed letters of the alphabet using a <literal>while</literal> loop: </para><programlisting language="java">
System.out.print("Roman alphabet: ");
char c = 'A';
while (c &lt;= 'Z') {
    System.out.print(c);
    c++;
}
System.out.println();</programlisting><para>You might wonder when to use one or the other. It depends on whether you know how many times the loop will repeat. </para><para>A <literal>for</literal> loop is “definite”, which means we know, at the beginning of the loop, how many times it will repeat. In the alphabet example, we know it will run 26 times. In that case, it’s better to use a <literal>for</literal> loop, which puts all of the loop control code on one line. </para><para>A <literal>while</literal> loop is “indefinite”, which means we don’t know how many times it will repeat. For example, when validating user input as in <xref linkend="validate" />, it’s impossible to know how many times the user will enter a wrong value. In this case, a <literal>while</literal> loop is more appropriate. </para><programlisting language="java">
System.out.print("Enter a number: ");
while (!in.hasNextDouble()) {
    String word = in.next();
    System.err.println(word + " is not a number");
    System.out.print("Enter a number: ");
}
double number = in.nextDouble();</programlisting><para>It’s easier to read the <literal>Scanner</literal> method calls when they’re not all on one line of code. </para>
</sect1><sect1 id="a0000004357" remap="section">
  <title>String Iteration</title>
    <para><indexterm>
  <primary>iteration</primary>

</indexterm>Strings provide a method called <literal>length</literal> that returns the number of characters in the string. The following loop iterates the characters in <literal>fruit</literal> and displays them, one on each line: </para><programlisting language="java">
for (int i = 0; i &lt; fruit.length(); i++) {
    char letter = fruit.charAt(i);
    System.out.println(letter);
}</programlisting><para><indexterm>
  <primary>string</primary>
<secondary>length</secondary>
</indexterm><indexterm>
  <primary>length</primary>
<secondary>string</secondary>
</indexterm>Because <literal>length</literal> is a method, you have to invoke it with parentheses (there are no arguments). When <literal>i</literal> is equal to the length of the string, the condition becomes <literal>false</literal> and the loop terminates. </para><para>To find the last letter of a string, you might be tempted to do something like: </para><programlisting language="java">
int length = fruit.length();
char last = fruit.charAt(length);      // wrong!</programlisting><para><indexterm>
  <primary>StringIndexOutOfBoundsException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>StringIndexOutOfBounds</secondary>
</indexterm>This code compiles and runs, but invoking the <literal>charAt</literal> method throws a <literal>StringIndexOutOfBoundsException</literal>. The problem is that there is no sixth letter in <literal>"banana"</literal>. Since we started counting at 0, the 6 letters are indexed from 0 to 5. To get the last character, you have to subtract 1 from <literal>length</literal>. </para><programlisting language="java">
int length = fruit.length();
char last = fruit.charAt(length - 1);  // correct</programlisting><para>Many string algorithms involve reading one string and building another. For example, to reverse a string, we can concatenate one character at a time: </para><programlisting language="java">
public static String reverse(String s) {
    String r = "";
    for (int i = s.length() - 1; i &gt;= 0; i--) {
        r += s.charAt(i);
    }
    return r;
}</programlisting><para><indexterm>
  <primary>empty string</primary>

</indexterm>The initial value of <literal>r</literal> is <literal>""</literal>, which is the <emphasis role="bold">empty string</emphasis>. The loop iterates the letters of <literal>s</literal> in reverse order. Each time through the loop, it creates a new string and assigns it to <literal>r</literal>. When the loop exits, <literal>r</literal> contains the letters from <literal>s</literal> in reverse order. So the result of <literal>reverse("banana")</literal> is <literal>"ananab"</literal>. </para>
</sect1><sect1 id="a0000004412" remap="section">
  <title>The indexOf Method</title>
    <para><indexterm>
  <primary>indexOf</primary>

</indexterm>To search for a specific character in a string, you could write a <literal>for</literal> loop and use <literal>charAt</literal> like in the previous section. However, the <literal>String</literal> class already provides a method for doing just that. </para><programlisting language="java">
String fruit = "banana";
int index = fruit.indexOf('a');     // returns 1</programlisting><para>This example finds the index of <literal>’a’</literal> in the string. But the letter appears three times, so it’s not obvious what <literal>indexOf</literal> might do. According to the documentation, it returns the index of the <emphasis>first</emphasis> appearance. </para><para>To find subsequent appearances, you can use another version of <literal>indexOf</literal>, which takes a second argument that indicates where in the string to start looking. </para><programlisting language="java">
int index = fruit.indexOf('a', 2);  // returns 3</programlisting><para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>To visualize how <literal>indexOf</literal> and other <literal>String</literal> methods work, it helps to draw a picture like <xref linkend="fig.banana" />. The previous code starts at index 2 (the first <literal>’n’</literal>) and finds the next <literal>’a’</literal>, which is at index 3. </para>
  
  <figure id="fig.banana" float="False">
    <title>Memory diagram for a <literal>String</literal> of six characters.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/banana.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If the character happens to appear at the starting index, the starting index is the answer. So <literal>fruit.indexOf(’a’, 5)</literal> returns <literal>5</literal>. If the character does not appear in the string, <literal>indexOf</literal> returns <literal>-1</literal>. Since indexes cannot be negative, this value indicates the character was not found. </para><para>You can also use <literal>indexOf</literal> to search for an entire string, not just a single character. For example, the expression <literal>fruit.indexOf("nan")</literal> returns <literal>2</literal>. </para>
</sect1><sect1 id="a0000004471" remap="section">
  <title>Substrings</title>
    <para><indexterm>
  <primary>substring</primary>

</indexterm>In addition to searching strings, we often need to extract parts of strings. The <literal>substring</literal> method returns a new string that copies letters from an existing string, given a pair of indexes. </para><itemizedlist>
  
    <listitem><para><literal>fruit.substring(0, 3)</literal> returns <literal>"ban"</literal> </para></listitem>
  
    <listitem><para><literal>fruit.substring(2, 5)</literal> returns <literal>"nan"</literal> </para></listitem>
  
    <listitem><para><literal>fruit.substring(6, 6)</literal> returns <literal>""</literal> </para></listitem>
  
</itemizedlist><para>Notice that the character indicated by the second index is <emphasis>not</emphasis> included. Defining <literal>substring</literal> this way simplifies some common operations. For example, to select a substring with length <literal>len</literal>, starting at index <literal>i</literal>, you could write <literal>fruit.substring(i, i + len)</literal>. </para><para><indexterm>
  <primary>overloaded</primary>

</indexterm>Like most string methods, <literal>substring</literal> is <emphasis role="bold">overloaded</emphasis>. That is, there are other versions of <literal>substring</literal> that have different parameters. If it’s invoked with one argument, it returns the letters from that index to the end. </para><itemizedlist>
  
    <listitem><para><literal>fruit.substring(0)</literal> returns <literal>"banana"</literal> </para></listitem>
  
    <listitem><para><literal>fruit.substring(2)</literal> returns <literal>"nana"</literal> </para></listitem>
  
    <listitem><para><literal>fruit.substring(6)</literal> returns <literal>""</literal> </para></listitem>
  
</itemizedlist><para>The first example returns a copy of the entire string. The second example returns all but the first two characters. As the last example shows, <literal>substring</literal> returns the empty string if the argument is the length of the string. </para><para>We could also use <literal>fruit.substring(2, fruit.length() - 1)</literal> to get the result <literal>"nana"</literal>. But calling <literal>substring</literal> with one argument is more convenient when you want the end of the string. </para>
</sect1><sect1 id="strcmp" remap="section">
  <title>String Comparison</title><para><indexterm>
  <primary>equals</primary>

</indexterm><indexterm>
  <primary>string</primary>
<secondary>comparing</secondary>
</indexterm>When comparing strings, it might be tempting to use the <literal>==</literal> and <literal>!=</literal> operators. But that will almost never work. The following code compiles and runs, but it always prints <literal>"Goodbye!"</literal> regardless what the user types. </para><programlisting language="java">
System.out.print("Play again? ");
String answer = in.nextLine();
if (answer == "yes") {                 // wrong!
    System.out.println("Let's go!");
} else {
    System.out.println("Goodbye!");
}</programlisting><para>The problem is that the <literal>==</literal> operator checks whether the two operands refer to the <emphasis>same object</emphasis>. Even if answer is <literal>"yes"</literal>, it will refer to a different object in memory than the literal string <literal>"yes"</literal> in the code. We’ll learn more about objects and references in the next chapter. </para><para>The correct way to compare strings is with the <literal>equals</literal> method, like this: </para><programlisting language="java">
if (answer.equals("yes")) {
    System.out.println("Let's go!");
}</programlisting><para>This example invokes <literal>equals</literal> on <literal>answer</literal> and passes <literal>"yes"</literal> as an argument. The <literal>equals</literal> method returns <literal>true</literal> if the strings contain the same characters; otherwise it returns <literal>false</literal>. </para><para><indexterm>
  <primary>compareTo</primary>

</indexterm>If two strings differ, we can use <literal>compareTo</literal> to see which comes first in alphabetical order: </para><programlisting language="java">
String name1 = "Alan Turing";
String name2 = "Ada Lovelace";
int diff = name1.compareTo(name2);
if (diff &lt; 0) {
    System.out.println("name1 comes before name2.");
} else if (diff &gt; 0) {
    System.out.println("name2 comes before name1.");
} else {
    System.out.println("The names are the same.");
}</programlisting><para>The return value from <literal>compareTo</literal> is the difference between the first characters in the strings that are not the same. In the preceding code, <literal>compareTo</literal> returns positive 8, because the second letter of <literal>"Ada"</literal> comes before the second letter of <literal>"Alan"</literal> by 8 letters. </para><para>If the first string (the one on which the method is invoked) comes earlier in the alphabet, the difference is negative. If it comes later in the alphabet, the difference is positive. If the strings are equal, their difference is zero. </para><para><indexterm>
  <primary>case-sensitive</primary>

</indexterm>Both <literal>equals</literal> and <literal>compareTo</literal> are case-sensitive. In Unicode, uppercase letters come before lowercase letters. So <literal>"Ada"</literal> comes before <literal>"ada"</literal>. </para>
</sect1><sect1 id="a0000004610" remap="section">
  <title>String Formatting</title>
    <para><indexterm>
  <primary>printf</primary>

</indexterm>In <xref linkend="printf" />, we learned how to use <literal>System.out.printf</literal> to display formatted output. Sometimes programs need to create strings that are formatted a certain way, but not display them immediately (or ever). For example, the following method returns a time string in 12-hour format: </para><programlisting language="java">
public static String timeString(int hour, int minute) {
    String ampm;
    if (hour &lt; 12) {
        ampm = "AM";
        if (hour == 0) {
            hour = 12;  // midnight
        }
    } else {
        ampm = "PM";
        hour = hour - 12;
    }
    return String.format("%02d:%02d %s", hour, minute, ampm);
}</programlisting><para><indexterm>
  <primary>string</primary>
<secondary>format</secondary>
</indexterm><literal>String.format</literal> takes the same arguments as <literal>System.out.printf</literal>: a format specifier followed by a sequence of values. The main difference is that <literal>System.out.printf</literal> displays the result on the screen. <literal>String.format</literal> creates a new string, but does not display anything. </para><para>In this example, the format specifier <literal>%02d</literal> means “two digit integer padded with zeros”, so <literal>timeString(19, 5)</literal> returns the string <literal>"07:05 PM"</literal>. As an exercise, try writing two nested <literal>for</literal> loops (in <literal>main</literal>) that invoke <literal>timeString</literal> and display all possible times over a 24-hour period. </para><para>Be sure to skim through the documentation for <literal>String</literal>. Knowing what other methods are there will help you avoid reinventing the wheel. The easiest way to find documentation for Java classes is to do a web search for “Java” and the name of the class. </para>
</sect1><sect1 id="a0000004646" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>loop:</term>
      <listitem><para><indexterm>
  <primary>loop</primary>

</indexterm>A statement that executes a sequence of statements repeatedly. </para></listitem>
  </varlistentry><varlistentry>
    <term>loop body:</term>
      <listitem><para><indexterm>
  <primary>loop body</primary>

</indexterm>The statements inside the loop. </para></listitem>
  </varlistentry><varlistentry>
    <term>infinite loop:</term>
      <listitem><para><indexterm>
  <primary>infinite loop</primary>

</indexterm>A loop whose condition is always true. </para></listitem>
  </varlistentry><varlistentry>
    <term>increment:</term>
      <listitem><para><indexterm>
  <primary>increment</primary>

</indexterm>Increase the value of a variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>decrement:</term>
      <listitem><para><indexterm>
  <primary>decrement</primary>

</indexterm>Decrease the value of a variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>iteration:</term>
      <listitem><para><indexterm>
  <primary>iteration</primary>

</indexterm>Executing a sequence of statements repeatedly. </para></listitem>
  </varlistentry><varlistentry>
    <term>loop variable:</term>
      <listitem><para><indexterm>
  <primary>loop variable</primary>

</indexterm>A variable that is initialized, tested, and updated in order to control a loop. </para></listitem>
  </varlistentry><varlistentry>
    <term>index:</term>
      <listitem><para><indexterm>
  <primary>index</primary>

</indexterm>An integer variable or value used to indicate a character in a string. </para></listitem>
  </varlistentry><varlistentry>
    <term>Unicode:</term>
      <listitem><para><indexterm>
  <primary>Unicode</primary>

</indexterm>An international standard for representing characters in most of the world’s languages. </para></listitem>
  </varlistentry><varlistentry>
    <term>empty string:</term>
      <listitem><para><indexterm>
  <primary>empty string</primary>

</indexterm>The string <literal>""</literal>, which contains no characters and has a length of zero. </para></listitem>
  </varlistentry><varlistentry>
    <term>overloading:</term>
      <listitem><para><indexterm>
  <primary>overloading</primary>

</indexterm>Defining two or more methods with the same name but different parameters. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000004673" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch06</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="debugger" />, now might be a good time. It describes the DrJava debugger, which is a useful tool for visualizing the flow of execution through loops. </para><para><example id="a0000004685" role="exercise">
  <title></title>
  <para>Consider the following methods (<literal>main</literal> and <literal>loop</literal>). </para><orderedlist>
  
  <listitem><para>Draw a table that shows the value of the variables <literal>i</literal> and <literal>n</literal> during the execution of <literal>loop</literal>. The table should contain one column for each variable and one line for each iteration. </para></listitem>
  
  <listitem><para>What is the output of this program? </para></listitem>
  
  <listitem><para>Can you prove that this loop terminates for any positive value of <literal>n</literal>? </para></listitem>
  
</orderedlist><programlisting language="java">
public static void main(String[] args) {
    loop(10);
}

public static void loop(int n) {
    int i = n;
    while (i &gt; 1) {
        System.out.println(i);
        if (i % 2 == 0) {
            i = i / 2;
        } else {
            i = i + 1;
        }
    }
}</programlisting></example> </para><para><example id="a0000004710" role="exercise">
  <title></title>
  <para>Let’s say you are given a number, <emphasis role="math">a</emphasis>, and you want to find its square root. One way to do that is to start with a rough guess about the answer, <emphasis role="math">x<subscript>0</subscript></emphasis>, and then improve the guess using this formula: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mi>a</mml:mi><mml:mo>/</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></informalequation><para> For example, if we want to find the square root of 9, and we start with <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inlineequation>, then <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mn>9</mml:mn><mml:mo>/</mml:mo><mml:mn>6</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>75</mml:mn></mml:mrow></mml:math></inlineequation>, which is closer. We can repeat the procedure, using <emphasis role="math">x<subscript>1</subscript></emphasis> to calculate <emphasis role="math">x<subscript>2</subscript></emphasis>, and so on. In this case, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>075</mml:mn></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>.</mml:mo><mml:mn>00091</mml:mn></mml:mrow></mml:math></inlineequation>. So it converges quickly on the correct answer. </para><para>Write a method called <literal>squareRoot</literal> that takes a <literal>double</literal> and returns an approximation of the square root of the parameter, using this technique. You should not use <literal>Math.sqrt</literal>. </para><para>As your initial guess, you should use <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inlineequation>. Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001. You can use <literal>Math.abs</literal> to calculate the absolute value of the difference. </para>
</example> </para><para><example id="a0000004745" role="exercise">
  <title></title>
  <para>One way to evaluate <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> is to use the infinite series expansion: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">exp</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>-</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>6</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mo>...</mml:mo></mml:mrow></mml:math></informalequation><para> The <emphasis role="math">i</emphasis>th term in this series is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msup><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inlineequation>. Write a method named <literal>gauss</literal> that takes <literal>x</literal> and <literal>n</literal> as arguments and returns the sum of the first <literal>n</literal> terms of the series. You should not use <literal>factorial</literal> or <literal>pow</literal>. </para>
</example> </para><para><example id="a0000004776" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>abecedarian</primary>

</indexterm>A word is said to be “abecedarian” if the letters in the word appear in alphabetical order. For example, the following are all six-letter English abecedarian words: </para><blockquote remap="quote"><para> abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, deinos, diluvy, dimpsy </para></blockquote><para>Write a method called <literal>isAbecedarian</literal> that takes a <literal>String</literal> and returns a <literal>boolean</literal> indicating whether the word is abecedarian. </para>
</example> </para><para><example id="doubloon" role="exercise">
  <title></title><para><indexterm>
  <primary>doubloon</primary>

</indexterm>A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Here are some example doubloons found in the dictionary: </para><blockquote remap="quote"><para> Abba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto </para></blockquote><para>Write a method called <literal>isDoubloon</literal> that takes a string and checks whether it is a doubloon. To ignore case, invoke the <literal>toLowerCase</literal> method before checking. </para>
</example> </para><para><example id="a0000004801" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>Scrabble</primary>

</indexterm>In Scrabble<footnote><para>Scrabble is a registered trademark owned in the USA and Canada by Hasbro Inc., and in the rest of the world by J. W. Spear &amp; Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.</para></footnote> each player has a set of tiles with letters on them. The object of the game is to use those letters to spell words. The scoring system is complex, but longer words are usually worth more than shorter words. </para><para>Imagine you are given your set of tiles as a string, like <literal>"quijibo"</literal>, and you are given another string to test, like <literal>"jib"</literal>. </para><para>Write a method called <literal>canSpell</literal> that takes two strings and checks whether the set of tiles can spell the word. You might have more than one tile with the same letter, but you can only use each tile once. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000004816">
  <title>Arrays and References</title>
  <para>Up to this point, the only variables we have used were for individual values such as numbers or strings. In this chapter, we’ll learn how to store multiple values of the same type using a single variable. This language feature will enable you to write programs that manipulate larger amounts of data. </para><para>For example, <xref linkend="doubloon" /> asked you to check whether every letter in a string appears exactly twice. One algorithm (which hopefully you already discovered) is to loop through the string 26 times, once for each lowercase letter: </para><programlisting language="java">
// outer loop: for each lowercase letter
for (char c = 'a'; c &lt;= 'z'; c++) {
    // inner loop: count how many times the letter appears
    for (int i = 0; i &lt; str.length(); i++) {
        ...
    // if the count is not 0 or 2, return false</programlisting><para>This “nested loops” approach is inefficient, especially when the string is long. For example, there are more than 3 million characters in <emphasis>War and Peace</emphasis>; to process the whole book, the nested loop would run about 80 million times. </para><para>Another algorithm would initialize 26 variables to zero, loop through the string <emphasis>one time</emphasis>, and use a giant <literal>if</literal> statement to update the variable for each letter. But who wants to declare 26 variables? </para><para>That’s where arrays come in. We can use a single variable to store 26 integers. Rather than use an <literal>if</literal> statement to update each value, we can use arithmetic to update the <emphasis role="math">n</emphasis>th value directly. We will present this algorithm at the end of the chapter. </para><sect1 id="a0000004835" remap="section">
  <title>Creating Arrays</title>
    <para><indexterm>
  <primary>array</primary>

</indexterm><indexterm>
  <primary>element</primary>

</indexterm>An <emphasis role="bold">array</emphasis> is a sequence of values; the values in the array are called <emphasis role="bold">elements</emphasis>. You can make an array of <literal>int</literal>s, <literal>double</literal>s, <literal>String</literal>s, or any other type, but all the values in an array must have the same type. </para><para><indexterm>
  <primary>type</primary>
<secondary>array</secondary>
</indexterm><indexterm>
  <primary>[ ] square brackets</primary>

</indexterm><indexterm>
  <primary>brackets</primary>
<secondary>square</secondary>
</indexterm>To create an array, you have to declare a variable with an <emphasis>array type</emphasis> and then create the array itself. Array types look like other Java types, except they are followed by square brackets (<literal>[]</literal>). For example, the following lines declare that <literal>counts</literal> is an “integer array” and <literal>values</literal> is a “double array”: </para><programlisting language="java">
int[] counts;
double[] values;</programlisting><para><indexterm>
  <primary>new</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm><indexterm>
  <primary>allocate</primary>

</indexterm>To create the array itself, you have to use the <literal>new</literal> operator, which we first saw in <xref linkend="scanner" />. The <literal>new</literal> operator <emphasis role="bold">allocates</emphasis> memory for the array and automatically initializes all of its elements to zero. </para><programlisting language="java">
counts = new int[4];
values = new double[size];</programlisting><para>The first assignment makes <literal>counts</literal> refer to an array of four integers. The second makes <literal>values</literal> refer to an array of <literal>double</literal>s, but the number of elements depends on the value of <literal>size</literal> (at the time the array is created). </para><para>Of course, you can also declare the variable and create the array with a single line of code: </para><programlisting language="java">
int[] counts = new int[4];
double[] values = new double[size];</programlisting><para><indexterm>
  <primary>NegativeArraySizeException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>NegativeArraySize</secondary>
</indexterm>You can use any integer expression for the size of an array, as long as the value is nonnegative. If you try to create an array with <literal>-4</literal> elements, for example, you will get a <literal>NegativeArraySizeException</literal>. An array with zero elements is allowed, and there are special uses for such arrays. </para><para>You can initialize an array with an <emphasis role="bold">array literal</emphasis>, which is a comma-separated sequence of elements enclosed in braces, like this: </para><programlisting language="java">
int[] a = {1, 2, 3, 4};</programlisting><para>This statement creates an array variable, <literal>a</literal>, and makes it refer to an array with four elements. </para>
</sect1><sect1 id="elements" remap="section">
  <title>Accessing Elements</title><para>When you create an array with the <literal>new</literal> operator, the elements are initialized to zero. <xref linkend="fig.array" /> shows a memory diagram of the <literal>counts</literal> array so far. </para>
  
  <figure id="fig.array" float="False">
    <title>Memory diagram of an <literal>int</literal> array.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>reference</primary>

</indexterm>The arrow indicates that the value of <literal>counts</literal> is a <emphasis role="bold">reference</emphasis> to the array. You should think of <emphasis>the array</emphasis> and <emphasis>the variable</emphasis> that refers to it as two different things. As we’ll soon see, we can assign a different variable to refer to the same array, and we can change the value of <literal>counts</literal> to refer to a different array. </para><para><indexterm>
  <primary>element</primary>

</indexterm><indexterm>
  <primary>index</primary>

</indexterm><indexterm>
  <primary>array</primary>
<secondary>element</secondary>
</indexterm><indexterm>
  <primary>array</primary>
<secondary>index</secondary>
</indexterm>The boldface numbers inside the boxes are the elements of the array. The lighter numbers outside the boxes are the <emphasis role="bold">indexes</emphasis> used to identify each location in the array. As with strings, the index of the first element is 0, not 1. For this reason, we sometimes refer to the first element as the “zeroth” element. </para><para>The <literal>[]</literal> operator selects elements from an array: </para><programlisting language="java">
System.out.println("The zeroth element is " + counts[0]);</programlisting><para>You can use the <literal>[]</literal> operator anywhere in an expression: </para><programlisting language="java">
counts[0] = 7;
counts[1] = counts[0] * 2;
counts[2]++;
counts[3] -= 60;</programlisting><para><xref linkend="fig.array2" /> shows the result of these statements. </para>
  
  <figure id="fig.array2" float="False">
    <title>Memory diagram after several assignment statements.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>You can use any expression as an index, as long as it has type <literal>int</literal>. One of the most common ways to index an array is with a loop variable. For example: </para><programlisting language="java">
int i = 0;
while (i &lt; 4) {
    System.out.println(counts[i]);
    i++;
}</programlisting><para>This <literal>while</literal> loop counts up from 0 to 4. When <literal>i</literal> is 4, the condition fails and the loop terminates. So the body of the loop is only executed when <literal>i</literal> is 0, 1, 2, and 3. In this context, the variable name <literal>i</literal> is short for “index”. </para><para><indexterm>
  <primary>loop variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>loop</secondary>
</indexterm>Each time through the loop we use <literal>i</literal> as an index into the array, displaying the <emphasis role="math">i</emphasis>th element. This type of array processing is usually written as a <literal>for</literal> loop. </para><programlisting language="java">
for (int i = 0; i &lt; 4; i++) {
    System.out.println(counts[i]);
}</programlisting><para><indexterm>
  <primary>ArrayIndexOutOfBoundsException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>ArrayIndexOutOfBounds</secondary>
</indexterm>For the <literal>counts</literal> array, the only legal indexes are 0, 1, 2, and 3. If the index is negative or greater than 3, the result is an <literal>ArrayIndexOutOfBoundsException</literal>. </para>
</sect1><sect1 id="printarray" remap="section">
  <title>Displaying Arrays</title><para><indexterm>
  <primary>array</primary>
<secondary>printing</secondary>
</indexterm>You can use <literal>println</literal> to display an array, but it probably doesn’t do what you would like. For example, if you print an array like this: </para><programlisting language="java">
int[] a = {1, 2, 3, 4};
System.out.println(a);</programlisting><para>The output is something like: </para><programlisting>[I@bf3f7e0</programlisting><para>The bracket indicates that the value is an array, <literal>I</literal> stands for “integer”, and the rest represents the address of the array in memory. </para><para>If we want to display the elements of the array, we can do it ourselves: </para><programlisting language="java">
public static void printArray(int[] a) {
    System.out.print("{" + a[0]);
    for (int i = 1; i &lt; a.length; i++) {
        System.out.print(", " + a[i]);
    }
    System.out.println("}");
}</programlisting><para>Given the previous array, the output of <literal>printArray</literal> is: </para><programlisting>{1, 2, 3, 4}</programlisting><para><indexterm>
  <primary>utility class</primary>

</indexterm><indexterm>
  <primary>Arrays class</primary>

</indexterm>The Java library includes a class, <literal>java.util.Arrays</literal>, that provides methods for working with arrays. One of them, <literal>toString</literal>, returns a string representation of an array. After importing <literal>Arrays</literal>, we can invoke <literal>toString</literal> like this: </para><programlisting language="java">
System.out.println(Arrays.toString(a));</programlisting><para>And the output is: </para><programlisting>[1, 2, 3, 4]</programlisting><para>Notice that <literal>Arrays.toString</literal> uses square brackets instead of curly braces. But it beats writing your own <literal>printArray</literal> method. </para>
</sect1><sect1 id="a0000005021" remap="section">
  <title>Copying Arrays</title>
    <para><indexterm>
  <primary>array</primary>
<secondary>copying</secondary>
</indexterm>As explained in <xref linkend="elements" />, array variables contain <emphasis>references</emphasis> to arrays. When you make an assignment to an array variable, it simply copies the reference. But it doesn’t copy the array itself. For example: </para><programlisting language="java">
double[] a = new double[3];
double[] b = a;</programlisting><para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>These statements create an array of three <literal>double</literal>s and make two different variables refer to it, as shown in <xref linkend="fig.array3" />. </para>
  
  <figure id="fig.array3" float="False">
    <title>Memory diagram of two variables referring to the same array.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>alias</primary>

</indexterm>Any changes made through either variable will be seen by the other. For example, if we set <literal>a[0] = 17.0</literal>, and then display <literal>b[0]</literal>, the result is <literal>17.0</literal>. Because <literal>a</literal> and <literal>b</literal> are different names for the same thing, they are sometimes called <emphasis role="bold">aliases</emphasis>. </para><para>If you actually want to copy the array, not just the reference, you have to create a new array and copy the elements from one to the other, like this: </para><programlisting language="java">
double[] b = new double[3];
for (int i = 0; i &lt; 3; i++) {
    b[i] = a[i];
}</programlisting><para><indexterm>
  <primary>Arrays class</primary>

</indexterm><literal>java.util.Arrays</literal> provides a method named <literal>copyOf</literal> that performs this task for you. So you can replace the previous code with one line: </para><programlisting language="java">
double[] b = Arrays.copyOf(a, 3);</programlisting><para>The second parameter is the number of elements you want to copy, so <literal>copyOf</literal> can also be used to copy part of an array. <xref linkend="fig.array4" /> shows the state of the array variables after invoking <literal>Arrays.copyOf</literal>. </para>
  
  <figure id="fig.array4" float="False">
    <title>Memory diagram of two variables referring to different arrays.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/array4.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>length</primary>
<secondary>array</secondary>
</indexterm><indexterm>
  <primary>array</primary>
<secondary>length</secondary>
</indexterm>The examples so far only work if the array has three elements. It is better to generalize the code to work with arrays of any size. We can do that by replacing the magic number, <literal>3</literal>, with <literal>a.length</literal>: </para><programlisting language="java">
double[] b = new double[a.length];
for (int i = 0; i &lt; a.length; i++) {
    b[i] = a[i];
}</programlisting><para>All arrays have a built-in constant, <literal>length</literal>, that stores the number of elements. In contrast to <literal>String.length()</literal>, which is a method, <literal>a.length</literal> is a constant. The expression <literal>a.length</literal> may look like a method invocation, but there are no parentheses and no arguments. </para><para>The last time the loop gets executed, <literal>i</literal> is <literal>a.length - 1</literal>, which is the index of the last element. When <literal>i</literal> is equal to <literal>a.length</literal>, the condition fails and the body is not executed—which is a good thing, because trying to access <literal>a[a.length]</literal> would throw an exception. </para><para>Of course we can replace the loop altogether by using <literal>Arrays.copyOf</literal> and <literal>a.length</literal> for the second argument. The following line produces the same result shown in <xref linkend="fig.array4" />. </para><programlisting language="java">
double[] b = Arrays.copyOf(a, a.length);</programlisting><para>The <literal>Arrays</literal> class provides many other useful methods like <literal>Arrays.compare</literal>, <literal>Arrays.equals</literal>, <literal>Arrays.fill</literal>, and <literal>Arrays.sort</literal>. Take a moment to read the documentation by searching the web for <literal>java.util.Arrays</literal>. </para>
</sect1><sect1 id="traversal" remap="section">
  <title>Array Traversal</title><para><indexterm>
  <primary>traversal</primary>

</indexterm>Many computations can be implemented by looping through the elements of an array and performing an operation on each element. Looping through the elements of an array is called a <emphasis role="bold">traversal</emphasis>. </para><programlisting language="java">
int[] a = {1, 2, 3, 4, 5};
for (int i = 0; i &lt; a.length; i++) {
    a[i] *= a[i];
}</programlisting><para>This example traverses an array and squares each element. At the end of the loop, the array has the values <literal remap="verb">{1, 4, 9, 16, 25}</literal>. </para><para><indexterm>
  <primary>search</primary>

</indexterm>Another common pattern is a <emphasis role="bold">search</emphasis>, which involves traversing an array and “searching” for a particular element. For example, the following method takes an array and a value, and it returns the index where the value appears: </para><programlisting language="java">
public static int search(double[] array, double target) {
    for (int i = 0; i &lt; array.length; i++) {
        if (array[i] == target) {
            return i;
        }
    }
    return -1;  // not found
}</programlisting><para>If we find the target value in the array, we return its index immediately. If the loop exits without finding the target, it returns <literal>-1</literal>, a special value chosen to indicate a failed search. (This code is essentially what the <literal>String.indexOf</literal> method does.) </para><para>The following code searches an array for the value <literal>1.23</literal>, which is the third element. Because array indexes start at zero, the output is <literal>2</literal>. </para><programlisting language="java">
double[] array = {3.14, -55.0, 1.23, -0.8};
int index = search(array, 1.23);
System.out.println(index);</programlisting><para><indexterm>
  <primary>reduce</primary>

</indexterm>Another common traversal is a <emphasis role="bold">reduce</emphasis> operation, which “reduces” an array of values down to a single value. Examples include the sum or product of the elements, the minimum, and the maximum. The following method takes an array and returns the sum of its elements: </para><programlisting language="java">
public static double sum(double[] array) {
    double total = 0.0;
    for (int i = 0; i &lt; array.length; i++) {
        total += array[i];
    }
    return total;
}</programlisting><para><indexterm>
  <primary>accumulator</primary>

</indexterm>Before the loop, we initialize <literal>total</literal> to zero. Each time through the loop, we update <literal>total</literal> by adding one element from the array. At the end of the loop, <literal>total</literal> contains the sum of the elements. A variable used this way is sometimes called an <emphasis role="bold">accumulator</emphasis>, because it “accumulates” the running total. </para>
</sect1><sect1 id="random" remap="section">
  <title>Random Numbers</title><para><indexterm>
  <primary>deterministic</primary>

</indexterm>Most computer programs do the same thing every time they run; programs like that are called <emphasis role="bold">deterministic</emphasis>. Usually determinism is a good thing, since we expect the same calculation to yield the same result. But for some applications, we want the computer to be unpredictable. Games are an obvious example, but there are many others, like scientific simulations. </para><para><indexterm>
  <primary>nondeterministic</primary>

</indexterm><indexterm>
  <primary>pseudorandom</primary>

</indexterm>Making a program <emphasis role="bold">nondeterministic</emphasis> turns out to be hard, because it’s impossible for a computer to generate truly random numbers. But there are algorithms that generate unpredictable sequences called <emphasis role="bold">pseudorandom</emphasis> numbers. For most applications, they are as good as random. </para><para><indexterm>
  <primary>Random</primary>

</indexterm><indexterm>
  <primary>nextInt</primary>
<secondary>Random</secondary>
</indexterm>If you did <xref linkend="guess" />, you have already seen <literal>java.util.Random</literal>, which generates pseudorandom numbers. The method <literal>nextInt</literal> takes an integer argument, <literal>n</literal>, and returns a random integer between <literal>0</literal> and <literal>n - 1</literal> (inclusive). </para><para>If you generate a long series of random numbers, every value should appear, at least approximately, the same number of times. One way to test this behavior of <literal>nextInt</literal> is to generate a large number of values, store them in an array, and count the number of times each value occurs. </para><para>The following method creates an <literal>int</literal> array and fills it with random numbers between 0 and 99. The argument specifies the desired size of the array, and the return value is a reference to the new array. </para><programlisting language="java">
public static int[] randomArray(int size) {
    Random random = new Random();
    int[] a = new int[size];
    for (int i = 0; i &lt; a.length; i++) {
        a[i] = random.nextInt(100);
    }
    return a;
}</programlisting><para>The following <literal>main</literal> method generates an array and displays it using <literal>printArray</literal> from <xref linkend="printarray" />. We could have used <literal>Arrays.toString</literal>, but we like seeing curly braces instead of square brackets. </para><programlisting language="java">
public static void main(String[] args) {
    int[] array = randomArray(8);
    printArray(array);
}</programlisting><para>Each time you run the program, you should get different values. The output will look something like this: </para><programlisting>{15, 62, 46, 74, 67, 52, 51, 10}</programlisting></sect1><sect1 id="singlepass" remap="section">
  <title>Building a Histogram</title><para><indexterm>
  <primary>histogram</primary>

</indexterm><indexterm>
  <primary>counter</primary>

</indexterm>If these values were exam scores—and they would be pretty bad exam scores in that case—the teacher might present them to the class in the form of a <emphasis role="bold">histogram</emphasis>. In statistics, a histogram is a set of counters that keeps track of the number of times each value appears. </para><para>For exam scores, we might have ten counters to keep track of how many students scored in the 90s, the 80s, etc. To do that, we can traverse the array and count the number of elements that fall in a given range. </para><para>The following method takes an array and two integers. It returns the number of elements that fall in the range from <literal>low</literal> to <literal>high - 1</literal>. </para><programlisting language="java">
public static int inRange(int[] a, int low, int high) {
    int count = 0;
    for (int i = 0; i &lt; a.length; i++) {
        if (a[i] &gt;= low &amp;&amp; a[i] &lt; high) {
            count++;
        }
    }
    return count;
}</programlisting><para><indexterm>
  <primary>reduce</primary>

</indexterm>This pattern should look familiar: it is another reduce operation. Notice that <literal>low</literal> is included in the range (<literal>&gt;=</literal>), but <literal>high</literal> is excluded (<literal>&lt;</literal>). This design keeps us from counting any scores twice. </para><para>Now we can count the number of scores in each grade range. We add the following code to our <literal>main</literal> method: </para><programlisting language="java">
int[] scores = randomArray(30);
int a = inRange(scores, 90, 100);
int b = inRange(scores, 80, 90);
int c = inRange(scores, 70, 80);
int d = inRange(scores, 60, 70);
int f = inRange(scores, 0, 60);</programlisting><para>This code is repetitive, but it is acceptable as long as the number of ranges is small. Suppose we wanted to keep track of the number of times each individual score appears. Then we would have to write 100 lines of code: </para><programlisting language="java">
int count0 = inRange(scores, 0, 1);
int count1 = inRange(scores, 1, 2);
int count2 = inRange(scores, 2, 3);
...
int count99 = inRange(scores, 99, 100);</programlisting><para>What we need is a way to store 100 counters, preferably so we can use an index to access them. Wait a minute, that’s exactly what an array does. </para><para>The following fragment creates an array of 100 counters, one for each possible score. It loops through the scores and uses <literal>inRange</literal> to count how many times each score appears. Then it stores the results in the <literal>counts</literal> array: </para><programlisting language="java">
int[] counts = new int[100];
for (int i = 0; i &lt; counts.length; i++) {
    counts[i] = inRange(scores, i, i + 1);
}</programlisting><para>Notice that we are using the loop variable <literal>i</literal> three times: as an index into the <literal>counts</literal> array, and in the last two arguments of <literal>inRange</literal>. </para><para><indexterm>
  <primary>efficiency</primary>

</indexterm>The code works, but it is not as efficient as it could be. Every time the loop invokes <literal>inRange</literal>, it traverses the entire array. It would be better to make a single pass through the <literal>scores</literal> array. </para><para>For each score, we already know which range it falls in—the score itself. We can use that value to increment the corresponding counter. This code traverses the array of scores <emphasis>only once</emphasis> to generate the histogram: </para><programlisting language="java">
int[] counts = new int[100];
for (int i = 0; i &lt; scores.length; i++) {
    int index = scores[i];
    counts[index]++;
}</programlisting><para>Each time through the loop, it selects one element from <literal>scores</literal> and uses it as an index to increment the corresponding element of <literal>counts</literal>. Because this code traverses the array of scores only once, it is much more efficient. </para>
</sect1><sect1 id="enhanced" remap="section">
  <title>The Enhanced for Loop</title><para>Since traversing arrays is so common, Java provides an alternative syntax that makes the code more compact. Consider a <literal>for</literal> loop that displays the elements of an array on separate lines: </para><programlisting language="java">
for (int i = 0; i &lt; values.length; i++) {
    int value = values[i];
    System.out.println(value);
}</programlisting><para>We could rewrite the loop like this: </para><programlisting language="java">
for (int value : values) {
    System.out.println(value);
}</programlisting><para><indexterm>
  <primary>enhanced for loop</primary>

</indexterm><indexterm>
  <primary>for</primary>
<secondary>enhanced</secondary>
</indexterm>This statement is called an <emphasis role="bold">enhanced for loop</emphasis>, also known as the “for each” loop. You can read the code as, “for each <literal>value</literal> in <literal>values</literal>”. It’s conventional to use plural nouns for array variables and singular nouns for element variables. </para><para>Notice how the single line <literal>for (int value : values)</literal> replaces the first two lines of the standard <literal>for</literal> loop. It hides the details of iterating each index of the array, and instead, focuses on the values themselves. </para><para>Using the enhanced <literal>for</literal> loop, and removing the temporary variable, we can write the histogram code from the previous section more concisely: </para><programlisting language="java">
int[] counts = new int[100];
for (int score : scores) {
    counts[score]++;
}</programlisting><para>Enhanced <literal>for</literal> loops often make the code more readable, especially for accumulating values. But they are not helpful when you need to refer to the index, as in search operations. </para><programlisting language="java">
for (double d : array) {
    if (d == target) {
        // array contains d, but we don't know where
    }
}</programlisting></sect1><sect1 id="a0000005318" remap="section">
  <title>Counting Characters</title>
    <para>We now return to the example from the beginning of the chapter and present a solution to <xref linkend="doubloon" /> using arrays. Here is the problem again: </para><blockquote remap="quote"><para> A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice. Write a method called <literal>isDoubloon</literal> that takes a string and checks whether it is a doubloon. To ignore case, invoke the <literal>toLowerCase</literal> method before checking. </para></blockquote><para>Based on the approach from <xref linkend="singlepass" />, we will create an array of 26 integers to count how many times each letter appears. We convert the string to lowercase, so that we can treat <literal>’A’</literal> and <literal>’a’</literal> (for example) as the same latter. </para><programlisting language="java">
int[] counts = new int[26];
String lower = s.toLowerCase();</programlisting><para>We can use a <literal>for</literal> loop to iterate each character in the string. To update the <literal>counts</literal> array, we need to compute the index that corresponds to each character. Fortunately, Java allows you to perform arithmetic on characters. </para><programlisting language="java">
for (int i = 0; i &lt; lower.length(); i++) {
    char letter = lower.charAt(i);
    int index = letter - 'a';
    counts[index]++;
}</programlisting><para>If <literal>letter</literal> is <literal>’a’</literal>, the value of <literal>index</literal> is <literal>0</literal>; if <literal>letter</literal> is <literal>’b’</literal>, the value of <literal>index</literal> is <literal>1</literal>, and so on. </para><para>Then we use <literal>index</literal> to increment the corresponding element of <literal>counts</literal>. At the end of the loop, <literal>counts</literal> contains a histogram of the letters in the string <literal>lower</literal>. </para><para><indexterm>
  <primary>toCharArray</primary>

</indexterm>We can simplify this code with an enhanced <literal>for</literal> loop, but it doesn’t work with strings; we have to convert <literal>lower</literal> to an array of characters, like this: </para><programlisting language="java">
for (char letter : lower.toCharArray()) {
    int index = letter - 'a';
    counts[index]++;
}</programlisting><para>Once we have the counts, we can use a second <literal>for</literal> loop to check whether each letter appears 0 or 2 times. </para><programlisting language="java">
for (int count : counts) {
    if (count != 0 &amp;&amp; count != 2) {
        return false;  // not a doubloon
    }
}
return true;  // is a doubloon</programlisting><para>If we find a count that is neither 0 or 2, we know the word is not a doubloon and we can return immediately. If we make it all the way through the <literal>for</literal> loop, we know that all counts are 0 or 2, which means the word is a doubloon. </para><para><indexterm>
  <primary>Doubloon.java</primary>

</indexterm>Pulling together the code fragments, and adding some comments and test cases, here’s the entire program. </para><programlisting language="java">
public class Doubloon {

    public static boolean isDoubloon(String s) {
        // count the number of times each letter appears
        int[] counts = new int[26];
        String lower = s.toLowerCase();
        for (char letter : lower.toCharArray()) {
            int index = letter - 'a';
            counts[index]++;
        }
        // determine whether the given word is a doubloon
        for (int count : counts) {
            if (count != 0 &amp;&amp; count != 2) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(isDoubloon("Mama"));  // true
        System.out.println(isDoubloon("Lama"));  // false
    }
}</programlisting><para>This example uses methods, <literal>if</literal> statements, <literal>for</literal> loops, arithmetic and logical operators, integers, characters, strings, booleans, and arrays. We hope you’ll take a second to appreciate how much you’ve learned! </para>
</sect1><sect1 id="a0000005395" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>array:</term>
      <listitem><para><indexterm>
  <primary>array</primary>

</indexterm>A collection of values, where all the values have the same type, and each value is identified by an index. </para></listitem>
  </varlistentry><varlistentry>
    <term>element:</term>
      <listitem><para><indexterm>
  <primary>element</primary>

</indexterm>One of the values in an array. The <literal>[]</literal> operator selects elements. </para></listitem>
  </varlistentry><varlistentry>
    <term>index:</term>
      <listitem><para><indexterm>
  <primary>index</primary>

</indexterm>An integer variable or value used to indicate an element of an array. </para></listitem>
  </varlistentry><varlistentry>
    <term>allocate:</term>
      <listitem><para><indexterm>
  <primary>allocate</primary>

</indexterm>To reserve memory for an array or other object. In Java, the <literal>new</literal> operator allocates memory. </para></listitem>
  </varlistentry><varlistentry>
    <term>reference:</term>
      <listitem><para><indexterm>
  <primary>reference</primary>

</indexterm>A value that indicates a storage location. In a memory diagram, a reference appears as an arrow. </para></listitem>
  </varlistentry><varlistentry>
    <term>alias:</term>
      <listitem><para><indexterm>
  <primary>alias</primary>

</indexterm>A variable that refers to the same object as another variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>traversal:</term>
      <listitem><para><indexterm>
  <primary>traversal</primary>

</indexterm>Looping through the elements of an array (or other collection). </para></listitem>
  </varlistentry><varlistentry>
    <term>search:</term>
      <listitem><para><indexterm>
  <primary>search</primary>

</indexterm>A traversal pattern used to find a particular element of an array. </para></listitem>
  </varlistentry><varlistentry>
    <term>reduce:</term>
      <listitem><para><indexterm>
  <primary>reduce</primary>

</indexterm>A traversal pattern that combines the elements of an array into a single value. </para></listitem>
  </varlistentry><varlistentry>
    <term>accumulator:</term>
      <listitem><para><indexterm>
  <primary>accumulator</primary>

</indexterm>A variable used to accumulate results during a traversal. </para></listitem>
  </varlistentry><varlistentry>
    <term>deterministic:</term>
      <listitem><para><indexterm>
  <primary>deterministic</primary>

</indexterm>A program that does the same thing every time it is run. </para></listitem>
  </varlistentry><varlistentry>
    <term>nondeterministic:</term>
      <listitem><para><indexterm>
  <primary>nondeterministic</primary>

</indexterm>A program that always behaves differently, even when run multiple times with the same input. </para></listitem>
  </varlistentry><varlistentry>
    <term>pseudorandom:</term>
      <listitem><para><indexterm>
  <primary>pseudorandom</primary>

</indexterm>A sequence of numbers that appear to be random, but which are actually the product of a deterministic computation. </para></listitem>
  </varlistentry><varlistentry>
    <term>histogram:</term>
      <listitem><para><indexterm>
  <primary>histogram</primary>

</indexterm>An array of integers where each integer counts the number of values that fall into a certain range. </para></listitem>
  </varlistentry><varlistentry>
    <term>enhanced for loop:</term>
      <listitem><para><indexterm>
  <primary>enhanced for loop</primary>

</indexterm>An alternative syntax for traversing the elements of an array (or other collection). </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000005432" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch07</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you haven’t already, take a look at <xref linkend="debugging" /> where we’ve collected some of our favorite debugging advice. It refers to language features we haven’t yet covered, but it’s good for you to know what’s available when you need it. </para><para><example id="a0000005444" role="exercise">
  <title></title>
  <para>The purpose of this exercise is to practice reading code and recognizing the traversal patterns in this chapter. The following methods are hard to read, because instead of using meaningful names for the variables and methods, they use names of fruit. </para><para>For each method, write one sentence that describes what the method does, without getting into the details of how it works. And for each variable, identify the role it plays. </para><programlisting language="java">
public static int banana(int[] a) {
    int kiwi = 1;
    int i = 0;
    while (i &lt; a.length) {
        kiwi = kiwi * a[i];
        i++;
    }
    return kiwi;
}</programlisting><programlisting language="java">
public static int grapefruit(int[] a, int grape) {
    for (int i = 0; i &lt; a.length; i++) {
        if (a[i] == grape) {
            return i;
        }
    }
    return -1;
}</programlisting><programlisting language="java">
public static int pineapple(int[] a, int apple) {
    int pear = 0;
    for (int pine: a) {
        if (pine == apple) {
            pear++;
        }
    }
    return pear;
}</programlisting></example> </para><para><example id="a0000005454" role="exercise">
  <title></title>
  <para>What is the output of the following program? Describe in a few words what <literal>mus</literal> does. Draw a stack diagram just before <literal>mus</literal> returns. </para><programlisting language="java">
public static int[] make(int n) {
    int[] a = new int[n];
    for (int i = 0; i &lt; n; i++) {
        a[i] = i + 1;
    }
    return a;
}</programlisting><programlisting language="java">
public static void dub(int[] jub) {
    for (int i = 0; i &lt; jub.length; i++) {
        jub[i] *= 2;
    }
}</programlisting><programlisting language="java">
public static int mus(int[] zoo) {
    int fus = 0;
    for (int i = 0; i &lt; zoo.length; i++) {
        fus += zoo[i];
    }
    return fus;
}</programlisting><programlisting language="java">
public static void main(String[] args) {
    int[] bob = make(5);
    dub(bob);
    System.out.println(mus(bob));
}</programlisting></example> </para><para><example id="a0000005469" role="exercise">
  <title></title>
  <para>Write a method called <literal>indexOfMax</literal> that takes an array of integers and returns the index of the largest element. Can you write this method using an enhanced <literal>for</literal> loop? Why or why not? </para>
</example> </para><para><example id="a0000005476" role="exercise">
  <title></title>
  <para>The Sieve of Eratosthenes is “a simple, ancient algorithm for finding all prime numbers up to any given limit,” which you can read about at <ulink url="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"></ulink>. </para><para>Write a method called <literal>sieve</literal> that takes an integer parameter, <literal>n</literal>, and returns a <literal>boolean</literal> array that indicates, for each number from <literal>0</literal> to <literal>n - 1</literal>, whether the number is prime. </para>
</example> </para><para><example id="a0000005491" role="exercise">
  <title></title>
  <para>Write a method named <literal>areFactors</literal> that takes an integer <literal>n</literal> and an array of integers, and that returns <literal>true</literal> if the numbers in the array are all factors of <literal>n</literal> (which is to say that <literal>n</literal> is divisible by all of them). </para>
</example> </para><para><example id="a0000005504" role="exercise">
  <title></title>
  <para>Write a method named <literal>arePrimeFactors</literal> that takes an integer <literal>n</literal> and an array of integers, and that returns <literal>true</literal> if the numbers in the array are all prime <emphasis>and</emphasis> their product is <literal>n</literal>. </para>
</example> </para><para><example id="a0000005517" role="exercise">
  <title></title>
  <para>Write a method called <literal>letterHist</literal> that takes a string as a parameter and returns a histogram of the letters in the string. The zeroth element of the histogram should contain the number of a’s in the string (upper- and lowercase); the 25th element should contain the number of z’s. Your solution should only traverse the string once. </para>
</example> </para><para><example id="a0000005522" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>anagram</primary>

</indexterm>Two words are anagrams if they contain the same letters and the same number of each letter. For example, “stop” is an anagram of “pots”, “allen downey” is an anagram of “well annoyed”, and “christopher mayfield” is an anagram of “hi prof the camel is dry”. Write a method that takes two strings and checks whether they are anagrams of each other. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000005525">
  <title>Recursive Methods</title>
  <para><indexterm>
  <primary>iterative</primary>

</indexterm><indexterm>
  <primary>recursive</primary>

</indexterm>Up to this point, we’ve been using <literal>while</literal> and <literal>for</literal> loops whenever we’ve needed to repeat something. Methods that use iteration are called <emphasis role="bold">iterative</emphasis>. They are straight-forward, but sometimes there are more elegant solutions. </para><para>In this chapter, we explore one of the most magical things that a method can do: invoke <emphasis>itself</emphasis> to solve a smaller version of the <emphasis>same</emphasis> problem. A method that invokes itself is called <emphasis role="bold">recursive</emphasis>. </para><sect1 id="recursion" remap="section">
  <title>Recursive Void Methods</title><para><indexterm>
  <primary>countdown</primary>

</indexterm>Consider the following example: </para><programlisting language="java">
public static void countdown(int n) {
    if (n == 0) {
        System.out.println("Blastoff!");
    } else {
        System.out.println(n);
        countdown(n - 1);
    }
}</programlisting><para>The name of the method is <literal>countdown</literal>; it takes a single integer as a parameter. If the parameter is zero, it displays the word “Blastoff”. Otherwise, it displays the number and then invokes itself, passing <literal>n - 1</literal> as the argument. </para><para>What happens if we invoke <literal>countdown(3)</literal> from <literal>main</literal>? </para><blockquote remap="quote"><para> The execution of <literal>countdown</literal> begins with <literal>n == 3</literal>, and since <literal>n</literal> is not zero, it displays the value 3, and then invokes itself... <blockquote remap="quote"><para> The execution of <literal>countdown</literal> begins with <literal>n == 2</literal>, and since <literal>n</literal> is not zero, it displays the value 2, and then invokes itself... <blockquote remap="quote"><para> The execution of <literal>countdown</literal> begins with <literal>n == 1</literal>, and since <literal>n</literal> is not zero, it displays the value 1, and then invokes itself... <blockquote remap="quote"><para> The execution of <literal>countdown</literal> begins with <literal>n == 0</literal>, and since <literal>n</literal> is zero, it displays the word “Blastoff!” and then returns. </para></blockquote> The <literal>countdown</literal> that got <literal>n == 1</literal> returns. </para></blockquote> The <literal>countdown</literal> that got <literal>n == 2</literal> returns. </para></blockquote> The <literal>countdown</literal> that got <literal>n == 3</literal> returns. </para></blockquote><para>And then you’re back in <literal>main</literal>. So the total output looks like: </para><programlisting>3
2
1
Blastoff!</programlisting><para>As a second example, we’ll rewrite the methods <literal>newLine</literal> and <literal>threeLine</literal> from <xref linkend="adding_methods" />. Here they are again: </para><programlisting language="java">
public static void newLine() {
    System.out.println();
}

public static void threeLine() {
    newLine();
    newLine();
    newLine();
}</programlisting><para><indexterm>
  <primary>newline</primary>

</indexterm>Although these methods work, they would not help if we wanted to display two newlines, or maybe 100. A more general alternative would be: </para><programlisting language="java">
public static void nLines(int n) {
    if (n &gt; 0) {
        System.out.println();
        nLines(n - 1);
    }
}</programlisting><para>This method takes an integer, <literal>n</literal>, as a parameter and displays <literal>n</literal> newlines. The structure is similar to <literal>countdown</literal>. As long as <emphasis role="math">n</emphasis> is greater than zero, it displays a newline and then invokes itself to display <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> additional newlines. The total number of newlines is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>, which is just what we wanted: <emphasis role="math">n</emphasis>. </para>
</sect1><sect1 id="a0000005631" remap="section">
  <title>Recursive Stack Diagrams</title>
    <para><indexterm>
  <primary>stack diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>stack</secondary>
</indexterm>In <xref linkend="stack" />, we used a stack diagram to represent the state of a program during a method invocation. The same kind of diagram can make it easier to interpret a recursive method. </para><para>Remember that every time a method gets called, Java creates a new frame that contains the method’s parameters and variables. <xref linkend="fig.stack2" /> is a stack diagram for <literal>countdown</literal>, called with <literal>n == 3</literal>. </para>
  
  <figure id="fig.stack2" float="False">
    <title>Stack diagram for the <literal>countdown</literal> program.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>By convention, the frame for <literal>main</literal> is at the top, and the stack of other frames grows down. That way, we can draw stack diagrams on paper without needing to guess how far they will grow. The frame for <literal>main</literal> is empty because <literal>main</literal> does not have any variables. (It has the parameter <literal>args</literal>, but since we’re not using it, we left it out of the diagram.) </para><para><indexterm>
  <primary>base case</primary>

</indexterm>There are four frames for <literal>countdown</literal>, each with a different value for the parameter <literal>n</literal>. The last frame, with <literal>n == 0</literal>, is called the <emphasis role="bold">base case</emphasis>. It does not make a recursive call, so there are no more frames below it. </para><para><indexterm>
  <primary>StackOverflowError</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>StackOverflow</secondary>
</indexterm>If there is no base case in a recursive method, or if the base case is never reached, the stack would grow forever—at least in theory. In practice, the size of the stack is limited. If you exceed the limit, you get a <literal>StackOverflowError</literal>. </para><para>For example, here is a recursive method without a base case: </para><programlisting language="java">
public static void forever(String s) {
    System.out.println(s);
    forever(s);
}</programlisting><para><indexterm>
  <primary>call stack</primary>

</indexterm>This method displays the given string until the stack overflows, at which point it throws an error. Try this example on your computer—you might be surprised by how long the error message is! </para>
</sect1><sect1 id="factorial" remap="section">
  <title>Value-Returning Methods</title><para>To give you an idea of what you can do with the tools we have learned, let’s look at methods that evaluate recursively-defined mathematical functions. </para><para>A recursive definition is similar to a “circular” definition, in the sense that the definition refers to the thing being defined. Of course, a truly circular definition is not very useful: </para><blockquote remap="quote"><para> <emphasis role="bold">recursive:</emphasis> An adjective used to describe a method that is recursive. </para></blockquote><para><indexterm>
  <primary>recursion</primary>

</indexterm>If you saw that definition in the dictionary, you might be annoyed. Then again, if you search for “recursion” on Google, it displays “Did you mean: recursion” as an inside joke. People fall for that link all the time. </para><para><indexterm>
  <primary>factorial</primary>

</indexterm>Many mathematical functions are defined recursively, because that is often the simplest way. For example, the <emphasis role="bold">factorial</emphasis> of an integer <emphasis role="math">n</emphasis>, which is written <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inlineequation>, is defined like this: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mo>!</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>·</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para> Don’t confuse the mathematical symbol <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mo>!</mml:mo></mml:math></inlineequation>, which means <emphasis>factorial</emphasis>, with the Java operator <literal>!</literal>, which means <emphasis>not</emphasis>. This definition says that <literal>factorial(0)</literal> is <literal>1</literal>, and <literal>factorial(n)</literal> is <literal>n * factorial(n - 1)</literal>. </para><para>So <literal>factorial(3)</literal> is <literal>3 * factorial(2)</literal>; <literal>factorial(2)</literal> is <literal>2 * factorial(1)</literal>; <literal>factorial(1)</literal> is <literal>1 * factorial(0)</literal>; and <literal>factorial(0)</literal> is <literal>1</literal>. Putting it all together, we get <literal>3 * 2 * 1 * 1</literal>, which is 6. </para><para>If you can formulate a recursive definition of something, you can easily write a Java method to evaluate it. The first step is to decide what the parameters and return type are. Since factorial is defined for integers, the method takes an <literal>int</literal> as a parameter and returns an <literal>int</literal>. </para><programlisting language="java">
public static int factorial(int n) {
    return 0;  // stub
}</programlisting><para>Next, we think about the base case. If the argument happens to be zero, we return 1. </para><programlisting language="java">
public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return 0;  // stub
}</programlisting><para>Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, and then multiply it by <emphasis role="math">n</emphasis>. </para><programlisting language="java">
public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    int recurse = factorial(n - 1);
    int result = n * recurse;
    return result;
}</programlisting><para>To illustrate what is happening, we’ll use the temporary variables <literal>recurse</literal> and <literal>result</literal>. In each method call, <literal>recurse</literal> stores the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, and <literal>result</literal> stores the factorial of <emphasis role="math">n</emphasis>. </para><para>The flow of execution for this program is similar to <literal>countdown</literal> from <xref linkend="recursion" />. If we invoke <literal>factorial</literal> with the value 3: </para><blockquote remap="quote"><para> Since 3 is not zero, we skip the first branch and calculate the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>... <blockquote remap="quote"><para> Since 2 is not zero, we skip the first branch and calculate the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>... <blockquote remap="quote"><para> Since 1 is not zero, we skip the first branch and calculate the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>... <blockquote remap="quote"><para> Since 0 <emphasis>is</emphasis> zero, we take the first branch and return the value 1 immediately. </para></blockquote> The return value (1) gets multiplied by <literal>n</literal>, which is 1, and the result is returned. </para></blockquote> The return value (1) gets multiplied by <literal>n</literal>, which is 2, and the result is returned. </para></blockquote> The return value (2) gets multiplied by <literal>n</literal>, which is 3, and the result, 6, is returned to whatever invoked <literal>factorial(3)</literal>. </para></blockquote><para><indexterm>
  <primary>stack diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>stack</secondary>
</indexterm><xref linkend="fig.stack3" /> shows what the stack diagram looks like for this sequence of method invocations. The return values are shown being passed up the stack. Notice that <literal>recurse</literal> and <literal>result</literal> do not exist in the last frame, because when <literal>n == 0</literal> the code that declares them does not execute. </para>
  
  <figure id="fig.stack3" float="False">
    <title>Stack diagram for the <literal>factorial</literal> method.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>

</sect1><sect1 id="fibonacci" remap="section">
  <title>The Leap of Faith</title><para><indexterm>
  <primary>leap of faith</primary>

</indexterm>Following the flow of execution is one way to read programs, but it can quickly become overwhelming. Another way to understand recursion is the <emphasis role="bold">leap of faith</emphasis>: when you come to a method invocation, instead of following the flow of execution, you <emphasis>assume</emphasis> that the method works correctly and returns the appropriate value. </para><para>In fact, you are already practicing this leap of faith when you use methods in the Java library. When you invoke <literal>Math.cos</literal> or <literal>System.out.println</literal>, you don’t think about the implementations of those methods. You just assume that they work properly. </para><para>The same is true of other methods. For example, consider the method from <xref linkend="boolmeth" /> that determines whether an integer has only one digit: </para><programlisting language="java">
public static boolean isSingleDigit(int x) {
    return x &gt; -10 &amp;&amp; x &lt; 10;
}</programlisting><para>Once you convince yourself that this method is correct—by examining and testing the code—you can just use the method without ever looking at the implementation again. </para><para>Recursive methods are no different. When you get to a recursive call, don’t think about the flow of execution. Instead, <emphasis>assume</emphasis> that the recursive call produces the desired result. </para><para>For example, “Assuming that I can find the factorial of <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation>, can I compute the factorial of <emphasis role="math">n</emphasis>?” Yes you can, by multiplying by <emphasis role="math">n</emphasis>. Here’s an implementation of <literal>factorial</literal> with the temporary variables removed: </para><programlisting language="java">
public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}</programlisting><para>Notice how similar this version is to the original mathematical definition: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mo>!</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mi>n</mml:mi><mml:mo>!</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>·</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para> Of course, it is strange to assume that the method works correctly when you have not finished writing it. But that’s why it’s called a leap of faith! </para><para><indexterm>
  <primary>fibonacci</primary>

</indexterm>Another common recursively-defined mathematical function is the Fibonacci sequence, which has the following definition: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para> Notice that each Fibonacci number is the sum of the two preceding Fibonacci numbers. Translated into Java, this function is: </para><programlisting language="java">
public static int fibonacci(int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}</programlisting><para>If you try to follow the flow of execution here, even for small values of <literal>n</literal>, your head will explode. But if we take a leap of faith and assume that the two recursive invocations work correctly, then it is clear, looking at the definition, that our implementation is correct. </para>
</sect1><sect1 id="countup" remap="section">
  <title>Counting Up Recursively</title><para>The <literal>countdown</literal> example in <xref linkend="recursion" /> has three parts: (1) it checks the base case, (2) it displays something, and (3) it makes a recursive call. What do you think happens if you reverse steps (2) and (3), making the recursive call <emphasis>before</emphasis> displaying? </para><programlisting language="java">
public static void countup(int n) {
    if (n == 0) {
        System.out.println("Blastoff!");
    } else {
        countup(n - 1);
        System.out.println(n);
    }
}</programlisting><para>The stack diagram is the same as before, and the method is still called <emphasis role="math">n</emphasis> times. But now the <literal>System.out.println</literal> happens just before each recursive call returns. As a result, it counts <emphasis>up</emphasis> instead of down: </para><programlisting>Blastoff!
1
2
3</programlisting><para>Keep this in mind for the next example, which displays numbers in binary. </para>
</sect1><sect1 id="binary" remap="section">
  <title>Binary Number System</title><para>You are probably aware that computers can only store 1’s and 0’s. That’s because processors and memory are made up of billions of tiny on-off switches. </para><para>The value 1 means a switch is on; the value 0 means a switch is off. All types of data, whether integer, floating-point, text, audio, video, or something else, are represented by 1’s and 0’s. </para><para><indexterm>
  <primary>binary</primary>

</indexterm>Fortunately, we can represent any integer as a <emphasis role="bold">binary</emphasis> number. The following table shows the first eight numbers in binary and decimal. </para>
   
     <table id="tab..binary" remap="tabular">
     <title>The first eight binary numbers.</title>
     <tgroup>
     
     <tbody>
     <row>
     
       
       <entry> </entry>
     
       
       <entry><para> Binary </para><para> Decimal </para><para>0 </para><para> 0 </para><para>1 </para><para> 1 </para><para>10 </para><para> 2 </para><para>11 </para><para> 3 </para><para>100 </para><para> 4 </para><para>101 </para><para> 5 </para><para>110 </para><para> 6 </para><para>111 </para><para> 7 </para></entry>
     
       
       <entry> </entry>
     
       
       <entry>The first eight binary numbers.</entry>
     
       
       <entry> </entry>
     
       
       <entry></entry>
     
       
       <entry> </entry>
     
     </row>
     </tbody>
     </tgroup>
     </table>
   
   
<para>In decimal there are 10 digits, and the written representation of numbers is based on powers of 10. For example, the number 456 has 4 in the 100’s place, 5 in the 10’s place, and 6 in the 1’s place. So the value is 400 + 50 + 6. </para> 
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="3">
     
     <tbody>
     <row>
     
       
       <entry><para> 4 </para></entry>
     
       
       <entry><para> 5 </para></entry>
     
       
       <entry><para> 6 </para></entry>
     
     </row><row>
     
       
       <entry><para><emphasis role="math">10<superscript>2</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">10<superscript>1</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">10<superscript>0</superscript></emphasis> </para></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 <para>In binary there are 2 digits, and the written representation of numbers is based on powers of 2. For example, the number 10111 has 1 in the 16’s place, 0 in the 8’s place, 1 in the 4’s place, 1 in the 2’s place, and 1 in the 16’s place. So the value is 16 + 0 + 4 + 2 + 1, which is 23 in decimal. </para> 
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="5">
     
     <tbody>
     <row>
     
       
       <entry><para> 1 </para></entry>
     
       
       <entry><para> 0 </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
     </row><row>
     
       
       <entry><para><emphasis role="math">2<superscript>4</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">2<superscript>3</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">2<superscript>2</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">2<superscript>1</superscript></emphasis> </para></entry>
     
       
       <entry><para> <emphasis role="math">2<superscript>0</superscript></emphasis> </para></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 <para>To get the digits of a decimal number, we can use repeated division. For example, if we divide 456 by 10, we get 45 with remainder 6. The remainder is the rightmost digit of 456. </para><para>If we divide the result again, we get 4 with remainder 5. The remainder is the second rightmost digit of 456. And if we divide again, we get 0 with remainder 4. The remainder is the third rightmost digit of 456, and the result, 0, tells us that we’re done. </para><para>We can do the same thing in binary if we divide by two. When you divide by two, the remainder is the right-most digit, either 0 or 1. If you divide the result again, you get the second rightmost digit. If you keep going, and write down the remainders, you’ll have your number in binary. </para><programlisting>23 / 2 is 11 remainder 1
11 / 2 is  5 remainder 1
 5 / 2 is  2 remainder 1
 2 / 2 is  1 remainder 0
 1 / 2 is  0 remainder 1</programlisting><para>Reading these remainders from bottom to top, 23 in binary is 10111. </para>
</sect1><sect1 id="a0000006047" remap="section">
  <title>Recursive Binary Method</title>
    <para>Now, to display a number in binary we can combine the algorithm from the previous section and the “count up” pattern from <xref linkend="countup" />. </para><para>Here is a recursive method that displays any positive integer in binary: </para><programlisting language="java">
public static void displayBinary(int value) {
    if (value &gt; 0) {
        displayBinary(value / 2);
        System.out.print(value % 2);
    }
}</programlisting><para><indexterm>
  <primary>stack diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>stack</secondary>
</indexterm>If <literal>value</literal> is zero, <literal>displayBinary</literal> does nothing (that’s the base case). If the argument is positive, the method divides it by two and calls <literal>displayBinary</literal> recursively. When the recursive call returns, the method displays one digit of the result and returns (again). <xref linkend="fig.stack4" /> illustrates this process. </para>
  
  <figure id="fig.stack4" float="False">
    <title>Stack diagram for the <literal>displayBinary</literal> method.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stack4.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The leftmost digit is near the bottom of the stack, so it gets displayed first. The rightmost digit, near the top of the stack, gets displayed last. After invoking <literal>displayBinary</literal>, we use <literal>println</literal> to complete the output. </para><programlisting language="java">
displayBinary(23);      // output is 10111
System.out.println();</programlisting></sect1><sect1 id="a0000006079" remap="section">
  <title>CodingBat Problems</title>
    <para>In the past several chapters you’ve seen methods, conditions, loops, strings, arrays, and recursion. A great resource for practicing all of these concepts is <ulink url="https://codingbat.com/"></ulink>. </para><para><indexterm>
  <primary>CodingBat</primary>

</indexterm>CodingBat is a free website of programming problems developed by Nick Parlante, a Computer Science lecturer at Stanford University. As you work on these problems, CodingBat saves your progress (if you create an account). </para><para>To conclude this chapter, we consider two problems in the Recursion-1 section of CodingBat. One of them deals with strings, and the other deals with arrays. Both of them have the same recursive idea: check the base case, look at the current index, and recursively handle the rest. </para><para>The first problem is available at <ulink url="https://codingbat.com/prob/p118230"></ulink>: </para><blockquote remap="quote"><para> <emphasis role="bold">Recursion-1  noX</emphasis> </para><para>Given a string, compute recursively a new string where all the <literal>’x’</literal> chars have been removed. </para><para>noX("xaxb") <emphasis role="math">→</emphasis> "ab" noX("abc") <emphasis role="math">→</emphasis> "abc" noX("xx") <emphasis role="math">→</emphasis> "" </para></blockquote><para>When solving recursive problems, it helps to think about the base case first. The base case is the easiest version of the problem; for <literal>noX</literal>, it’s the empty string. If the argument is an empty string, there are no <literal>x</literal>’s to be removed. </para><programlisting language="java">
if (str.length() == 0) {
    return "";
}</programlisting><para>Next comes the more difficult part. To solve a problem recursively, you need to think of a simpler instance of the same problem. For <literal>noX</literal>, it’s removing all the <literal>x</literal>’s from a shorter string. </para><para>So let’s split the string into two parts, the first letter and the rest. </para><programlisting language="java">
char first = str.charAt(0);
String rest = str.substring(1);</programlisting><para>Now we can make a recursive call to remove the <literal>x</literal>’s from <literal>rest</literal>: </para><programlisting language="java">
String recurse = noX(rest);</programlisting><para>If <literal>first</literal> happens to be an <literal>x</literal>, we’re done; we just have to return <literal>recurse</literal>. Otherwise, we have to concatenate <literal>first</literal> and <literal>recurse</literal>. Here’s the <literal>if</literal> statement we need. </para><programlisting language="java">
if (first == 'x') {
    return recurse;
} else {
    return first + recurse;
}</programlisting><para>You can run this solution on CodingBat by pasting these snippets into the provided method definition. </para><para>The second problem is available at <ulink url="https://codingbat.com/prob/p135988"></ulink>: </para><blockquote remap="quote"><para> <emphasis role="bold">Recursion-1  array11</emphasis> </para><para>Given an array of ints, compute recursively the number of times that the value 11 appears in the array. </para><para>array11([1, 2, 11], 0) <emphasis role="math">→</emphasis> 1 array11([11, 11], 0) <emphasis role="math">→</emphasis> 2 array11([1, 2, 3, 4], 0) <emphasis role="math">→</emphasis> 0 </para></blockquote><para>This problem uses the convention of passing the index as an argument. So the base case is when we’ve reached the end of the array. At that point, we know there are no more <literal>11</literal>’s. </para><programlisting language="java">
if (index &gt;= nums.length) {
    return 0;
}</programlisting><para>Next we look at the current number (based on the given index), and check if it’s an <literal>11</literal>. After that, we can recursively check the rest of the array. Similar to the noX problem, we look at only one integer per method call. </para><programlisting language="java">
int recurse = array11(nums, index + 1);
if (nums[index] == 11) {
    return recurse + 1;
} else {
    return recurse;
}</programlisting><para>Again, you can run this solutions on CodingBat by pasting the snippets into the method definition. </para><para><indexterm>
  <primary>Java Tutor</primary>

</indexterm>To see how these solutions actually work, you might find it helpful to step through them with a debugger (see <xref linkend="debugger" />) or Java Tutor (<ulink url="https://thinkjava.org/javatutor"></ulink>). Then try solving other CodingBat problems on your own. </para><para>Learning to think recursively is an important part of learning to think like a computer scientist. Many algorithms can be written concisely with recursive methods that perform computations on the way down, on the way up, or both. </para>
</sect1><sect1 id="a0000006180" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>iterative:</term>
      <listitem><para><indexterm>
  <primary>iterative</primary>

</indexterm>A method or algorithm that repeats steps using one or more loops. </para></listitem>
  </varlistentry><varlistentry>
    <term>recursive:</term>
      <listitem><para><indexterm>
  <primary>recursive</primary>

</indexterm>A method or algorithm that invokes itself one or more times with different arguments. </para></listitem>
  </varlistentry><varlistentry>
    <term>base case:</term>
      <listitem><para><indexterm>
  <primary>base case</primary>

</indexterm>A condition that causes a recursive method <emphasis>not</emphasis> to make another recursive call. </para></listitem>
  </varlistentry><varlistentry>
    <term>factorial:</term>
      <listitem><para><indexterm>
  <primary>factorial</primary>

</indexterm>The product of all the integers up to and including a given integer. </para></listitem>
  </varlistentry><varlistentry>
    <term>leap of faith:</term>
      <listitem><para><indexterm>
  <primary>leap of faith</primary>

</indexterm>A way to read recursive programs by assuming that the recursive call works, rather than following the flow of execution. </para></listitem>
  </varlistentry><varlistentry>
    <term>binary:</term>
      <listitem><para><indexterm>
  <primary>binary</primary>

</indexterm>A system that uses only zeros and ones to represent numbers. Also known as “base 2”. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000006197" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch08</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>If you have not already read <xref linkend="JUnit" />, now might be a good time. It describes JUnit, a standard framework for writing test code. </para><para><example id="a0000006209" role="exercise">
  <title></title>
  <para>The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods. Consider the first verse of the song “99 Bottles of Beer”: </para><blockquote remap="quote"><para> 99 bottles of beer on the wall,99 bottles of beer,ya’ take one down, ya’ pass it around,98 bottles of beer on the wall. </para></blockquote><para>Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse: </para><blockquote remap="quote"><para> No bottles of beer on the wall,no bottles of beer,ya’ can’t take one down, ya’ can’t pass it around,’cause there are no more bottles of beer on the wall! </para></blockquote><para>And then the song (finally) ends. </para><para>Write a program that displays the entire lyrics of “99 Bottles of Beer”. Your program should include a recursive method that does the hard part, but you might want to write additional methods to separate other parts of the program. As you develop your code, test it with a small number of verses, like <literal>3</literal>. </para>
</example> </para><para><example id="a0000006227" role="exercise">
  <title></title>
  <para>Write a recursive method named <literal>oddSum</literal> that takes a positive odd integer <literal>n</literal> and returns the sum of odd integers from 1 to n. Start with a base case, and use temporary variables to debug your solution. You might find it helpful to print the value of <literal>n</literal> each time <literal>oddSum</literal> is invoked. </para>
</example> </para><para><example id="a0000006238" role="exercise">
  <title></title>
  <para>In this exercise, you will use a stack diagram to understand the execution of the following recursive method. </para><programlisting language="java">
public static void main(String[] args) {
    System.out.println(prod(1, 4));
}

public static int prod(int m, int n) {
    if (m == n) {
        return n;
    } else {
        int recurse = prod(m, n - 1);
        int result = n * recurse;
        return result;
    }
}</programlisting><orderedlist>
  
  <listitem><para>Draw a stack diagram showing the state of the program just before the last invocation of <literal>prod</literal> completes. </para></listitem>
  
  <listitem><para>What is the output of this program? (Try to answer this question on paper first, then run the code to check your answer.) </para></listitem>
  
  <listitem><para>Explain in a few words what <literal>prod</literal> does (without getting into the details of how it works). </para></listitem>
  
  <listitem><para>Rewrite <literal>prod</literal> without the temporary variables <literal>recurse</literal> and <literal>result</literal>. <emphasis>Hint:</emphasis> You only need one line for the <literal>else</literal> branch. </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000006267" role="exercise">
  <title></title>
  <para>The goal of this exercise is to translate a recursive definition into a Java method. The Ackermann function is defined for non-negative integers as follows: </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>A</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfenced open="{" close="" separators=""><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="4.pt"></mml:mspace><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>A</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="4.pt"></mml:mspace><mml:mi>m</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mspace width="4.pt"></mml:mspace><mml:mtext>and</mml:mtext><mml:mspace width="4.pt"></mml:mspace><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>A</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="4.pt"></mml:mspace><mml:mi>m</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mspace width="4.pt"></mml:mspace><mml:mtext>and</mml:mtext><mml:mspace width="4.pt"></mml:mspace><mml:mi>n</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></informalequation><para>Write a recursive method called <literal>ack</literal> that takes two <literal>int</literal>s as parameters and that computes and returns the value of the Ackermann function. </para><para>Test your implementation of Ackermann by invoking it from <literal>main</literal> and displaying the return value. Note the return value gets very big very quickly. You should try it only for small values of <emphasis role="math">m</emphasis> and <emphasis role="math">n</emphasis> (not bigger than 3). </para>
</example> </para><para><example id="ex.power" role="exercise">
  <title></title><para>Write a recursive method called <literal>power</literal> that takes a double <literal>x</literal> and an integer <literal>n</literal> and returns <emphasis role="math">x<superscript>n</superscript></emphasis>. </para><para><emphasis>Hint:</emphasis> A recursive definition of this operation is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>·</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inlineequation>. Also, remember that anything raised to the zeroth power is 1. </para><para>Optional challenge: you can make this method more efficient, when <literal>n</literal> is even, using <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mfenced open="(" close=")" separators=""><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inlineequation>. </para>
</example> </para><para><example id="a0000006335" role="exercise">
  <title></title>
  <para>Many of the patterns we have seen for traversing arrays can also be written recursively. It is not common, but it is a useful exercise. </para><orderedlist>
  
  <listitem><para>Write a method called <literal>maxInRange</literal> that takes an array of integers and two indexes, <literal>lowIndex</literal> and <literal>highIndex</literal>, and finds the maximum value in the array, but only considering the elements between <literal>lowIndex</literal> and <literal>highIndex</literal>, including both. </para><para>This method should be recursive. If the length of the range is 1, that is, if <literal>lowIndex == highIndex</literal>, we know immediately that the sole element in the range must be the maximum. So that’s the base case. </para><para>If there is more than one element in the range, we can break the array into two pieces, find the maximum in each of the pieces, and then find the maximum of the maxima. </para></listitem>
  
  <listitem><para>Methods like <literal>maxInRange</literal> can be awkward to use. To find the largest element in an array, we have to provide the range for the entire array. </para><programlisting language="java">
double max = maxInRange(a, 0, a.length - 1);</programlisting><para>Write a method called <literal>max</literal> that takes an array and uses <literal>maxInRange</literal> to find and return the largest element. </para></listitem>
  
</orderedlist>
</example> </para><para><beginpage></beginpage><example id="a0000006368" role="exercise">
  <title></title>
  <para>Create a program called <literal>Recurse.java</literal> and type in the following methods: </para><programlisting language="java">
/**
 * Returns the first character of the given String.
 */
public static char first(String s) {
    return s.charAt(0);
}</programlisting><programlisting language="java">
/**
 * Returns all but the first letter of the given String.
 */
public static String rest(String s) {
    return s.substring(1);
}</programlisting><programlisting language="java">
/**
 * Returns all but the first and last letter of the String.
 */
public static String middle(String s) {
    return s.substring(1, s.length() - 1);
}</programlisting><programlisting language="java">
/**
 * Returns the length of the given String.
 */
public static int length(String s) {
    return s.length();
}</programlisting><orderedlist>
  
  <listitem><para>Write some code in <literal>main</literal> that tests each of these methods. Make sure they work, and you understand what they do. </para></listitem>
  
  <listitem><para>Using these methods, and without using any other <literal>String</literal> methods, write a method called <literal>printString</literal> that takes a string as a parameter and that displays the letters of the string, one on each line. It should be a void method. </para></listitem>
  
  <listitem><para>Again using only these methods, write a method called <literal>printBackward</literal> that does the same thing as <literal>printString</literal> but that displays the string backward (again, one character per line). </para></listitem>
  
  <listitem><para>Now write a method called <literal>reverseString</literal> that takes a string as a parameter and that returns a new string as a return value. The new string should contain the same letters as the parameter, but in reverse order. </para><programlisting language="java">
String backwards = reverseString("coffee");
System.out.println(backwards);</programlisting><para>The output of this example code should be: </para><programlisting>eeffoc</programlisting><indexterm>
  <primary>palindrome</primary>

</indexterm></listitem>
  
  <listitem><para>A palindrome is a word that reads the same both forward and backward, like “otto” and “palindromeemordnilap”. Here’s one way to test whether a string is a palindrome: </para><blockquote remap="quotation"><para> A single letter is a palindrome, a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome. </para></blockquote><para>Write a recursive method named <literal>isPalindrome</literal> that takes a <literal>String</literal> and returns a <literal>boolean</literal> indicating whether the word is a palindrome. </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</chapter><chapter id="immutable">
  <title>Immutable Objects</title><para><indexterm>
  <primary>object-oriented</primary>

</indexterm>Java is an <emphasis role="bold">object-oriented</emphasis> language, which means that it uses objects to (1) represent data and (2) provide methods related to them. This way of organizing programs is a powerful design concept, and we will introduce it gradually throughout the remainder of the book. </para><para><indexterm>
  <primary>object</primary>

</indexterm><indexterm>
  <primary>System.in</primary>

</indexterm><indexterm>
  <primary>System.out</primary>

</indexterm>An <emphasis role="bold">object</emphasis> is a collection of data that provides a set of methods. For example, <literal>Scanner</literal>, which we saw in <xref linkend="scanner" />, is an object that provides methods for parsing input. <literal>System.out</literal> and <literal>System.in</literal> are also objects. </para><para>Strings are objects, too. They contain characters and provide methods for manipulating character data. Other data types, like <literal>Integer</literal>, contain numbers and provide methods for manipulating number data. We will explore some of these methods in this chapter. </para><sect1 id="a0000006443" remap="section">
  <title>Primitives vs Objects</title>
    <para><indexterm>
  <primary>primitive</primary>

</indexterm>Not everything in Java is an object: <literal>int</literal>, <literal>double</literal>, <literal>char</literal>, and <literal>boolean</literal> are <emphasis role="bold">primitive</emphasis> types. When you declare a variable with a primitive type, Java reserves a small amount of memory to store its value. <xref linkend="fig.mem1" /> shows how the following values are stored in memory. </para><programlisting language="java">
int number = -2;
char symbol = '!';</programlisting><figure id="fig.mem1" float="False">
    <title>Memory diagram of two primitive variables.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/mem1.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>As we learned in <xref linkend="elements" />, an array variable stores a <emphasis>reference</emphasis> to an array. For example, the following line declares a variable named <literal>array</literal> and creates an array of three characters. </para><programlisting language="java">
    char[] array = {'c', 'a', 't'};</programlisting><para><xref linkend="fig.mem2" /> shows them both, with a box to represent the location of the variable and an arrow pointing to the location of the array. </para>
  
  <figure id="fig.mem2" float="False">
    <title>Memory diagram of an array of characters.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/mem2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Objects work in a similar way. For example, this line declares a <literal>String</literal> variable named <literal>word</literal> and creates a <literal>String</literal> object, as shown in <xref linkend="fig.mem3" />. </para><programlisting language="java">
String word = "dog";</programlisting><figure id="fig.mem3" float="False">
    <title>Memory diagram of a <literal>String</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/mem3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Objects and arrays are usually created with the <literal>new</literal> keyword, which allocates memory for them. For convenience, you don’t have to use <literal>new</literal> to create strings: </para><programlisting language="java">
String word = new String("dog");  // creates a string object
String word = "dog";   // implicitly creates a string object</programlisting><para><indexterm>
  <primary>string</primary>
<secondary>comparing</secondary>
</indexterm>Recall from <xref linkend="strcmp" /> that you need to use the <literal>equals</literal> method to compare strings. The <literal>equals</literal> method traverses the <literal>String</literal> objects and tests whether they contain the same characters. </para><para>To test whether two integers or other primitive types are equal, you can simply use the <literal>==</literal> operator. But two <literal>String</literal> objects with the same characters would not be considered equal in the <literal>==</literal> sense. The <literal>==</literal> operator, when applied to string variables, only tests whether they refer to the <emphasis>same</emphasis> object. </para>
</sect1><sect1 id="a0000006532" remap="section">
  <title>The null Keyword</title>
    <para>Often when you declare an object variable, you assign it to reference an object. But sometimes you want to declare variable that doesn’t refer to an object, at least initially. </para><para><indexterm>
  <primary>null</primary>

</indexterm>In Java, the keyword <literal>null</literal> is a special value that means “no object”. You can initialize object and array variables this way: </para><programlisting language="java">
String name = null;
int[] combo = null;</programlisting><para>The value <literal>null</literal> is represented in memory diagrams by a small box with no arrow, as in <xref linkend="fig.mem4" />. </para>
  
  <figure id="fig.mem4" float="False">
    <title>Memory diagram showing variables that are <literal>null</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/mem4.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>NullPointerException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>NullPointer</secondary>
</indexterm>If you try to use a variable that is <literal>null</literal> by invoking a method or accessing an element, Java throws a <literal>NullPointerException</literal>. </para><programlisting language="java">
System.out.println(name.length());  // NullPointerException
System.out.println(combo[0]);       // NullPointerException</programlisting><para>On the other hand, it is perfectly fine to pass a <literal>null</literal> reference as an argument to a method, or to receive one as a return value. In these situations, <literal>null</literal> is often used to represent a special condition or indicate an error. </para>
</sect1><sect1 id="a0000006566" remap="section">
  <title>Strings are Immutable</title>
    <para>If the Java library didn’t have a <literal>String</literal> class, we would have to use character arrays to store and manipulate text. Operations like concatenation (<literal>+</literal>), <literal>indexOf</literal>, and <literal>substring</literal> would be difficult and inconvenient. Fortunately, Java does have a <literal>String</literal> class that provides these and other methods. </para><para><indexterm>
  <primary>toUpperCase</primary>

</indexterm><indexterm>
  <primary>toLowerCase</primary>

</indexterm><indexterm>
  <primary>immutable</primary>

</indexterm>For example, the methods <literal>toLowerCase</literal> and <literal>toUpperCase</literal> convert uppercase letters to lowercase, and vice versa. These methods are often a source of confusion, because it sounds like they modify strings. But neither these methods nor any others can change a string, because strings are <emphasis role="bold">immutable</emphasis>. </para><para>When you invoke <literal>toUpperCase</literal> on a string, you get a new <literal>String</literal> object as a result. For example: </para><programlisting language="java">
String name = "Alan Turing";
String upperName = name.toUpperCase();</programlisting><para>After these statements run, <literal>upperName</literal> refers to the string <literal>"ALAN TURING"</literal>. But <literal>name</literal> still refers to <literal>"Alan Turing"</literal>. A common mistake is to assume that <literal>toUpperCase</literal> somehow affects the original string: </para><programlisting language="java">
String name = "Alan Turing";
name.toUpperCase();           // ignores the return value
System.out.println(name);</programlisting><para>The previous code displays <literal>"Alan Turing"</literal>, because the value of <literal>name</literal>, which refers to the original <literal>String</literal> object, never changes. If you want to change <literal>name</literal> to be uppercase, then you need to assign the return value: </para><programlisting language="java">
String name = "Alan Turing";
name = name.toUpperCase();    // references the new string
System.out.println(name);</programlisting><para><indexterm>
  <primary>replace</primary>

</indexterm>A similar method is <literal>replace</literal>, which finds and replaces instances of one string within another. This example replaces <literal>"Computer Science"</literal> with <literal>"CS"</literal>: </para><programlisting language="java">
String text = "Computer Science is fun!";
text = text.replace("Computer Science", "CS");</programlisting><para>As with <literal>toUpperCase</literal>, assigning the return value (to <literal>text</literal>) is important. If you don’t assign the return value, invoking <literal>text.replace</literal> has no effect. </para><para>Strings are immutable by design, because it simplifies passing them as parameters and return values. And since the contents of a string can never change, two variables can reference the same string without one accidentally corrupting the other. </para>
</sect1><sect1 id="a0000006636" remap="section">
  <title>Wrapper Classes</title>
    <para>Primitive types like <literal>int</literal>, <literal>double</literal>, and <literal>char</literal> cannot be <literal>null</literal>, and they do not provide methods. For example, you can’t invoke <literal>equals</literal> on an <literal>int</literal>: </para><programlisting language="java">
int i = 5;
System.out.println(i.equals(5));  // compiler error</programlisting><para><indexterm>
  <primary>wrapper class</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>wrapper</secondary>
</indexterm><indexterm>
  <primary>Character</primary>

</indexterm><indexterm>
  <primary>Integer</primary>

</indexterm><indexterm>
  <primary>Double</primary>

</indexterm>But for each primitive type, there is a corresponding <emphasis role="bold">wrapper class</emphasis> in the Java library. The wrapper class for <literal>int</literal> is named <literal>Integer</literal>, with a capital <literal>I</literal>. </para><programlisting language="java">
Integer i = Integer.valueOf(5);
System.out.println(i.equals(5));  // displays true</programlisting><para>Other wrapper classes include <literal>Boolean</literal>, <literal>Character</literal>, <literal>Double</literal>, and <literal>Long</literal>. They are in the <literal>java.lang</literal> package, so you can use them without importing them. </para><para>Like strings, objects from wrapper classes are immutable, and you have to use the <literal>equals</literal> method to compare them. </para><programlisting language="java">
Integer x = Integer.valueOf(123);
Integer y = Integer.valueOf(123);
if (x == y) {                     // false
    System.out.println("x and y are the same object");
}
if (x.equals(y)) {                // true
    System.out.println("x and y have the same value");
}</programlisting><para>Because <literal>x</literal> and <literal>y</literal> refer to different objects, this code only displays “x and y have the same value”. </para><para>Each wrapper class defines the constants <literal>MIN_VALUE</literal> and <literal>MAX_VALUE</literal>. For example, <literal>Integer.MIN_VALUE</literal> is <literal>-2147483648</literal>, and <literal>Integer.MAX_VALUE</literal> is <literal>2147483647</literal>. Because these constants are available in wrapper classes, you don’t have to remember them, and you don’t have to write them yourself. </para><para><indexterm>
  <primary>parse</primary>

</indexterm>Wrapper classes also provide methods for converting strings to and from primitive types. For example, <literal>Integer.parseInt</literal> converts a string to an <literal>int</literal>. In this context, <emphasis role="bold">parse</emphasis> means “read and translate”. </para><programlisting language="java">
String str = "12345";
int num = Integer.parseInt(str);</programlisting><para>Other wrapper classes provide similar methods, like <literal>Double.parseDouble</literal> and <literal>Boolean.parseBoolean</literal>. They also provide <literal>toString</literal>, which returns a string representation of a value: </para><programlisting language="java">
int num = 12345;
String str = Integer.toString(num);</programlisting><para>The result is the <literal>String</literal> object <literal>"12345"</literal>. </para><para><indexterm>
  <primary>NumberFormatException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>NumberFormat</secondary>
</indexterm>It’s always possible to convert a primitive value to a string, but not the other way around. For example, if we try to parse an invalid string like this: </para><programlisting language="java">
String str = "five";
int num = Integer.parseInt(str);  // NumberFormatException</programlisting><para><literal>parseInt</literal> throws a <literal>NumberFormatException</literal>, because the characters in the string <literal>"five"</literal> are not digits. </para>
</sect1><sect1 id="a0000006733" remap="section">
  <title>Command-Line Arguments</title>
    <para><indexterm>
  <primary>args</primary>

</indexterm><indexterm>
  <primary>command-line interface</primary>

</indexterm>Now that you know about strings, arrays, and wrapper classes, we can <emphasis>finally</emphasis> explain the <literal>args</literal> parameter of the <literal>main</literal> method, which we have been ignoring since <xref linkend="theway" />. If you are unfamiliar with the command-line interface, please read <xref linkend="commandline" />. </para><para>Let’s write a program to find the maximum value in a sequence of numbers. Rather than read the numbers from <literal>System.in</literal> using a <literal>Scanner</literal>, we’ll pass them as command-line arguments. Here is a starting point: </para><programlisting language="java">
import java.util.Arrays;
public class Max {
    public static void main(String[] args) {
        System.out.println(Arrays.toString(args));
    }
}</programlisting><para>You can run this program from the command line by typing: </para><programlisting>java Max</programlisting><para><indexterm>
  <primary>empty array</primary>

</indexterm>The output indicates that <literal>args</literal> is an <emphasis role="bold">empty array</emphasis>; that is, it has no elements: </para><programlisting>[]</programlisting><para>If you provide additional values on the command line, they are passed as arguments to <literal>main</literal>. For example, if you run the program like this: </para><programlisting>java Max 10 -3 55 0 14</programlisting><para>The output is: </para><programlisting>[10, -3, 55, 0, 14]</programlisting><para>It’s not clear from the output, but the elements of <literal>args</literal> are strings. So <literal>args</literal> is the array <literal>{"10", "-3", "55", "0", "14"}</literal>. To find the maximum number, we have to convert the arguments to integers. </para><para>The following code uses an enhanced <literal>for</literal> loop (see <xref linkend="enhanced" />) to parse the arguments and find the largest value: </para><programlisting language="java">
int max = Integer.MIN_VALUE;
for (String arg : args) {
    int value = Integer.parseInt(arg);
    if (value &gt; max) {
        max = value;
    }
}
System.out.println("The max is " + max);</programlisting><para>We begin by initializing <literal>max</literal> to the smallest (most negative) number an <literal>int</literal> can represent. That way, the first value we parse will replace <literal>max</literal>. As we find larger values, they will replace <literal>max</literal> as well. </para><para>If <literal>args</literal> is empty, the result will be <literal>MIN_VALUE</literal>. We can prevent this situation from happening by checking <literal>args</literal> at the beginning of the program: </para><programlisting language="java">
if (args.length == 0) {
    System.err.println("Usage: java Max &lt;numbers&gt;");
    return;
}</programlisting><para>It’s customary for programs that require command-line arguments to display a “usage” message if the arguments are not valid. For example, if you run <literal>javac</literal> or <literal>java</literal> from the command line without any arguments, you will get a very long message. </para>
</sect1><sect1 id="a0000006811" remap="section">
  <title>Argument Validation</title>
    <para>As we discussed in <xref linkend="validate" />, you should never assume that program input will be in the correct format. Sometimes users make mistakes, such as pressing the wrong key or misreading instructions. </para><para><indexterm>
  <primary>hacker</primary>

</indexterm>Or even worse, someone might make intentional “mistakes” to see what your program will do. One way hackers break into computer systems is by entering malicious input that causes a program to fail. </para><para>Programmers can make mistakes too. It’s difficult to write bug-free software, especially when working in teams on large projects. </para><para><indexterm>
  <primary>validate</primary>

</indexterm>For all of these reasons, it’s good practice to validate arguments passed to methods, including the <literal>main</literal> method. In the previous section, we did this by ensuring that <literal>args.length</literal> was not zero. </para><para><indexterm>
  <primary>Character</primary>

</indexterm>As a further example, consider a method that checks whether the first word of a sentence is capitalized. We can write this method using the <literal>Character</literal> wrapper class: </para><programlisting language="java">
public static boolean isCapitalized(String str) {
    return Character.isUpperCase(str.charAt(0));
}</programlisting><para><indexterm>
  <primary>NullPointerException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>NullPointer</secondary>
</indexterm>The expression <literal>str.charAt(0)</literal> makes two assumptions: the string object referenced by <literal>str</literal> exists, and it has at least one character. What if these assumptions don’t hold at run-time? </para><itemizedlist>
  
    <listitem><para>If <literal>str</literal> is <literal>null</literal>, invoking <literal>charAt</literal> will cause a <literal>NullPointerException</literal>, because you can’t invoke a method on <literal>null</literal>. </para></listitem>
  
    <listitem><para>If <literal>str</literal> refers to an empty string, which is a <literal>String</literal> object with no characters, <literal>charAt</literal> will cause a <literal>StringIndexOutOfBoundsException</literal>, because there is no character at index <literal>0</literal>. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>StringIndexOutOfBoundsException</primary>

</indexterm><indexterm>
  <primary>exception</primary>
<secondary>StringIndexOutOfBounds</secondary>
</indexterm>We can prevent these exceptions by validating <literal>str</literal> <emphasis>at the start</emphasis> of the method. If it’s invalid, we return before executing the rest of the method. </para><programlisting language="java">
public static boolean isCapitalized(String str) {
    if (str == null || str.isEmpty()) {
        return false;
    }
    return Character.isUpperCase(str.charAt(0));
}</programlisting><para>Notice that <literal>null</literal> and “empty” are different concepts, as shown in <xref linkend="fig.nullempty" />. The variable <literal>str1</literal> is <literal>null</literal>, meaning that it doesn’t reference an object. The variable <literal>str2</literal> refers to the empty string, an object that exists. </para>
  
  <figure id="fig.nullempty" float="False">
    <title>Memory diagram of <literal>null</literal> and empty string.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/nullempty.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Beginners sometimes make the mistake of checking for empty first. Doing so causes a <literal>NullPointerException</literal>, because you can’t invoke methods on variables that are <literal>null</literal>. </para><programlisting language="java">
if (str.isEmpty() || str == null) {    // wrong!</programlisting><para><indexterm>
  <primary>short circuit</primary>

</indexterm>Checking for <literal>null</literal> first prevents the <literal>NullPointerException</literal>. If <literal>str</literal> is <literal>null</literal>, the <literal>||</literal> operator will short circuit (see <xref linkend="shortcircuit" />) and evaluate to <literal>true</literal> immediately. As a result, <literal>str.isEmpty()</literal> will not be called. </para>
</sect1><sect1 id="a0000006914" remap="section">
  <title>BigInteger Arithmetic</title>
    <para>It might not be clear at this point why you would ever need an integer object when you can just use an <literal>int</literal> or <literal>long</literal>. One advantage is the variety of methods that <literal>Integer</literal> and <literal>Long</literal> provide. But there is another reason: when you need very large integers that exceed <literal>Long.MAX_VALUE</literal>. </para><para><indexterm>
  <primary>BigInteger</primary>

</indexterm><literal>BigInteger</literal> is a Java class that can represent arbitrarily large integers. There is no upper bound except the limitations of memory size and processing speed. Take a minute to read the documentation, which you can find by doing a web search for “Java BigInteger”. </para><para><indexterm>
  <primary>java.math</primary>

</indexterm>To use BigIntegers, you have to <literal>import java.math.BigInteger</literal> at the beginning of your program. There are several ways to create a BigInteger, but the simplest uses <literal>valueOf</literal>. The following code converts a <literal>long</literal> to a BigInteger: </para><programlisting language="java">
long x = 17;
BigInteger big = BigInteger.valueOf(x);</programlisting><para>You can also create BigIntegers from strings. For example, here is a 20-digit integer that is too big to store using a <literal>long</literal>. </para><programlisting language="java">
String s = "12345678901234567890";
BigInteger bigger = new BigInteger(s);</programlisting><para>Notice the difference in the previous two examples: you use <literal>valueOf</literal> to convert integers, and <literal>new BigInteger</literal> to convert strings. </para><para>Since BigIntegers are not primitive types, the usual math operators don’t work. Instead, we have to use methods like <literal>add</literal>. To add two BigIntegers, we invoke <literal>add</literal> on one and pass the other as an argument. </para><programlisting language="java">
BigInteger a = BigInteger.valueOf(17);
BigInteger b = BigInteger.valueOf(1700000000);
BigInteger c = a.add(b);</programlisting><para>Like strings, <literal>BigInteger</literal> objects are immutable. Methods like <literal>add</literal>, <literal>multiply</literal>, and <literal>pow</literal> all return new BigIntegers, rather than modify an existing one. </para><para>Internally, a BigInteger is implemented using an array of <literal>int</literal>s, similar to the way a string is implemented using an array of <literal>char</literal>s. Each <literal>int</literal> in the array stores a portion of the BigInteger. The methods of <literal>BigInteger</literal> traverse this array to perform addition, multiplication, etc. </para><para>For very long floating-point values, take a look at <literal>java.math.BigDecimal</literal>. Interestingly, <literal>BigDecimal</literal> objects represent floating-point numbers internally using a <literal>BigInteger</literal>! </para>
</sect1><sect1 id="encapsulation" remap="section">
  <title>Incremental Design</title><para><indexterm>
  <primary>design process</primary>

</indexterm><indexterm>
  <primary>encapsulation</primary>
<secondary>and generalization</secondary>
</indexterm>One challenge of programming, especially for beginners, is figuring out how to divide a program into methods. In this section, we present a <emphasis role="bold">design process</emphasis> that allows you to divide a program into methods as you go along. The process is called “encapsulation and generalization”. The essential steps are: </para><orderedlist>
  
  <listitem><para>Write a few lines of code in <literal>main</literal> or another method, and test them. </para></listitem>
  
  <listitem><para>When they are working, wrap them in a new method, and test again. </para></listitem>
  
  <listitem><para>If it’s appropriate, replace literal values with variables and parameters. </para></listitem>
  
</orderedlist><para><indexterm>
  <primary>table</primary>
<secondary>two-dimensional</secondary>
</indexterm>To demonstrate this process, we’ll develop methods that display multiplication tables. We begin by writing and testing a few lines of code. Here is a loop that displays the multiples of two, all on one line: </para><programlisting language="java">
for (int i = 1; i &lt;= 6; i++) {
    System.out.printf("%4d", 2 * i);
}
System.out.println();</programlisting><para>Each time through the loop, we display the value of <literal>2 * i</literal>, padded with spaces so it’s four characters wide. Since we use <literal>System.out.printf</literal>, the output appears on a single line. </para><para>After the loop, we call <literal>println</literal> to print a newline character. Remember that in some environments, none of the output is displayed until the line is complete. The output of the code so far is: </para><programlisting>   2   4   6   8  10  12</programlisting><para><indexterm>
  <primary>encapsulate</primary>

</indexterm>The next step is <emphasis role="bold">encapsulation</emphasis>; that is, we “wrap” the code in a method: </para><programlisting language="java">
public static void printRow() {
    for (int i = 1; i &lt;= 6; i++) {
        System.out.printf("%4d", 2 * i);
    }
    System.out.println();
}</programlisting><para><indexterm>
  <primary>generalize</primary>

</indexterm>Finally, we generalize the method to print multiples of other numbers by replacing the constant value <literal>2</literal> with a parameter <literal>n</literal>. This step is called <emphasis role="bold">generalization</emphasis>, because it makes the method more general (less specific). </para><programlisting language="java">
public static void printRow(int n) {
    for (int i = 1; i &lt;= 6; i++) {
        System.out.printf("%4d", n * i);  // generalized n
    }
    System.out.println();
}</programlisting><para>Invoking this method with the argument <literal>2</literal> yields the same output as before. With the argument <literal>3</literal>, the output is: </para><programlisting>   3   6   9  12  15  18</programlisting><para>By now you can probably guess how we are going to display a multiplication table: we’ll invoke <literal>printRow</literal> repeatedly with different arguments. In fact, we’ll use another loop to iterate through the rows. </para><programlisting language="java">
for (int i = 1; i &lt;= 6; i++) {
    printRow(i);
}</programlisting><para>And the output looks like this: </para><programlisting>   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36</programlisting></sect1><sect1 id="a0000007043" remap="section">
  <title>More Generalization</title>
    <para>The previous result is similar to the “nested loops” approach in <xref linkend="nested" />. However, the inner loop is now encapsulated in the <literal>printRow</literal> method. We can encapsulate the outer loop in a method too: </para><programlisting language="java">
public static void printTable() {
    for (int i = 1; i &lt;= 6; i++) {
        printRow(i);
    }
}</programlisting><para>The initial version of <literal>printTable</literal> always displays six rows. We can generalize it by replacing the literal <literal>6</literal> with a parameter: </para><programlisting language="java">
public static void printTable(int rows) {
    for (int i = 1; i &lt;= rows; i++) {     // generalized rows
        printRow(i);
    }
}</programlisting><para>Here is the output of <literal>printTable(7)</literal>: </para><programlisting>   1   2   3   4   5   6
   2   4   6   8  10  12
   3   6   9  12  15  18
   4   8  12  16  20  24
   5  10  15  20  25  30
   6  12  18  24  30  36
   7  14  21  28  35  42</programlisting><para>That’s better, but it always displays the same number of columns. We can generalize more by adding a parameter to <literal>printRow</literal>: </para><programlisting language="java">
public static void printRow(int n, int cols) {
    for (int i = 1; i &lt;= cols; i++) {     // generalized cols
        System.out.printf("%4d", n * i);
    }
    System.out.println();
}</programlisting><para>Now <literal>printRow</literal> takes two parameters: <literal>n</literal> is the value whose multiples should be displayed, and <literal>cols</literal> is the number of columns. Since we added a parameter to <literal>printRow</literal>, we also have to change the line in <literal>printTable</literal> where it is invoked: </para><programlisting language="java">
public static void printTable(int rows) {
    for (int i = 1; i &lt;= rows; i++) {
        printRow(i, rows);
    }
}</programlisting><para>When this line executes, it evaluates <literal>rows</literal> and passes the value, which is 7 in this example, as an argument. In <literal>printRow</literal>, this value is assigned to <literal>cols</literal>. As a result, the number of columns equals the number of rows, so we get a square 7x7 table, instead of the previous 7x6 table. </para><para>When you generalize a method appropriately, you often find that it has capabilities you did not plan. For example, you might notice that the multiplication table is symmetric. Since <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:math></inlineequation>, all the entries in the table appear twice. You could save ink by printing half of the table, and you would only have to change <emphasis>one line</emphasis> of <literal>printTable</literal>: </para><programlisting language="java">
printRow(i, i);  // using i for both n and cols</programlisting><para>This means the length of each row is the same as its row number. The result is a triangular multiplication table. </para><programlisting>   1
   2   4
   3   6   9
   4   8  12  16
   5  10  15  20  25
   6  12  18  24  30  36
   7  14  21  28  35  42  49</programlisting><para>Generalization makes code more versatile, more likely to be reused, and sometimes easier to write. </para>
</sect1><sect1 id="a0000007100" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>object-oriented:</term>
      <listitem><para><indexterm>
  <primary>object-oriented</primary>

</indexterm>A way of organizing code and data into objects, rather than independent methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>object:</term>
      <listitem><para><indexterm>
  <primary>object</primary>

</indexterm>A collection of related data that comes with a set of methods that operate on the data. </para></listitem>
  </varlistentry><varlistentry>
    <term>primitive:</term>
      <listitem><para><indexterm>
  <primary>primitive</primary>

</indexterm>A data type that stores a single value and provides no methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>immutable:</term>
      <listitem><para><indexterm>
  <primary>immutable</primary>

</indexterm>An object that, once created, cannot be modified. Strings are immutable by design. </para></listitem>
  </varlistentry><varlistentry>
    <term>wrapper class:</term>
      <listitem><para><indexterm>
  <primary>wrapper class</primary>

</indexterm>Classes in <literal>java.lang</literal> that provide constants and methods for working with primitive types. </para></listitem>
  </varlistentry><varlistentry>
    <term>parse:</term>
      <listitem><para><indexterm>
  <primary>parse</primary>

</indexterm>To read a string and interpret or translate it. </para></listitem>
  </varlistentry><varlistentry>
    <term>empty array:</term>
      <listitem><para><indexterm>
  <primary>empty array</primary>

</indexterm>An array with no elements and a length of zero. </para></listitem>
  </varlistentry><varlistentry>
    <term>design process:</term>
      <listitem><para><indexterm>
  <primary>design process</primary>

</indexterm>A process for determining what methods a class or program should have. </para></listitem>
  </varlistentry><varlistentry>
    <term>encapsulate:</term>
      <listitem><para><indexterm>
  <primary>encapsulate</primary>

</indexterm>To wrap data inside of an object, or to wrap statements inside of a method. </para></listitem>
  </varlistentry><varlistentry>
    <term>generalize:</term>
      <listitem><para><indexterm>
  <primary>generalize</primary>

</indexterm>To replace something unnecessarily specific (like a constant value) with something appropriately general (like a variable or parameter). </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000007125" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch09</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000007134" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>concatenate</primary>

</indexterm>The point of this exercise is to explore Java types and fill in some of the details that aren’t covered in the chapter. </para><orderedlist>
  
  <listitem><para>Create a new program named <literal>Test.java</literal> and write a <literal>main</literal> method that contains expressions that combine various types using the <literal>+</literal> operator. For example, what happens when you “add” a <literal>String</literal> and a <literal>char</literal>? Does it perform character addition or string concatenation? What is the type of the result? </para></listitem>
  
  <listitem><para>Make a bigger copy of the following table and fill it in. At the intersection of each pair of types, you should indicate whether it is legal to use the <literal>+</literal> operator with these types, what operation is performed (addition or concatenation), and what the type of the result is. </para> 
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="6">
     
     <tbody>
     <row>
     
       
       <entry></entry>
     
       
       <entry><para> boolean </para></entry>
     
       
       <entry><para>  char  </para></entry>
     
       
       <entry><para>   int   </para></entry>
     
       
       <entry><para> double </para></entry>
     
       
       <entry><para> String </para></entry>
     
     </row><row>
     
       
       <entry><para>boolean </para></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para>char </para></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para>int </para></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para>double </para></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
     </row><row>
     
       
       <entry><para>String </para></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
       
       <entry></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
 </listitem>
  
  <listitem><para>Think about some of the choices the designers of Java made, based on this table. How many of the entries seem unavoidable, as if there was no other choice? How many seem like arbitrary choices from several equally reasonable possibilities? Which entries seem most problematic? </para></listitem>
  
  <listitem><para>Here’s a puzzler: normally, the statement <literal>x++</literal> is exactly equivalent to <literal>x = x + 1</literal>. But if <literal>x</literal> is a <literal>char</literal>, it’s not exactly the same! In that case, <literal>x++</literal> is legal, but <literal>x = x + 1</literal> causes an error. Try it out and see what the error message is, then see if you can figure out what is going on. </para></listitem>
  
  <listitem><para>What happens when you add <literal>""</literal> (the empty string) to the other types, for example, <literal>"" + 5</literal>? </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000007246" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>factorial</primary>

</indexterm>You might be sick of the factorial method by now, but we’re going to do one more version. </para><orderedlist>
  
  <listitem><para>Create a new program called <literal>Big.java</literal> and write an iterative version of <literal>factorial</literal> (using a <literal>for</literal> loop). </para></listitem>
  
  <listitem><para>Display a table of the integers from 0 to 30 along with their factorials. At some point around 15, you will probably see that the answers are not correct anymore. Why not? </para></listitem>
  
  <listitem><para>Convert <literal>factorial</literal> so that it performs its calculation using BigIntegers and returns a <literal>BigInteger</literal> as a result. You can leave the parameter alone; it will still be an integer. </para></listitem>
  
  <listitem><para>Try displaying the table again with your modified factorial method. Is it correct up to 30? How high can you make it go? </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000007270" role="exercise">
  <title></title>
  <para>Many encryption algorithms depend on the ability to raise large integers to a power. Here is a method that implements an efficient algorithm for integer exponentiation: </para><programlisting language="java">
public static int pow(int x, int n) {
    if (n == 0) return 1;

    // find x to the n/2 recursively
    int t = pow(x, n / 2);

    // if n is even, the result is t squared
    // if n is odd, the result is t squared times x
    if (n % 2 == 0) {
        return t * t;
    } else {
        return t * t * x;
    }
}</programlisting><para>The problem with this method is that it only works if the result is small enough to be represented by an <literal>int</literal>. Rewrite it so that the result is a <literal>BigInteger</literal>. The parameters should still be integers, though. </para><para>You should use the <literal>BigInteger</literal> methods <literal>add</literal> and <literal>multiply</literal>. But don’t use <literal>BigInteger.pow</literal>; that would spoil the fun. </para>
</example> </para><para><example id="a0000007289" role="exercise">
  <title></title>
  <para>One way to calculate <emphasis role="math">e<superscript>x</superscript></emphasis> is to use the following infinite series expansion. The <emphasis role="math">i</emphasis>th term in the series is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msup><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>!</mml:mo></mml:mrow></mml:math></inlineequation>. </para><informalequation><mml:math mode="display" overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mi>x</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>!</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>!</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>4</mml:mn><mml:mo>!</mml:mo><mml:mo>+</mml:mo><mml:mo>...</mml:mo></mml:mrow></mml:math></informalequation><orderedlist>
  
  <listitem><para><indexterm>
  <primary>efficiency</primary>

</indexterm>Write a method called <literal>myexp</literal> that takes <literal>x</literal> and <literal>n</literal> as parameters and estimates <emphasis role="math">e<superscript>x</superscript></emphasis> by adding the first <literal>n</literal> terms of this series. You can use the <literal>factorial</literal> method from <xref linkend="factorial" /> or your iterative version from the previous exercise. </para></listitem>
  
  <listitem><para>You can make this method more efficient by observing that the numerator of each term is the same as its predecessor multiplied by <literal>x</literal>, and the denominator is the same as its predecessor multiplied by <literal>i</literal>. </para><para>Use this observation to eliminate the use of <literal>Math.pow</literal> and <literal>factorial</literal>, and check that you get the same result. </para></listitem>
  
  <listitem><para>Write a method called <literal>check</literal> that takes a parameter, <literal>x</literal>, and displays <literal>x</literal>, <literal>myexp(x)</literal>, and <literal>Math.exp(x)</literal>. The output should look something like: </para><programlisting>1.0     2.708333333333333     2.718281828459045</programlisting><para>You can use the escape sequence <literal>"t"</literal> to put a tab character between columns of a table. </para></listitem>
  
  <listitem><para>Vary the number of terms in the series (the second argument that <literal>check</literal> sends to <literal>myexp</literal>) and see the effect on the accuracy of the result. Adjust this value until the estimated value agrees with the correct answer when <literal>x</literal> is 1. </para></listitem>
  
  <listitem><para>Write a loop in <literal>main</literal> that invokes <literal>check</literal> with the values 0.1, 1.0, 10.0, and 100.0. How does the accuracy of the result vary as <literal>x</literal> varies? Compare the number of digits of agreement rather than the difference between the actual and estimated values. </para></listitem>
  
  <listitem><para>Add a loop in <literal>main</literal> that checks <literal>myexp</literal> with the values -0.1, -1.0, -10.0, and -100.0. Comment on the accuracy. </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000007374" role="exercise">
  <title></title>
  <para>The goal of this exercise is to practice encapsulation and generalization using some of the examples in previous chapters. </para><orderedlist>
  
  <listitem><para>Starting with the code in <xref linkend="traversal" />, write a method called <literal>powArray</literal> that takes a <literal>double</literal> array, <literal>a</literal>, and returns a new array that contains the elements of <literal>a</literal> squared. Generalize it to take a second argument and raise the elements of <literal>a</literal> to the given power. </para></listitem>
  
  <listitem><para>Starting with the code in <xref linkend="enhanced" />, write a method called <literal>histogram</literal> that takes an <literal>int</literal> array of scores from 0 to (but not including) 100, and returns a histogram of 100 counters. Generalize it to take the number of counters as an argument. </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000007401" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>encapsulation</primary>

</indexterm><indexterm>
  <primary>generalization</primary>

</indexterm>The following code fragment traverses a string and checks whether it has the same number of open and close parentheses: </para><programlisting language="java">
String s = "((3 + 7) * 2)";
int count = 0;

for (int i = 0; i &lt; s.length(); i++) {
    char c = s.charAt(i);
    if (c == '(') {
        count++;
    } else if (c == ')') {
        count--;
    }
}

System.out.println(count);</programlisting><orderedlist>
  
  <listitem><para>Encapsulate this fragment in a method that takes a string argument and returns the final value of <literal>count</literal>. </para></listitem>
  
  <listitem><para>Test your method with multiple strings, including some that are balanced and some that are not. </para></listitem>
  
  <listitem><para>Generalize the code so that it works on any string. What could you do to generalize it more? </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</chapter><chapter id="mutable">
  <title>Mutable Objects</title><para><indexterm>
  <primary>String class</primary>

</indexterm><indexterm>
  <primary>type</primary>
<secondary>String</secondary>
</indexterm>As you learned in the previous chapter, an object is a collection of data that provides a set of methods. For example, a <literal>String</literal> is a collection of characters that provides methods like <literal>charAt</literal> and <literal>substring</literal>. </para><para>In this chapter, we’ll explore two new types of objects: <literal>Point</literal> and <literal>Rectangle</literal>. We’ll see how to write methods that take objects as parameters and produce objects as return values. </para><para>We will also take a first look at the source code for the Java library. </para><sect1 id="point" remap="section">
  <title>Point Objects</title><para><indexterm>
  <primary>coordinate</primary>

</indexterm>In math, 2D “points” are often written in parentheses with a comma separating the coordinates. For example, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> indicates the origin, and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> indicates the point <emphasis role="math">x</emphasis> units to the right and <emphasis role="math">y</emphasis> units up from the origin. </para><para><indexterm>
  <primary>AWT</primary>

</indexterm><indexterm>
  <primary>java.awt</primary>

</indexterm><indexterm>
  <primary>Point</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Point</secondary>
</indexterm>The <literal>java.awt</literal> package provides a class named <literal>Point</literal> that represents a location in a Cartesian plane. In order to use the <literal>Point</literal> class, you have to import it: </para><programlisting language="java">
import java.awt.Point;</programlisting><para><indexterm>
  <primary>new</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm>Then, to create a new point, you use the <literal>new</literal> operator: </para><programlisting language="java">
Point blank;
blank = new Point(3, 4);</programlisting><para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm><indexterm>
  <primary>declaration</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>declaration</secondary>
</indexterm><indexterm>
  <primary>reference</primary>

</indexterm>The first line declares that <literal>blank</literal> has type <literal>Point</literal>. The second line creates the new <literal>Point</literal> with the coordinates <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inlineequation>. The result of the <literal>new</literal> operator is a <emphasis>reference</emphasis> to the object. <xref linkend="fig.reference" /> shows the result. </para>
  
  <figure id="fig.reference" float="False">
    <title>Memory diagram showing a variable that refers to a <literal>Point</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/reference.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>As usual, the name of the variable <literal>blank</literal> appears outside the box, and its value appears inside the box. In this case, the value is a reference, which is represented with an arrow. The arrow points to the <literal>Point</literal> object, which contains two variables, <literal>x</literal> and <literal>y</literal>. </para><para><indexterm>
  <primary>attribute</primary>

</indexterm><indexterm>
  <primary>dot notation</primary>

</indexterm>Variables that belong to an object are called <emphasis role="bold">attributes</emphasis>. In some documentation, you also see them called “fields”. To access an attribute of an object, Java uses <emphasis role="bold">dot notation</emphasis>. For example: </para><programlisting language="java">
int x = blank.x;</programlisting><para>The expression <literal>blank.x</literal> means “go to the object <literal>blank</literal> refers to, and get the value of the attribute <literal>x</literal>.” In this case, we assign that value to a local variable named <literal>x</literal>. </para><para>There is no conflict between the local variable <literal>x</literal> and the attribute <literal>x</literal>. The purpose of dot notation is to identify <emphasis>which</emphasis> variable you are referring to unambiguously. </para><para>You can use dot notation as part of an expression. For example: </para><programlisting language="java">
System.out.println(blank.x + ", " + blank.y);
int sum = blank.x * blank.x + blank.y * blank.y;</programlisting><para>The first line displays <literal>3, 4</literal>. The second line calculates the value <literal>25</literal>. </para>
</sect1><sect1 id="a0000007522" remap="section">
  <title>Objects as Parameters</title>
    <para><indexterm>
  <primary>parameter</primary>

</indexterm><indexterm>
  <primary>object</primary>
<secondary>as parameter</secondary>
</indexterm>You can pass objects as parameters in the usual way. For example: </para><programlisting language="java">
public static void printPoint(Point p) {
    System.out.println("(" + p.x + ", " + p.y + ")");
}</programlisting><para>This method takes a point as an argument and displays its attributes in parentheses. If you invoke <literal>printPoint(blank)</literal>, it displays <literal>(3, 4)</literal>. </para><para>As another example, we can rewrite the <literal>distance</literal> method from <xref linkend="distance" /> so that it takes two <literal>Point</literal>s as parameters instead of four <literal>double</literal>s. </para><programlisting language="java">
public static double distance(Point p1, Point p2) {
    int dx = p2.x - p1.x;
    int dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
}</programlisting><para>Passing objects as parameters makes the source code more readable and less error-prone because related values are bundled together. </para><para>You actually don’t need to write a <literal>distance</literal> method, because <literal>Point</literal> objects already have one. To compute the distance between two points, we invoke <literal>distance</literal> on one and pass the other as an argument. </para><programlisting language="java">
Point p1 = new Point(0, 0);
Point p2 = new Point(3, 4);
double dist = p1.distance(p2);  // dist is 5.0</programlisting><para>It turns out you don’t need the <literal>printPoint</literal> method either. If you invoke <literal>System.out.println(blank)</literal>, it prints the type of the object and the values of the attributes: </para><programlisting>java.awt.Point[x=3,y=4]</programlisting><para><indexterm>
  <primary>toString</primary>

</indexterm><literal>Point</literal> objects provide a method called <literal>toString</literal> that returns a string representation of a point. When you call <literal>println</literal> with objects, it <emphasis>automatically</emphasis> calls <literal>toString</literal> and displays the result. </para>
</sect1><sect1 id="sec..Rectangle" remap="section">
  <title>Objects as Return Values</title><para><indexterm>
  <primary>Rectangle</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Rectangle</secondary>
</indexterm>The <literal>java.awt</literal> package also provides a class named <literal>Rectangle</literal>. To use it, you have to import it: </para><programlisting language="java">
import java.awt.Rectangle;</programlisting><para><literal>Rectangle</literal> objects are similar to points, but they have four attributes: <literal>x</literal>, <literal>y</literal>, <literal>width</literal>, and <literal>height</literal>. The following example creates a <literal>Rectangle</literal> object and makes the variable <literal>box</literal> refer to it: </para><programlisting language="java">
Rectangle box = new Rectangle(0, 0, 100, 200);</programlisting><para><xref linkend="fig.rectangle" /> shows the effect of this assignment. </para>
  
  <figure id="fig.rectangle" float="False">
    <title>Memory diagram showing a <literal>Rectangle</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/rectangle.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If you run <literal>System.out.println(box)</literal>, you get: </para><programlisting>java.awt.Rectangle[x=0,y=0,width=100,height=200]</programlisting><para>Again, <literal>println</literal> uses the <literal>toString</literal> method provided by <literal>Rectangle</literal>, which knows how to represent <literal>Rectangle</literal> objects as strings. </para><para><indexterm>
  <primary>return</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>You can also write methods that return new objects. For example, <literal>findCenter</literal> takes a <literal>Rectangle</literal> as an argument and returns a <literal>Point</literal> with the coordinates of the center of the rectangle: </para><programlisting language="java">
public static Point findCenter(Rectangle box) {
    int x = box.x + box.width / 2;
    int y = box.y + box.height / 2;
    return new Point(x, y);
}</programlisting><para>The return type of this method is <literal>Point</literal>. The last line creates a new <literal>Point</literal> object and returns a reference to it. </para>
</sect1><sect1 id="a0000007639" remap="section">
  <title>Rectangles are Mutable</title>
    <para><indexterm>
  <primary>mutable</primary>

</indexterm><indexterm>
  <primary>object</primary>
<secondary>mutable</secondary>
</indexterm>You can change the contents of an object by making an assignment to one of its attributes. For example, to “move” a rectangle without changing its size, you can modify the <literal>x</literal> and <literal>y</literal> values: </para><programlisting language="java">
Rectangle box = new Rectangle(0, 0, 100, 200);
box.x = box.x + 50;
box.y = box.y + 100;</programlisting><para>The result is shown in <xref linkend="fig.rectangle2" />. </para>
  
  <figure id="fig.rectangle2" float="False">
    <title>Memory diagram showing updated attributes.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/rectangle2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>encapsulation</primary>

</indexterm><indexterm>
  <primary>generalization</primary>

</indexterm>We can encapsulate this code in a method and generalize it to move the rectangle by any amount: </para><programlisting language="java">
public static void moveRect(Rectangle box, int dx, int dy) {
    box.x = box.x + dx;
    box.y = box.y + dy;
}</programlisting><para>The variables <literal>dx</literal> and <literal>dy</literal> indicate how far to move the rectangle in each direction. Invoking this method has the effect of modifying the <literal>Rectangle</literal> that is passed as an argument. </para><programlisting language="java">
Rectangle box = new Rectangle(0, 0, 100, 200);
moveRect(box, 50, 100);  // now at (50, 100, 100, 200)</programlisting><para>Modifying objects by passing them as arguments to methods can be useful. But it can also make debugging difficult, because it is not always clear which method invocations modify their arguments. </para><para>Java provides a number of methods that operate on <literal>Point</literal>s and <literal>Rectangle</literal>s. For example, <literal>translate</literal> has the same effect as <literal>moveRect</literal>, but instead of passing the rectangle as an argument, you use dot notation: </para><programlisting language="java">
box.translate(50, 100);</programlisting><para>This line invokes the <literal>translate</literal> method on the object that <literal>box</literal> refers to, which modifies the object. </para><para><indexterm>
  <primary>object-oriented</primary>

</indexterm>This syntax—using dot notation to invoke a method on an object, rather than passing it as a parameter—is more consistent with the style of object-oriented programming. </para>
</sect1><sect1 id="aliasing" remap="section">
  <title>Aliasing Revisited</title><para><indexterm>
  <primary>reference</primary>

</indexterm>Remember that when you assign an object to a variable, you are assigning a <emphasis>reference</emphasis> to an object. It is possible to have multiple variables that refer to the same object. For example, this code creates two variables that refer to the same <literal>Rectangle</literal>: </para><programlisting language="java">
Rectangle box1 = new Rectangle(0, 0, 100, 200);
Rectangle box2 = box1;</programlisting><para><xref linkend="fig.aliasing" /> shows the result: <literal>box1</literal> and <literal>box2</literal> refer to the same object, so any changes that affect one variable also affect the other. </para>
  
  <figure id="fig.aliasing" float="False">
    <title>Memory diagram showing two variables that refer to the same <literal>Rectangle</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/aliasing.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>For example, the following code uses <literal>grow</literal> to make <literal>box1</literal> bigger by 50 units in all directions. It decreases <literal>x</literal> and <literal>y</literal> by 50, and it increases <literal>height</literal> and <literal>width</literal> by 100: </para><programlisting language="java">
box1.grow(50, 50);                // grow box1 (alias)</programlisting><para>The result is shown in <xref linkend="fig.aliasing2" />. </para>
  
  <figure id="fig.aliasing2" float="False">
    <title>Memory diagram showing the effect of invoking <literal>grow</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/aliasing2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Now, if we print <literal>box1</literal>, we are not surprised to see that it has changed. </para><programlisting language="java">
java.awt.Rectangle[x=-50,y=-50,width=200,height=300]</programlisting><para>And if we print <literal>box2</literal>, we should not be surprised to see that it has changed, too, because it refers to the same object: </para><programlisting language="java">
java.awt.Rectangle[x=-50,y=-50,width=200,height=300]</programlisting><para>This scenario is called “aliasing” because a single object has multiple names, or aliases, that refer to it. </para><para>As you can tell from this simple example, code that involves aliasing can get confusing fast, and it can be difficult to debug. </para>
</sect1><sect1 id="src.zip" remap="section">
  <title>Java Library Source</title><para><indexterm>
  <primary>library</primary>

</indexterm><indexterm>
  <primary>source code</primary>

</indexterm>So far we have used several classes from the Java library, including <literal>System</literal>, <literal>String</literal>, <literal>Scanner</literal>, <literal>Math</literal>, and <literal>Random</literal>. These classes are written in Java, so you can read the source code to see how they work. </para><para><indexterm>
  <primary>src.zip</primary>

</indexterm>The Java library contains thousands of files, many of which are thousands of lines of code. That’s more than one person could read and understand fully, but don’t be intimidated! </para><para>Because it’s so large, the library source code is stored in a ZIP archive named <literal>src.zip</literal>. If you have Java installed on your computer, you should already have this file somewhere. </para><itemizedlist>
  
    <listitem><para>On Linux, it’s likely under: <literal remap="verb">/usr/lib/jvm/.../lib</literal> If not, you might have to install the <literal>openjdk-...-source</literal> package. </para></listitem>
  
    <listitem><para>On MacOS, it’s likely under: <literal remap="verb">/Library/Java/JavaVirtualMachines/.../Contents/Home/lib</literal> </para></listitem>
  
    <listitem><para>On Windows, it’s likely under: <literal remap="verb">C:\Program Files\Java\...\lib</literal> </para></listitem>
  
</itemizedlist><para>When you open (or unzip) the file, you will see folders that correspond to Java packages. For example, open the <literal>java</literal> folder, and then open the <literal>awt</literal> folder. (If you don’t see a <literal>java</literal> folder at first, open the <literal>java.desktop</literal> folder.) You should now see <literal>Point.java</literal> and <literal>Rectangle.java</literal>, along with the other classes in the <literal>java.awt</literal> package. </para><para>Open <literal>Point.java</literal> in your editor and skim through the file. It uses language features we haven’t discussed yet, so you probably won’t understand every line. But you can get a sense of what professional Java source code looks like by browsing through the library. </para><para><indexterm>
  <primary>documentation</primary>

</indexterm><indexterm>
  <primary>HTML</primary>

</indexterm><indexterm>
  <primary>Javadoc</primary>

</indexterm>Notice how much of <literal>Point.java</literal> is documentation (see <xref linkend="javadoc" />). Each method includes comments and tags like <literal>@param</literal> and <literal>@return</literal>. Javadoc reads these comments and generates documentation in HTML. You can see the same documentation online by doing a web search for “Java Point”. </para><para>Now take a look at the <literal>grow</literal> and <literal>translate</literal> methods in the <literal>Rectangle</literal> class. There is more to them than you may have expected. </para>
</sect1><sect1 id="UML" remap="section">
  <title>Class Diagrams</title><para>To summarize what we’ve learned so far, <literal>Point</literal> and <literal>Rectangle</literal> objects have attributes and methods. Attributes are an object’s <emphasis>data</emphasis>; methods are an object’s <emphasis>code</emphasis>. An object’s <emphasis>class</emphasis> definition specifies the attributes and methods that it has. </para><para><indexterm>
  <primary>UML</primary>

</indexterm><emphasis role="bold">Unified Modeling Language</emphasis> (UML) defines a graphical way to summarize this information. <xref linkend="fig.umlPoint" />, shows two examples, the <emphasis role="bold">UML class diagrams</emphasis> for the <literal>Point</literal> and <literal>Rectangle</literal> classes. </para>
  
  <figure id="fig.umlPoint" float="False">
    <title>UML class diagrams for <literal>Point</literal> and <literal>Rectangle</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/point-rect.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>class diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>class</secondary>
</indexterm>Each class is represented by a box with the name of the class, a list of attributes, and a list of methods. </para><para><indexterm>
  <primary>private</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>private</secondary>
</indexterm>To identify the types of attributes and parameters, UML uses a language-independent syntax, like <literal>x: int</literal> rather than Java syntax, <literal>int x</literal>. </para><para>The plus sign (<literal>+</literal>) identifies <literal>public</literal> attributes and methods. A minus sign (<literal>-</literal>) identifies <literal>private</literal> attributes and methods, which we discuss in the next chapter. </para><para>Both <literal>Point</literal> and <literal>Rectangle</literal> have additional methods; we only show the ones introduced in this chapter. </para><para>In contrast to memory diagrams, which visualize objects (and variables) at run-time, a class diagram visualizes the source code at compile-time. </para>
</sect1><sect1 id="a0000007880" remap="section">
  <title>Scope Revisited</title>
    <para><indexterm>
  <primary>scope</primary>

</indexterm>In <xref linkend="stack" />, we introduced the idea that variables have scope. The scope of a variable is the part of a program where a variable can be used. </para><para>Consider the first few lines of the <literal>Rectangle.translate</literal> method from the Java library source code: </para><programlisting language="java">
public void translate(int dx, int dy) {
    int oldv = this.x;
    int newv = oldv + dx;
    if (dx &lt; 0) {
    ...</programlisting><para>This example uses three kinds of variables: </para><orderedlist>
  
  <listitem><para>Parameters (<literal>dx</literal> and <literal>dy</literal>) </para></listitem>
  
  <listitem><para><indexterm>
  <primary>this</primary>

</indexterm>Local variables (<literal>oldv</literal> and <literal>newv</literal>) </para></listitem>
  
  <listitem><para>Attributes (<literal>this.x</literal>) </para></listitem>
  
</orderedlist><para>Parameters and local variables are created when a method is invoked, and they disappear when the method returns. They can be used anywhere inside the method, but not in other methods and not in other classes. </para><para>Attributes are created when an object is created, and they disappear when the object is destroyed. They can be used in any of the object’s methods, using the keyword <literal>this</literal>. And if they are public, they can be used in other classes via references to the object, <literal>box1.x</literal>. </para><para>When the Java compiler encounters a variable name, it searches backwards for its declaration. The compiler first looks for local variables, then parameters, then attributes. </para>
</sect1><sect1 id="a0000007917" remap="section">
  <title>Garbage Collection</title>
    <para>In the previous section, we said that attributes exist as long as the object exists. But when does an object cease to exist? Here is a simple example: </para><programlisting language="java">
Point blank = new Point(3, 4);
blank = null;</programlisting><para>The first line creates a new <literal>Point</literal> object and makes <literal>blank</literal> refer to it. The second line changes <literal>blank</literal> so that instead of referring to the object, it refers to nothing. As shown in <xref linkend="fig.reference3" />, after the second assignment, there are no references to the <literal>Point</literal> object. </para>
  
  <figure id="fig.reference3" float="False">
    <title>Memory diagram showing the effect of setting a variable to <literal>null</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/reference3.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>If there are no references to an object, there is no way to access its attributes or invoke a method on it. From the program’s point of view, it ceases to exist. However, it’s still present in the computer’s memory, taking up space. </para><para><indexterm>
  <primary>garbage collection</primary>

</indexterm>As your program runs, the system automatically looks for stranded objects and deletes them; then the space can be reused for new objects. This process is called <emphasis role="bold">garbage collection</emphasis>. </para><para>You don’t have to do anything to make garbage collection happen, and in general, you don’t have to be aware of it. But in high-performance applications, you may notice a slight delay every now and then while Java reclaims space from discarded objects. </para>
</sect1><sect1 id="a0000007946" remap="section">
  <title>Mutable vs Immutable</title>
    <para><indexterm>
  <primary>mutable</primary>

</indexterm><indexterm>
  <primary>immutable</primary>

</indexterm><literal>Point</literal>s and <literal>Rectangle</literal>s are <emphasis role="bold">mutable</emphasis> objects, because their attributes can be modified. You can modify their attributes directly, like <literal>box.x = 15</literal>, or you can invoke methods that modify their attributes, like <literal>box.translate(15, 0)</literal>. </para><para>In contrast, immutable objects like <literal>String</literal>s and <literal>Integer</literal>s cannot be modified. They don’t allow direct access to their attributes or provide methods that change them. </para><para>Immutable objects have a number of advantages that help improve the reliability and performance of programs. You can pass strings (and other immutable objects) to methods without worrying about their contents changing as a “side-effect” of the method. That makes programs easier to debug, and more reliable. </para><para>Also, two strings that contain the same characters can be stored in memory only once. That can reduces the amount of memory the program uses, and can speed it up. </para><para><indexterm>
  <primary>Surprise.java</primary>

</indexterm>In the following example, <literal>s1</literal> and <literal>s2</literal> are created differently, but they refer to equivalent strings; that is, the two strings contains the same characters. </para><programlisting language="java">
public class Surprise {
    public static void main(String[] args) {
        String s1 = "Hi, Mom!";
        String s2 = "Hi, " + "Mom!";
        if (s1 == s2) {                // true!
            System.out.println("s1 and s2 are the same");
        }
    }
}</programlisting><para>Because both strings are specified at compile time, the compiler can tell that they are equivalent. And because strings are immutable, there is no need to make two copies; the compiler can create one <literal>String</literal> and make both variables refer to it. </para><para>As a result, the test <literal>s1 == s2</literal> turns out to be true, which means that <literal>s1</literal> and <literal>s2</literal> refer to the same object. In other words, they are not just equivalent; they are identical. </para><para>Although immutable objects have some advantages, mutable objects have other advantages. Sometimes it is more efficient to modify an existing object, rather than creating a new one. And some computations can be expressed more naturally using mutation. </para><para>Neither design is always better, which is why you will see both. </para>
</sect1><sect1 id="stringbuilder" remap="section">
  <title>StringBuilder Objects</title><para>Here’s an example where mutable objects are efficient and arguably more natural: building a long string by concatenating lots of small pieces. </para><para><indexterm>
  <primary>Append.java</primary>

</indexterm>Strings are particularly inefficient for this operation. For example, consider the following program, which reads ten lines from <literal>System.in</literal> and concatenates them into a single <literal>String</literal>. </para><programlisting language="java">
String text = "";
for (int i = 0; i &lt; 10; i++) {
    String line = in.nextLine();        // new string
    text = text + line + '\n';    // two more strings
}</programlisting><para>Inside the <literal>for</literal> loop, <literal>in.nextLine()</literal> returns a new string each time it is invoked. The next line of code concatenates <literal>text</literal> and <literal>line</literal>, which creates another string, and then appends the newline character, which creates yet another string. </para><para>As a result, this loop creates 30 <literal>String</literal> objects! At the end, <literal>text</literal> refers to the most recent <literal>String</literal>. Garbage collection deletes the rest, but that’s a lot of garbage for a seemly simple program. </para><para><indexterm>
  <primary>StringBuilder</primary>

</indexterm>The Java library provides the <literal>StringBuilder</literal> class for just this reason. It’s part of the <literal>java.lang</literal> package, so you don’t need to import it. Because <literal>StringBuilder</literal> objects are mutable, they can implement concatenation more efficiently. </para><para>Here’s a version of the program that uses <literal>StringBuilder</literal>: </para><programlisting language="java">
StringBuilder text = new StringBuilder();
for (int i = 0; i &lt; 10; i++) {
    String line = in.nextLine();
    text.append(line);
    text.append('\n');
}</programlisting><para>The <literal>append</literal> method takes a <literal>String</literal> as a parameter and appends it to the end of the <literal>StringBuilder</literal>. Each time it is invoked, it modifies the <literal>StringBuilder</literal>; it doesn’t create any new objects. </para><para>The <literal>StringBuilder</literal> class also provides methods for inserting and deleting parts of strings efficiently. Programs that manipulate large amounts of text run much faster if you use <literal>StringBuilder</literal> instead of <literal>String</literal>. </para>
</sect1><sect1 id="a0000008042" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>attribute:</term>
      <listitem><para><indexterm>
  <primary>attribute</primary>

</indexterm>One of the named data items that make up an object. </para></listitem>
  </varlistentry><varlistentry>
    <term>dot notation:</term>
      <listitem><para><indexterm>
  <primary>dot notation</primary>

</indexterm>Use of the dot operator (<literal>.</literal>) to access an object’s attributes or methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>UML:</term>
      <listitem><para><indexterm>
  <primary>UML</primary>

</indexterm>Unified Modeling Language, a standard way to draw diagrams for software engineering. </para></listitem>
  </varlistentry><varlistentry>
    <term>class diagram:</term>
      <listitem><para><indexterm>
  <primary>class diagram</primary>

</indexterm>An illustration of the attributes and methods for a class. </para></listitem>
  </varlistentry><varlistentry>
    <term>garbage collection:</term>
      <listitem><para><indexterm>
  <primary>garbage collection</primary>

</indexterm>The process of finding objects that have no references and reclaiming their storage space. </para></listitem>
  </varlistentry><varlistentry>
    <term>mutable:</term>
      <listitem><para><indexterm>
  <primary>mutable</primary>

</indexterm>An object that can be modified at any time. Points and rectangles are mutable by design. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000008059" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch10</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>At this point you know enough to read <xref linkend="graphics" />, which is about simple 2D graphics and animations. During the next few chapters, you should take a detour to read this appendix and work through the exercises. </para><para><example id="a0000008071" role="exercise">
  <title></title>
  <para>The point of this exercise is to make sure you understand the mechanism for passing objects as parameters. </para><orderedlist>
  
  <listitem><para>For the following program, draw a stack diagram showing the local variables and parameters of <literal>main</literal> and <literal>riddle</literal> just before <literal>riddle</literal> returns. Use arrows to show which objects each variable references. </para></listitem>
  
  <listitem><para>What is the output of the program? </para></listitem>
  
  <listitem><para>Is the <literal>blank</literal> object mutable or immutable? How can you tell? </para></listitem>
  
</orderedlist><programlisting language="java">
public static int riddle(int x, Point p) {
    x = x + 7;
    return x + p.x + p.y;
}</programlisting><programlisting language="java">
public static void main(String[] args) {
    int x = 5;
    Point blank = new Point(1, 2);

    System.out.println(riddle(x, blank));
    System.out.println(x);
    System.out.println(blank.x);
    System.out.println(blank.y);
}</programlisting></example> </para><para><example id="a0000008094" role="exercise">
  <title></title>
  <para>The point of this exercise is to make sure you understand the mechanism for returning new objects from methods. The following code uses <literal>findCenter</literal> and <literal>distance</literal> as defined in this chapter. </para><orderedlist>
  
  <listitem><para>Draw a stack diagram showing the state of the program just before <literal>findCenter</literal> returns. Include all variables and parameters, and show the objects those variables refer to. </para></listitem>
  
  <listitem><para>Draw a stack diagram showing the state of the program just before <literal>distance</literal> returns. Show all variables, parameters, and objects. </para></listitem>
  
  <listitem><para>What is the output of this program? (Can you tell without running it?) </para></listitem>
  
</orderedlist><programlisting language="java">
public static void main(String[] args) {
    Point blank = new Point(5, 8);

    Rectangle rect = new Rectangle(0, 2, 4, 4);
    Point center = findCenter(rect);

    double dist = distance(center, blank);
    System.out.println(dist);
}</programlisting></example> </para><para><example id="a0000008115" role="exercise">
  <title></title>
  <para>This exercise is about aliasing. Recall that aliases are two variables that refer to the same object. The following code uses <literal>findCenter</literal> and <literal>printPoint</literal> as defined in this chapter. </para><orderedlist>
  
  <listitem><para>Draw a diagram that shows the state of the program just before the end of <literal>main</literal>. Include all local variables and the objects they refer to. </para></listitem>
  
  <listitem><para>What is the output of the program? </para></listitem>
  
  <listitem><para>At the end of <literal>main</literal>, are <literal>p1</literal> and <literal>p2</literal> aliased? Why or why not? </para></listitem>
  
</orderedlist><programlisting language="java">
public static void main(String[] args) {
    Rectangle box1 = new Rectangle(2, 4, 7, 9);
    Point p1 = findCenter(box1);
    printPoint(p1);

    box1.grow(1, 1);
    Point p2 = findCenter(box1);
    printPoint(p2);
}</programlisting></example> </para>
</sect1>
</chapter><chapter id="a0000008139">
  <title>Designing Classes</title>
  <para><indexterm>
  <primary>object</primary>
<secondary>type</secondary>
</indexterm><indexterm>
  <primary>type</primary>
<secondary>object</secondary>
</indexterm>Whenever you create a new class, you are creating a new object type with the same name. So way back in <xref linkend="hello" />, when we created the class <literal>Hello</literal>, we also created an object type named <literal>Hello</literal>. </para><para>We didn’t declare any variables with type <literal>Hello</literal>, and we didn’t use <literal>new</literal> to create <literal>Hello</literal> objects. And it wouldn’t have done much good if we had—but we could have! </para><para>In this chapter, you will learn to design classes that represent <emphasis>useful</emphasis> objects. Here are the main ideas: </para><itemizedlist>
  
    <listitem><para><indexterm>
  <primary>class</primary>
<secondary>definition</secondary>
</indexterm>Again, defining a <emphasis role="bold">class</emphasis> creates a new object type with the same name. </para></listitem>
  
    <listitem><para><indexterm>
  <primary>instance</primary>

</indexterm>A class definition is a template for objects: it specifies what attributes the objects have and what methods can operate on them. </para></listitem>
  
    <listitem><para><indexterm>
  <primary>instantiate</primary>

</indexterm>Every object belongs to some object type; that is, it is an <emphasis role="bold">instance</emphasis> of some class. </para></listitem>
  
    <listitem><para>The <literal>new</literal> operator <emphasis role="bold">instantiates</emphasis> objects; that is, it creates new instances of a class. </para></listitem>
  
</itemizedlist><para>Think of a class like a blueprint for a house: you can use the same blueprint to build any number of houses. </para><sect1 id="a0000008180" remap="section">
  <title>The Time Class</title>
    <para>A common reason to define a new class is to encapsulate related data in an object that can be treated as a single unit. That way, we can use objects as parameters and return values, rather than passing and returning multiple values. We have already seen two types that encapsulate data in this way: <literal>Point</literal> and <literal>Rectangle</literal>. </para><para><indexterm>
  <primary>class</primary>
<secondary>Time</secondary>
</indexterm><indexterm>
  <primary>Time</primary>

</indexterm>Another example, which we will implement ourselves, is <literal>Time</literal>, which represents a time of day. The data encapsulated in a <literal>Time</literal> object include an hour, a minute, and a number of seconds. Because every <literal>Time</literal> object contains these values, we define attributes to hold them. </para><para><indexterm>
  <primary>instance variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>instance</secondary>
</indexterm>Attributes are also called <emphasis role="bold">instance variables</emphasis>, because each instance has its own variables (as opposed to “class variables”, coming up in <xref linkend="classvar" />). </para><para>The first step is to decide what type each variable should be. It seems clear that <literal>hour</literal> and <literal>minute</literal> should be integers. Just to keep things interesting, let’s make <literal>second</literal> a double. </para><para>Instance variables are declared at the beginning of the class definition, outside of any method. By itself, this code fragment is a legal class definition: </para><programlisting language="java">
public class Time {
    private int hour;
    private int minute;
    private double second;
}</programlisting><para><indexterm>
  <primary>private</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>private</secondary>
</indexterm>The <literal>Time</literal> class is <literal>public</literal>, which means that it can be used in other classes. But the instance variables are <literal>private</literal>, which means they can only be accessed from inside the <literal>Time</literal> class. If you try to read or write them from another class, you will get a compiler error. </para><para><indexterm>
  <primary>information hiding</primary>

</indexterm>Private instance variables help keep classes isolated from each other, so that changes in one class won’t require changes in other classes. It also simplifies what other programmers need to know to use your classes. This kind of isolation is called <emphasis role="bold">information hiding</emphasis>. </para>
</sect1><sect1 id="a0000008224" remap="section">
  <title>Constructors</title>
    <para><indexterm>
  <primary>static</primary>

</indexterm><indexterm>
  <primary>constructor</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>constructor</secondary>
</indexterm>After declaring instance variables, the next step is to define a <emphasis role="bold">constructor</emphasis>, which is a special method that initializes the object. The syntax for constructors is similar to that of other methods, except: </para><itemizedlist>
  
    <listitem><para>The name of the constructor is the same as the name of the class. </para></listitem>
  
    <listitem><para>Constructors have no return type (and no return value). </para></listitem>
  
    <listitem><para>The keyword <literal>static</literal> is omitted. </para></listitem>
  
</itemizedlist><para>Here is an example constructor for the <literal>Time</literal> class: </para><programlisting language="java">
public Time() {
    this.hour = 0;
    this.minute = 0;
    this.second = 0.0;
}</programlisting><para>This constructor does not take any arguments. Each line initializes an instance variable to zero (which is “midnight” for a <literal>Time</literal> object). </para><para><indexterm>
  <primary>this</primary>

</indexterm><indexterm>
  <primary>keyword</primary>

</indexterm>The name <literal>this</literal> is a keyword that refers to the object we are creating. You can use <literal>this</literal> the same way you use the name of any other object. For example, you can read and write the instance variables of <literal>this</literal>, and you can pass <literal>this</literal> as an argument to other methods. But you do not declare <literal>this</literal>, and you can’t make an assignment to it. </para><para>A common error when writing constructors is to put a <literal>return</literal> statement at the end. Like <literal>void</literal> methods, constructors do not return values. </para><para>To create a <literal>Time</literal> object, you must use the <literal>new</literal> operator: </para><programlisting language="java">
public static void main(String[] args) {
    Time time = new Time();
}</programlisting><para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm><indexterm>
  <primary>new</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>new</secondary>
</indexterm>When you use <literal>new</literal>, Java creates the object and invokes your constructor to initialize the instance variables. When the constructor is done, <literal>new</literal> returns a reference to the new object. In this example, the reference gets assigned to the variable <literal>time</literal>, which has type <literal>Time</literal>. <xref linkend="fig.time" /> shows the result. </para>
  
  <figure id="fig.time" float="False">
    <title>Memory diagram of a <literal>Time</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/time.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>recursion</primary>
<secondary>infinite</secondary>
</indexterm><indexterm>
  <primary>infinite recursion</primary>

</indexterm><indexterm>
  <primary>StackOverflowError</primary>

</indexterm>Beginners sometimes make the mistake of using <literal>new</literal> in the constructor: </para><programlisting language="java">
public Time() {
    new Time();         // StackOverflowError
    this.hour = 0;
    this.minute = 0;
    this.second = 0.0;
}</programlisting><para>Doing so causes an infinite recursion, since <literal>new</literal> invokes the <emphasis>same</emphasis> constructor, which uses <literal>new</literal> again, which invokes the constructor again, and so on. </para>
</sect1><sect1 id="a0000008306" remap="section">
  <title>Value Constructors</title>
    <para><indexterm>
  <primary>overload</primary>

</indexterm>Like other methods, constructors can be overloaded, which means you can provide multiple constructors with different parameters. Java knows which constructor to invoke by matching the arguments you provide with the parameters of the constructor. </para><para><indexterm>
  <primary>value constructor</primary>

</indexterm><indexterm>
  <primary>constructor</primary>
<secondary>value</secondary>
</indexterm>It is common to provide both a “default constructor” that takes no arguments, like the previous one, and a “value constructor”, like this one: </para><programlisting language="java">
public Time(int hour, int minute, double second) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
}</programlisting><para>To invoke this constructor, you have to provide arguments to the <literal>new</literal> operator. The following example creates a <literal>Time</literal> object that represents a fraction of a second before noon: </para><programlisting language="java">
Time time = new Time(11, 59, 59.9);</programlisting><para>Overloading constructors provides the flexibility to create an object first and then fill in the attributes, or collect all the information before creating the object itself. </para><para>Once you get the hang of it, writing constructors gets boring. You can write them quickly just by looking at the list of instance variables. In fact, some IDEs can generate them for you. </para><para>Here is the complete class definition so far: </para><programlisting language="java">
public class Time {
    private int hour;
    private int minute;
    private double second;

    public Time() {
        this.hour = 0;
        this.minute = 0;
        this.second = 0.0;
    }

    public Time(int hour, int minute, double second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }
}</programlisting><para>Notice how the second constructor declares the parameters <literal>hour</literal>, <literal>minute</literal>, and <literal>second</literal>. Java allows you to declare parameters (and local variables) with the same names as instance variables. They don’t have to use the same names, but it’s common practice. </para><para><indexterm>
  <primary>shadowing</primary>

</indexterm>The right side of <literal>this.hour = hour;</literal> refers to the parameter <literal>hour</literal>, since it was declared most recently. This situation is called <emphasis role="bold">shadowing</emphasis>, because the parameter “hides” the instance variable with the same name. </para><para>Java provides the keyword <literal>this</literal> so you can access instance variables, regardless of shadowing. As a result, this constructor copies the values from the parameters to the instance variables. </para>
</sect1><sect1 id="a0000008343" remap="section">
  <title>Getters and Setters</title>
    <para>Recall that the instance variables of <literal>Time</literal> are <literal>private</literal>. We can access them from within the <literal>Time</literal> class, but if we try to read or write them from another class, the compiler reports an error. </para><para><indexterm>
  <primary>client</primary>

</indexterm><indexterm>
  <primary>private</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>private</secondary>
</indexterm>A class that uses objects defined in another class is called a <emphasis role="bold">client</emphasis>. For example, here is a new class called <literal>TimeClient</literal>. </para><programlisting language="java">
public class TimeClient {

    public static void main(String[] args) {
        Time time = new Time(11, 59, 59.9);
        System.out.println(time.hour);      // compiler error
    }
}</programlisting><para>If you compile this code, you get an error message like “hour has private access in Time”. There are three ways to solve this problem: </para><itemizedlist>
  
    <listitem><para>We could make the instance variables public. </para></listitem>
  
    <listitem><para>We could provide methods to access the instance variables. </para></listitem>
  
    <listitem><para>We could decide that it’s not a problem, and refuse to let other classes access the instance variables. </para></listitem>
  
</itemizedlist><para>The first choice is appealing because it’s simple. But here is the problem: when Class <emphasis role="math">A</emphasis> accesses the instance variables of Class <emphasis role="math">B</emphasis> directly, <emphasis role="math">A</emphasis> becomes dependent on <emphasis role="math">B</emphasis>. If anything in <emphasis role="math">B</emphasis> changes later, it is likely that <emphasis role="math">A</emphasis> will have to change, too. </para><para><indexterm>
  <primary>dependent</primary>

</indexterm><indexterm>
  <primary>independent</primary>

</indexterm>But if <emphasis role="math">A</emphasis> only uses methods to interact with <emphasis role="math">B</emphasis>, <emphasis role="math">A</emphasis> and <emphasis role="math">B</emphasis> are less dependent, which means that we can make changes in <emphasis role="math">B</emphasis> without affecting <emphasis role="math">A</emphasis> (as long as we don’t change the method parameters). So we generally avoid making instance variables public. </para><para>The second option is to provide methods that access the instance variables. For example, we might want the instance variables to be “read only”; that is, code in other classes should be able to read them but not write them. We can do that by providing one method for each instance variable: </para><programlisting language="java">
public int getHour() {
    return this.hour;
}

public int getMinute() {
    return this.minute;
}

public double getSecond() {
    return this.second;
}</programlisting><para><indexterm>
  <primary>accessor</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>accessor</secondary>
</indexterm><indexterm>
  <primary>getter</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>getter</secondary>
</indexterm>Methods like these are formally called “accessors”, but more commonly referred to as <emphasis role="bold">getters</emphasis>. By convention, the method that gets a variable named <literal>something</literal> is called <literal>getSomething</literal>. </para><para>We can fix the compiler error in <literal>TimeClient</literal> by using the getter: </para><programlisting language="java">
System.out.println(time.getHour());</programlisting><para>If we decide that <literal>TimeClient</literal> should also be able to modify the instance variables of <literal>Time</literal>, we can provide methods to do that, too: </para><programlisting language="java">
public void setHour(int hour) {
    this.hour = hour;
}

public void setMinute(int minute) {
    this.minute = minute;
}

public void setSecond(double second) {
    this.second = second;
}</programlisting><para><indexterm>
  <primary>mutator</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>mutator</secondary>
</indexterm><indexterm>
  <primary>setter</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>setter</secondary>
</indexterm>These methods are formally called “mutators”, but more commonly known as <emphasis role="bold">setters</emphasis>. The naming convention is similar; the method that sets <literal>something</literal> is usually called <literal>setSomething</literal>. </para><para>Writing getters and setters can get boring, but many IDEs can generate them for you based on the instance variables. </para>
</sect1><sect1 id="a0000008416" remap="section">
  <title>Displaying Objects</title>
    <para>To display <literal>Time</literal> objects we can write a method to display the hour, minute, and second. Using <literal>printTime</literal> in <xref linkend="multparam" /> as a starting point, we could write: </para><programlisting language="java">
public static void printTime(Time t) {
    System.out.print(t.hour);
    System.out.print(":");
    System.out.print(t.minute);
    System.out.print(":");
    System.out.println(t.second);
}</programlisting><para><indexterm>
  <primary>printf</primary>

</indexterm><indexterm>
  <primary>print statement</primary>

</indexterm><indexterm>
  <primary>format string</primary>

</indexterm>The output of this method, given the <literal>time</literal> object from the first example, would be <literal>11:59:59.9</literal>. We can use <literal>printf</literal> to make the code more concise: </para><programlisting language="java">
public static void printTime(Time t) {
    System.out.printf("%02d:%02d:%04.1f\n",
        t.hour, t.minute, t.second);
}</programlisting><para>As a reminder, you need to use <literal>%d</literal> with integers and <literal>%f</literal> with floating-point numbers. The <literal>02</literal> option means “total width 2, with leading zeros if necessary”, and the <literal>04.1</literal> option means “total width 4, one digit after the decimal point, leading zeros if necessary”. The output is the same: <literal>11:59:59.9</literal>. </para><para>There’s nothing wrong with a method like <literal>printTime</literal>, but it is not consistent with object-oriented style. A more idiomatic solution is to provide a special method called <literal>toString</literal>. </para>
</sect1><sect1 id="a0000008454" remap="section">
  <title>The toString Method</title>
    <para>Every object has a method called <literal>toString</literal> that returns a string representation of the object. When you display an object using <literal>print</literal> or <literal>println</literal>, Java invokes the object’s <literal>toString</literal> method. </para><para><indexterm>
  <primary>override</primary>

</indexterm>By default it simply displays the type of the object and its address in hexadecimal. So, if you create a <literal>Time</literal> object and display it with <literal>println</literal>: </para><programlisting language="java">
public static void main(String[] args) {
    Time time = new Time(11, 59, 59.9);
    System.out.println(time);
}</programlisting><para><indexterm>
  <primary>print</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>print</secondary>
</indexterm><indexterm>
  <primary>object</primary>
<secondary>displaying</secondary>
</indexterm>The output looks something like this: </para><programlisting>Time@80cc7c0</programlisting><para><indexterm>
  <primary>address</primary>

</indexterm><indexterm>
  <primary>hexadecimal</primary>

</indexterm>This address can be useful for debugging, if you want to keep track of individual objects. </para><para><indexterm>
  <primary>toString</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>toString</secondary>
</indexterm>But you can <emphasis role="bold">override</emphasis> this behavior by providing your own <literal>toString</literal> method. For example, here is a <literal>toString</literal> method for <literal>Time</literal>: </para><programlisting language="java">
public String toString() {
    return String.format("%02d:%02d:%04.1f\n",
        this.hour, this.minute, this.second);
}</programlisting><para><indexterm>
  <primary>instance method</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>instance</secondary>
</indexterm>The definition does not have the keyword <literal>static</literal>, because it is not a static method. It is an <emphasis role="bold">instance method</emphasis>, so called because when you invoke it, you invoke it on an instance of the class. Instance methods are sometimes called “non-static”; you might see this term in an error message. </para><para>The body of the method is similar to <literal>printTime</literal> in the previous section, with two changes: </para><itemizedlist>
  
    <listitem><para>Inside the method, we use <literal>this</literal> to refer to the current instance; that is, the object the method is invoked on. </para></listitem>
  
    <listitem><para>Instead of <literal>printf</literal>, it uses <literal>String.format</literal>, which returns a formatted <literal>String</literal> rather than displaying it. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>string</primary>
<secondary>format</secondary>
</indexterm>Now you can call <literal>toString</literal> directly: </para><programlisting language="java">
Time time = new Time(11, 59, 59.9);
String s = time.toString();</programlisting><para>The value of <literal>s</literal> is the <literal>String</literal> <literal>"11:59:59.9"</literal>. </para><para>You can also invoke <literal>toString</literal> indirectly by invoking <literal>print</literal> or <literal>println</literal>: </para><programlisting language="java">
System.out.println(time);</programlisting><para>This code displays the <literal>String</literal> <literal>"11:59:59.9"</literal>. </para><para>Either way, when you use <literal>this</literal> inside <literal>toString</literal>, it refers to the same object as <literal>time</literal>. </para>
</sect1><sect1 id="equals" remap="section">
  <title>The equals Method</title><para><indexterm>
  <primary>identical</primary>

</indexterm><indexterm>
  <primary>equivalent</primary>

</indexterm><indexterm>
  <primary>== equals operator</primary>

</indexterm><indexterm>
  <primary>equals</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>equals</secondary>
</indexterm>We have seen two ways to check whether values are equal: the <literal>==</literal> operator and the <literal>equals</literal> method. With objects you can use either one, but they are not the same. </para><itemizedlist>
  
    <listitem><para>The <literal>==</literal> operator checks whether two references are <emphasis role="bold">identical</emphasis>; that is, whether they refer to the same object. </para></listitem>
  
    <listitem><para>The <literal>equals</literal> method checks whether two objects are <emphasis role="bold">equivalent</emphasis>; that is, whether they have the same values. </para></listitem>
  
</itemizedlist><para>The definition of identity is always the same, so the <literal>==</literal> operator always does the same thing. But the definition of equivalence is different for different objects, so objects can define their own <literal>equals</literal> methods. </para><para>Consider the following variables and the memory diagram in <xref linkend="fig.time2" />. </para><programlisting language="java">
Time time1 = new Time(9, 30, 0.0);
Time time2 = time1;
Time time3 = new Time(9, 30, 0.0);</programlisting><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>
  
  <figure id="fig.time2" float="False">
    <title>Memory diagram of three <literal>Time</literal> variables.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/time2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The assignment operator copies references, so <literal>time1</literal> and <literal>time2</literal> refer to the same object. Because they are identical, <literal>time1 == time2</literal> is true. But <literal>time1</literal> and <literal>time3</literal> refer to two different objects. Because they are not identical, <literal>time1 == time3</literal> is false. </para><para>By default, the <literal>equals</literal> method does the same thing as <literal>==</literal>. For <literal>Time</literal> objects, that’s probably not what we want. For example, <literal>time1</literal> and <literal>time3</literal> represent the same time of day, so we should consider them equivalent. </para><para><indexterm>
  <primary>equals</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>equals</secondary>
</indexterm>We can provide an <literal>equals</literal> method that implements this idea: </para><programlisting language="java">
public boolean equals(Time that) {
    final DELTA = 0.001;
    return this.hour == that.hour
        &amp;&amp; this.minute == that.minute
        &amp;&amp; Math.abs(this.second - that.second) &lt; DELTA;
}</programlisting><para><literal>equals</literal> is an instance method, so it doesn’t have the keyword <literal>static</literal>. It uses <literal>this</literal> to refer to current object, and <literal>that</literal> to refer to the other. <literal>that</literal> is <emphasis>not</emphasis> a keyword, so we could have given this parameter a different name. But using <literal>that</literal> makes the code nicely readable. </para><para>We can invoke <literal>equals</literal> like this: </para><programlisting language="java">
time1.equals(time3);</programlisting><para>Inside the <literal>equals</literal> method, <literal>this</literal> refers to the same object as <literal>time1</literal>, and <literal>that</literal> refers to the same object as <literal>time3</literal>. Since their instance variables are “equal”, the result is <literal>true</literal>. </para><para>Because <literal>hour</literal> and <literal>minute</literal> are integers, we compare them with <literal>==</literal>. But <literal>second</literal> is a floating-point number. Because of rounding errors, it is not good to compare floating-point numbers with <literal>==</literal> (see <xref linkend="rounderr" />). Instead, we check whether the difference is smaller than a threshold, <literal>DELTA</literal>. </para><para>Many objects have a similar notion of equivalence; that is, two objects are considered equal if their instance variables are equal. But other definitions are possible. </para>
</sect1><sect1 id="addingtime" remap="section">
  <title>Adding Times</title><para>Suppose you are going to a movie that starts at 18:50 (that is, 6:50 PM), and the running time is 2 hours 16 minutes. What time does the movie end? We’ll use <literal>Time</literal> objects to figure it out. </para><programlisting language="java">
Time startTime = new Time(18, 50, 0.0);
Time runningTime = new Time(2, 16, 0.0);</programlisting><para><indexterm>
  <primary>Time</primary>
<secondary>addition</secondary>
</indexterm><indexterm>
  <primary>addition</primary>
<secondary>time</secondary>
</indexterm>Here are two ways we could “add” the <literal>Time</literal> objects: </para><itemizedlist>
  
    <listitem><para>We could write a static method that takes two <literal>Time</literal> objects as parameters. </para></listitem>
  
    <listitem><para>We could write an instance method that gets invoked on one object and takes the other as a parameter. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>static</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>static</secondary>
</indexterm>To demonstrate the difference, we’ll do both. Here is the static method: </para><programlisting language="java">
public static Time add(Time t1, Time t2) {
    Time sum = new Time();
    sum.hour = t1.hour + t2.hour;
    sum.minute = t1.minute + t2.minute;
    sum.second = t1.second + t2.second;
    return sum;
}</programlisting><para>And here’s how we would invoke it: </para><programlisting language="java">
Time endTime = Time.add(startTime, runningTime);</programlisting><para><indexterm>
  <primary>instance method</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>instance</secondary>
</indexterm>Here’s what it looks like as an instance method: </para><programlisting language="java">
public Time add(Time t2) {
    Time sum = new Time();
    sum.hour = this.hour + t2.hour;
    sum.minute = this.minute + t2.minute;
    sum.second = this.second + t2.second;
    return sum;
}</programlisting><para>And here’s how we would invoke it: </para><programlisting language="java">
Time endTime = startTime.add(runningTime);</programlisting><para>Notice the differences: </para><itemizedlist>
  
    <listitem><para>The static method has the keyword <literal>static</literal>; the instance method does not. </para></listitem>
  
    <listitem><para>The static method has two parameters, <literal>t1</literal> and <literal>t2</literal>. The instance method has one explicit parameter, <literal>t1</literal>, and the implicit parameter, <literal>this</literal>. </para></listitem>
  
    <listitem><para>We invoked the static method with the <literal>Time</literal> class; we invoked the instance method with the <literal>startTime</literal> object. </para></listitem>
  
</itemizedlist><para>That’s all there is to it. Static methods and instance methods do the same thing, and you can convert from one to the other with just a few changes. </para><para>However, there’s a problem with both of these methods; they are not correct. The result from either method is <literal>20:66</literal>, which is not a valid time. </para><para>If <literal>second</literal> exceeds 59, we have to “carry” into the minutes column, and if <literal>minute</literal> exceeds 59, we have to carry into <literal>hour</literal>. </para><para>Here is a better version of the instance method, <literal>add</literal>: </para><programlisting language="java">
public Time add(Time t2) {
    Time sum = new Time();
    sum.hour = this.hour + t2.hour;
    sum.minute = this.minute + t2.minute;
    sum.second = this.second + t2.second;
    
    if (sum.second &gt;= 60.0) {
        sum.second -= 60.0;
        sum.minute += 1;
    }
    if (sum.minute &gt;= 60) {
        sum.minute -= 60;
        sum.hour += 1;
    }
    if (sum.hour &gt;= 24) {
        sum.hour -= 24
    }
    return sum;
}</programlisting><para>If <literal>hour</literal> exceeds 23, we subtract 24 hours, but there’s no <literal>days</literal> attribute to carry into. </para>
</sect1><sect1 id="a0000008745" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>class:</term>
      <listitem><para><indexterm>
  <primary>class</primary>

</indexterm>Previously, we defined a class as a collection of related methods. Now you know that a class is also a template for a new type of object. </para></listitem>
  </varlistentry><varlistentry>
    <term>instance:</term>
      <listitem><para><indexterm>
  <primary>instance</primary>

</indexterm>A member of a class. Every object is an instance of some class. </para></listitem>
  </varlistentry><varlistentry>
    <term>instantiate:</term>
      <listitem><para><indexterm>
  <primary>instantiate</primary>

</indexterm>Create a new instance of a class in the computer’s memory. </para></listitem>
  </varlistentry><varlistentry>
    <term>instance variable:</term>
      <listitem><para><indexterm>
  <primary>instance variable</primary>

</indexterm>An attribute of an object; a non-static variable defined at the class level. </para></listitem>
  </varlistentry><varlistentry>
    <term>information hiding:</term>
      <listitem><para><indexterm>
  <primary>information hiding</primary>

</indexterm>The practice of making instance variables <literal>private</literal> to limit dependencies between classes. </para></listitem>
  </varlistentry><varlistentry>
    <term>constructor:</term>
      <listitem><para><indexterm>
  <primary>constructor</primary>

</indexterm>A special method that initializes the instance variables of a newly-constructed object. </para></listitem>
  </varlistentry><varlistentry>
    <term>shadowing:</term>
      <listitem><para><indexterm>
  <primary>shadowing</primary>

</indexterm>Occurs when a local variable or parameter has the same name as an attribute. </para></listitem>
  </varlistentry><varlistentry>
    <term>client:</term>
      <listitem><para><indexterm>
  <primary>client</primary>

</indexterm>A class that uses objects defined in another class. </para></listitem>
  </varlistentry><varlistentry>
    <term>getter:</term>
      <listitem><para><indexterm>
  <primary>getter</primary>

</indexterm>A method that returns the value of an instance variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>setter:</term>
      <listitem><para><indexterm>
  <primary>setter</primary>

</indexterm>A method that assigns a value to an instance variable. </para></listitem>
  </varlistentry><varlistentry>
    <term>override:</term>
      <listitem><para><indexterm>
  <primary>override</primary>

</indexterm>Replacing a default implementation of a method, such as <literal>toString</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>instance method:</term>
      <listitem><para><indexterm>
  <primary>instance method</primary>

</indexterm>A non-static method that has access to <literal>this</literal> and the instance variables. </para></listitem>
  </varlistentry><varlistentry>
    <term>identical:</term>
      <listitem><para><indexterm>
  <primary>identical</primary>

</indexterm>References to the same object or the same location in memory are identical. </para></listitem>
  </varlistentry><varlistentry>
    <term>equivalent:</term>
      <listitem><para><indexterm>
  <primary>equivalent</primary>

</indexterm>Two objects that are “equal” but not necessarily identical, as defined by the <literal>equals</literal> method. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000008784" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch11</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000008793" role="exercise">
  <title></title>
  <para>The implementation of <literal>increment</literal> in this chapter is not very efficient. Can you rewrite it so it doesn’t use any loops? </para><para><emphasis>Hint:</emphasis> Remember the remainder operator. And yes, it works with floating-point values too. </para>
</example> </para><para><example id="a0000008801" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>Scrabble</primary>

</indexterm>In the board game Scrabble, each tile contains a letter, which is used to spell words in rows and columns, and a score, which is used to determine the value of words. </para><orderedlist>
  
  <listitem><para>Write a definition for a class named <literal>Tile</literal> that represents Scrabble tiles. The instance variables should include a character named <literal>letter</literal> and an integer named <literal>value</literal>. </para></listitem>
  
  <listitem><para>Write a constructor that takes parameters named <literal>letter</literal> and <literal>value</literal> and initializes the instance variables. </para></listitem>
  
  <listitem><para>Write a method named <literal>printTile</literal> that takes a <literal>Tile</literal> object as a parameter and displays the instance variables in a reader-friendly format. </para></listitem>
  
  <listitem><para>Write a <literal>main</literal> method that creates a <literal>Tile</literal> object with the letter <literal>Z</literal> and the value <literal>10</literal>, and then uses <literal>printTile</literal> to display the state of the object. </para></listitem>
  
  <listitem><para>Implement the <literal>toString</literal> and <literal>equals</literal> methods for a <literal>Tile</literal>. </para></listitem>
  
  <listitem><para>Create getters and setters for each of the attributes. </para></listitem>
  
</orderedlist><para>The point of this exercise is to practice the mechanical part of creating a new class definition. </para>
</example> </para><para><example id="a0000008849" role="exercise">
  <title></title>
  <para>Write a class definition for <literal>Date</literal>, an object type that contains three integers: <literal>year</literal>, <literal>month</literal>, and <literal>day</literal>. This class should provide two constructors. The first should take no parameters and initialize a default date. The second should take parameters named <literal>year</literal>, <literal>month</literal> and <literal>day</literal>, and use them to initialize the instance variables. </para><para>Write a <literal>main</literal> method that creates a new <literal>Date</literal> object named <literal>birthday</literal>. The new object should contain your birth date. You can use either constructor. </para>
</example> </para><para><example id="a0000008873" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>rational number</primary>

</indexterm>A rational number is a number that can be represented as the ratio of two integers. For example, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inlineequation> is a rational number, and you can think of 7 as a rational number with an implicit 1 in the denominator. </para><orderedlist>
  
  <listitem><para>Define a class called <literal>Rational</literal>. A <literal>Rational</literal> object should have two integer instance variables that store the numerator and denominator. </para></listitem>
  
  <listitem><para>Write a constructor that takes no arguments and that sets the numerator to 0 and denominator to 1. </para></listitem>
  
  <listitem><para>Write an instance method called <literal>printRational</literal> that displays a <literal>Rational</literal> in some reasonable format. </para></listitem>
  
  <listitem><para>Write a <literal>main</literal> method that creates a new object with type <literal>Rational</literal>, sets its instance variables to the values of your choice, and displays the object. </para></listitem>
  
  <listitem><para>At this stage, you have a minimal testable program. Test it and, if necessary, debug it. </para></listitem>
  
  <listitem><para>Write a <literal>toString</literal> method for <literal>Rational</literal> and test it using <literal>println</literal>. </para></listitem>
  
  <listitem><para>Write a second constructor that takes two arguments and uses them to initialize the instance variables. </para></listitem>
  
  <listitem><para>Write an instance method called <literal>negate</literal> that reverses the sign of a rational number. This method should be a modifier, so it should be void. Add lines to <literal>main</literal> to test the new method. </para></listitem>
  
  <listitem><para>Write an instance method called <literal>invert</literal> that inverts the number by swapping the numerator and denominator. It should be a modifier. Add lines to <literal>main</literal> to test the new method. </para></listitem>
  
  <listitem><para>Write an instance method called <literal>toDouble</literal> that converts the rational number to a <literal>double</literal> (floating-point number) and returns the result. This method is a pure method; it does not modify the object. As always, test the new method. </para></listitem>
  
  <listitem><para>Write an instance method named <literal>reduce</literal> that reduces a rational number to its lowest terms by finding the greatest common divisor (GCD) of the numerator and denominator and dividing through. This method should be a pure method; it should not modify the instance variables of the object on which it is invoked. </para><para><emphasis>Hint:</emphasis> Finding the GCD only takes a few lines of code. Search the web for “Euclidean algorithm”. </para></listitem>
  
  <listitem><para>Write an instance method called <literal>add</literal> that takes a <literal>Rational</literal> number as an argument, adds it to <literal>this</literal>, and returns a new <literal>Rational</literal> object. </para><para>There are several ways to add fractions. You can use any one you want, but you should make sure that the result of the operation is reduced so that the numerator and denominator have no common divisor (other than 1). </para></listitem>
  
</orderedlist><para>The purpose of this exercise is to write a class definition that includes a variety of methods, including constructors, static methods, instance methods, modifiers, and pure methods. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000008948">
  <title>Arrays of Objects</title>
  <para>During the next three chapters, we will develop programs that work with playing cards and decks of cards. Here is an outline of the road ahead: </para><itemizedlist>
  
    <listitem><para>In this chapter, we define a <literal>Card</literal> class and write methods that work with cards and arrays of cards. </para></listitem>
  
    <listitem><para>In <xref linkend="deck" />, we define a <literal>Deck</literal> class that encapsulates an array of cards, and we write methods that operate on decks. </para></listitem>
  
    <listitem><para>In <xref linkend="eights" />, we introduce a way to define new classes that extend existing classes. Then we use <literal>Card</literal> and <literal>Deck</literal> to implement the game <emphasis>Crazy Eights</emphasis>. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>rank</primary>

</indexterm><indexterm>
  <primary>suit</primary>

</indexterm>There are 52 cards in a standard deck. Each card belongs to one of four suits and one of 13 ranks. The suits are Clubs, Diamonds, Hearts, and Spades. The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. </para><para>If you are unfamiliar with traditional playing cards, now would be a good time to get a deck or read through <ulink url="https://en.wikipedia.org/wiki/Standard_52-card_deck"></ulink>. </para><sect1 id="a0000008976" remap="section">
  <title>Card Objects</title>
    <para><indexterm>
  <primary>Card</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Card</secondary>
</indexterm>If we want to define a class to represent a playing card, it is pretty clear what the instance variables should be: <literal>rank</literal> and <literal>suit</literal>. It is not as obvious what types they should be. </para><para>One possibility is a <literal>String</literal> containing things like <literal>"Spade"</literal> for suits and <literal>"Queen"</literal> for ranks. A problem with this choice is that it would not be easy to compare cards to see which had a higher rank or suit. </para><para><indexterm>
  <primary>encode</primary>

</indexterm><indexterm>
  <primary>map to</primary>

</indexterm>An alternative is to use integers to <emphasis role="bold">encode</emphasis> the ranks and suits. By encode, we <emphasis>don’t</emphasis> mean to encrypt or translate into a secret code. We mean to define a mapping between a sequence of numbers and the things we want to represent. </para><para>Here is a mapping for suits: </para>
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="3">
     
     <tbody>
     <row>
     
       
       <entry><para> Clubs </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 0 </para></entry>
     
     </row><row>
     
       
       <entry><para>Diamonds </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
     </row><row>
     
       
       <entry><para>Hearts </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 2 </para></entry>
     
     </row><row>
     
       
       <entry><para>Spades </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 3 </para></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
<para>We use the mathematical symbol <emphasis role="math">↦</emphasis> to make it clear that these mappings are not part of the program. They are part of the program design, but they never appear explicitly in the code. </para><para>Each of the numerical ranks (2 through 10) maps to the corresponding integer. For the face cards, we can use: </para>
   
   
     <informaltable remap="tabular" Colsep="1" Frame="all" Rowsep="1">
     <tgroup cols="3">
     
     <tbody>
     <row>
     
       
       <entry><para> Ace </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 1 </para></entry>
     
     </row><row>
     
       
       <entry><para>Jack </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 11 </para></entry>
     
     </row><row>
     
       
       <entry><para>Queen </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 12 </para></entry>
     
     </row><row>
     
       
       <entry><para>King </para></entry>
     
       
       <entry><para> <emphasis role="math">↦</emphasis> </para></entry>
     
       
       <entry><para> 13 </para></entry>
     
     </row>
     </tbody>
     </tgroup>
     </informaltable>
   
<para>With this encoding, the class definition for the <literal>Card</literal> type looks like this: </para><programlisting language="java">
public class Card {
    private int rank;
    private int suit;

    public Card(int rank, int suit) {
        this.rank = rank;
        this.suit = suit;
    }
}</programlisting><para><indexterm>
  <primary>constructor</primary>

</indexterm>The instance variables are <literal>private</literal>: we can access them from inside this class, but not from other classes. </para><para>The constructor takes a parameter for each instance variable. To create a <literal>Card</literal> object, we use the <literal>new</literal> operator: </para><programlisting language="java">
Card threeOfClubs = new Card(3, 0);</programlisting><para>The result is a reference to a <literal>Card</literal> that represents the “3 of Clubs”. </para>
</sect1><sect1 id="a0000009096" remap="section">
  <title>Card toString</title>
    <para><indexterm>
  <primary>print</primary>
<secondary>Card</secondary>
</indexterm>When you create a new class, the first step is to declare the instance variables and write constructors. A good next step is to write <literal>toString</literal>, which is useful for debugging and incremental development. </para><para><indexterm>
  <primary>string</primary>
<secondary>array of</secondary>
</indexterm><indexterm>
  <primary>array</primary>
<secondary>of strings</secondary>
</indexterm>To display <literal>Card</literal> objects in a way that humans can read easily, we need to “decode” the integer values as words. A natural way to do that is with an array of <literal>String</literal>s. For example, we can create the array like this: </para><programlisting language="java">
String[] suits = new String[4];</programlisting><para>And then assign values to the elements: </para><programlisting language="java">
suits[0] = "Clubs";
suits[1] = "Diamonds";
suits[2] = "Hearts";
suits[3] = "Spades";</programlisting><para>Or we can create the array and initialize the elements at the same time, as we saw in <xref linkend="printarray" />: </para><programlisting language="java">
String[] suits = {"Clubs", "Diamonds", "Hearts", "Spades"};</programlisting><para><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm><indexterm>
  <primary>reference</primary>

</indexterm><indexterm>
  <primary>string</primary>
<secondary>reference to</secondary>
</indexterm>The memory diagram in <xref linkend="fig.stringarray" /> shows the result. Each element of the array is a reference to a <literal>String</literal>. </para>
  
  <figure id="fig.stringarray" float="False">
    <title>Memory diagram of an array of strings.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/stringarray.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>We also need an array to decode the ranks: </para><programlisting language="java">
String[] ranks = {null, "Ace", "2", "3", "4", "5", "6",
           "7", "8", "9", "10", "Jack", "Queen", "King"};</programlisting><para>The zeroth element should never be used, because the only valid ranks are 1–13. We set it to <literal>null</literal> to indicate an unused element. </para><para>Using these arrays, we can create a meaningful <literal>String</literal> using <literal>suit</literal> and <literal>rank</literal> as indexes. </para><programlisting language="java">
String s = ranks[this.rank] + " of " + suits[this.suit];</programlisting><para>The expression <literal>ranks[this.rank]</literal> means “use the instance variable <literal>rank</literal> from <literal>this</literal> object as an index into the array <literal>ranks</literal>.” We select the string for <literal>this.suit</literal> in a similar way. </para><para>Now we can wrap all the previous code in a <literal>toString</literal> method. </para><programlisting language="java">
public String toString() {
    String[] ranks = {null, "Ace", "2", "3", "4", "5", "6",
               "7", "8", "9", "10", "Jack", "Queen", "King"};
    String[] suits = {"Clubs", "Diamonds", "Hearts", "Spades"};
    String s = ranks[this.rank] + " of " + suits[this.suit];
    return s;
}</programlisting><para>When we display a card, <literal>println</literal> automatically calls <literal>toString</literal>. The output of the following code is <literal>Jack of Diamonds</literal>. </para><programlisting language="java">
Card card = new Card(11, 1);
System.out.println(card);</programlisting></sect1><sect1 id="classvar" remap="section">
  <title>Class Variables</title><para><indexterm>
  <primary>class variable</primary>

</indexterm>So far we have seen local variables, which are declared inside a method, and instance variables, which are declared in a class definition, usually before the method definitions. Now it’s time to learn about <emphasis role="bold">class variables</emphasis>. They are shared across all instances of the class. </para><para><indexterm>
  <primary>static</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>static</secondary>
</indexterm>Like instance variables, class variables are defined in a class definition, before the method definitions. But they are identified by the keyword <literal>static</literal>. Here is a version of <literal>Card</literal> where <literal>RANKS</literal> and <literal>SUITS</literal> are defined as class variables: </para><programlisting language="java">
public class Card {

    public static final String[] RANKS = {
        null, "Ace", "2", "3", "4", "5", "6", "7",
        "8", "9", "10", "Jack", "Queen", "King"};

    public static final String[] SUITS = {
        "Clubs", "Diamonds", "Hearts", "Spades"};

    // instance variables and constructors go here

    public String toString() {
        return RANKS[this.rank] + " of " + SUITS[this.suit];
    }
}</programlisting><para><indexterm>
  <primary>garbage collection</primary>

</indexterm>Class variables are allocated when the program begins and persist until the program ends. In contrast, instance variables like <literal>rank</literal> and <literal>suit</literal> are allocated when the program creates <literal>new</literal> objects, and they are deleted when the object is garbage-collected. </para><para><indexterm>
  <primary>final</primary>

</indexterm>Class variables are often used to store constant values that are needed in several places. In that case, they should also be declared as <literal>final</literal>. Note that whether a variable is <literal>static</literal> or <literal>final</literal> involves two separate considerations: <literal>static</literal> means the variable is <emphasis>shared</emphasis>, and <literal>final</literal> means the variable is <emphasis>constant</emphasis>. </para><para>Naming <literal>static final</literal> variables with capital letters is a common convention that makes it easier to recognize their role in the class. In the <literal>toString</literal> method, we refer to <literal>SUITS</literal> and <literal>RANKS</literal> as if they were local variables, but we can tell that they are class variables. </para><para>One advantage of defining <literal>SUITS</literal> and <literal>RANKS</literal> as class variables is that they don’t need to be created (and garbage-collected) every time <literal>toString</literal> is called. They may also be needed in other methods and classes, so it’s helpful to make them available everywhere. Since the array variables are <literal>final</literal>, and the strings they reference are immutable, there is no danger in making them <literal>public</literal>. </para>
</sect1><sect1 id="a0000009231" remap="section">
  <title>The compareTo Method</title>
    <para><indexterm>
  <primary>equivalent</primary>

</indexterm>As we saw in <xref linkend="equals" />, it’s helpful to create an <literal>equals</literal> method to test whether two objects are equivalent. </para><programlisting language="java">
public boolean equals(Card that) {
    return this.rank == that.rank
        &amp;&amp; this.suit == that.suit;
}</programlisting><para><indexterm>
  <primary>operator</primary>
<secondary>logical</secondary>
</indexterm><indexterm>
  <primary>logical operator</primary>

</indexterm>It would also be nice to have a method for comparing cards, so we can tell if one is higher or lower than another. For primitive types, we can use comparison operators like <literal>&lt;</literal> and <literal>&gt;</literal> to compare values. But these operators don’t work for object types. </para><para>For strings, Java provides a <literal>compareTo</literal> method, as we saw in <xref linkend="strcmp" />. We can write our own version of <literal>compareTo</literal> for the classes that we define, like we did for the <literal>equals</literal> method. </para><para><indexterm>
  <primary>ordering</primary>

</indexterm><indexterm>
  <primary>complete ordering</primary>

</indexterm><indexterm>
  <primary>partial ordering</primary>

</indexterm>Some types are “totally ordered”, which means that you can compare any two values and tell which is bigger. Integers and strings are totally ordered. Other types are “unordered”, which means that there is no meaningful way to say that one element is bigger than another. In Java, the <literal>boolean</literal> type is unordered; if you try to compare <literal>true &lt; false</literal>, you get a compiler error. </para><para>The set of playing cards is “partially ordered”, which means that sometimes we can compare cards and sometimes not. For example, we know that the 3 of Clubs is higher than the 2 of Clubs, and the 3 of Diamonds is higher than the 3 of Clubs. But which is better, the 3 of Clubs or the 2 of Diamonds? One has a higher rank, but the other has a higher suit. </para><para><indexterm>
  <primary>compareTo</primary>

</indexterm>To make cards comparable, we have to decide which is more important: rank or suit. The choice is arbitrary, and it might be different for different games. But when you buy a new deck of cards, it comes sorted with all the Clubs together, followed by all the Diamonds, and so on. So for now, let’s say that suit is more important. With that decided, we can write <literal>compareTo</literal> as follows: </para><programlisting language="java">
public int compareTo(Card that) {
    if (this.suit &lt; that.suit) {
        return -1;
    }
    if (this.suit &gt; that.suit) {
        return 1;
    }
    if (this.rank &lt; that.rank) {
        return -1;
    }
    if (this.rank &gt; that.rank) {
        return 1;
    }
    return 0;
}</programlisting><para><literal>compareTo</literal> returns <literal>-1</literal> if <literal>this</literal> is a lower card, <literal>+1</literal> if <literal>this</literal> is a higher card, and <literal>0</literal> if <literal>this</literal> and <literal>that</literal> are equivalent. It compares suits first. If the suits are the same, it compares ranks. If the ranks are also the same, it returns 0. </para>
</sect1><sect1 id="a0000009285" remap="section">
  <title>Cards are Immutable</title>
    <para>The instance variables of <literal>Card</literal> are <literal>private</literal>, so they can’t be accessed from other classes. We can provide getters to allow other classes to read the <literal>rank</literal> and <literal>suit</literal> values: </para><programlisting language="java">
public int getRank() {
    return this.rank;
}

public int getSuit() {
    return this.suit;
}</programlisting><para><indexterm>
  <primary>immutable</primary>

</indexterm>Whether or not to provide setters is a design decision. If we did, cards would be mutable, so you could transform one card into another. That is probably not a feature we want, and in general, mutable objects are more error-prone. So it might be better to make cards immutable. To do that, all we have to do is <emphasis>not</emphasis> provide any modifier methods (including setters). </para><para><indexterm>
  <primary>final</primary>

</indexterm>That’s easy enough, but it is not foolproof, because a fool might come along later and add a modifier. We can prevent that possibility by declaring the instance variables <literal>final</literal>: </para><programlisting language="java">
public class Card {
    private final int rank;
    private final int suit;

    ...
}</programlisting><para>You can initialize these these variables inside a constructor, but if someone writes a method that tries to modify them, they’ll get a compiler error. This kind of safeguard helps prevent future mistakes and hours of debugging. </para>
</sect1><sect1 id="cardarray" remap="section">
  <title>Arrays of Cards</title><para><indexterm>
  <primary>array</primary>
<secondary>of objects</secondary>
</indexterm><indexterm>
  <primary>object</primary>
<secondary>array of</secondary>
</indexterm>Just as you can create an array of <literal>String</literal> objects, you can create an array of <literal>Card</literal> objects. The following statement creates an array of 52 cards. <xref linkend="fig.cardarray" /> shows the memory diagram for this array. </para><programlisting language="java">
Card[] cards = new Card[52];</programlisting><figure id="fig.cardarray" float="False">
    <title>Memory diagram of an unpopulated <literal>Card</literal> array.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/cardarray.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>null</primary>

</indexterm>Although we call it an “array of cards”, the array contains <emphasis>references</emphasis> to cards; it does not contain the <literal>Card</literal> objects themselves. Initially the references are all <literal>null</literal>. </para><para>Even so, you can access the elements of the array in the usual way: </para><programlisting language="java">
if (cards[0] == null) {
    System.out.println("No card yet!");
}</programlisting><para><indexterm>
  <primary>exception</primary>
<secondary>NullPointer</secondary>
</indexterm><indexterm>
  <primary>run-time error</primary>

</indexterm>But if you try to access the instance variables of non-existent <literal>Card</literal> objects, you will get a <literal>NullPointerException</literal>. </para><programlisting language="java">
System.out.println(cards[0].rank);  // NullPointerException</programlisting><para><indexterm>
  <primary>nesting</primary>

</indexterm><indexterm>
  <primary>loop</primary>
<secondary>nested</secondary>
</indexterm>That code won’t work until we put cards in the array. One way to populate the array is to write nested <literal>for</literal> loops: </para><programlisting language="java">
int index = 0;
for (int suit = 0; suit &lt;= 3; suit++) {
    for (int rank = 1; rank &lt;= 13; rank++) {
        cards[index] = new Card(rank, suit);
        index++;
    }
}</programlisting><para>The outer loop iterates suits from 0 to 3. For each suit, the inner loop iterates ranks from 1 to 13. Since the outer loop runs 4 times, and the inner loop runs 13 times for each suit, the body is executed 52 times. </para><para><indexterm>
  <primary>index</primary>

</indexterm>We use a separate variable <literal>index</literal> to keep track of where in the array the next card should go. <xref linkend="fig.cardarray2" /> shows what the array looks like after the first two cards have been created. </para>
  
  <figure id="fig.cardarray2" float="False">
    <title>Memory diagram of a <literal>Card</literal> array with two cards.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/cardarray2.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>print</primary>
<secondary>array</secondary>
</indexterm>When you work with arrays, it is convenient to have a method that displays the contents. We have seen the pattern for traversing an array several times, so the following method should be familiar. </para><programlisting language="java">
public static void printDeck(Card[] cards) {
    for (Card card : cards) {
        System.out.println(card);
    }
}</programlisting><para>Since <literal>cards</literal> has type <literal>Card[]</literal>, pronounced “card array”, an element of <literal>cards</literal> has type <literal>Card</literal>. So <literal>println</literal> invokes the <literal>toString</literal> method in the <literal>Card</literal> class. </para><para>Then again, we don’t have to write our own <literal>printDeck</literal> method. The <literal>Arrays</literal> class provides a <literal>toString</literal> method that invokes <literal>toString</literal> on the elements of an array and concatenates the results. </para><programlisting language="java">
System.out.println(Arrays.toString(cards))</programlisting></sect1><sect1 id="a0000009398" remap="section">
  <title>Sequential Search</title>
    <para><indexterm>
  <primary>traverse</primary>

</indexterm><indexterm>
  <primary>loop</primary>
<secondary>search</secondary>
</indexterm><indexterm>
  <primary>sequential search</primary>

</indexterm>The next method we’ll write is <literal>search</literal>, which takes an array of cards and a <literal>Card</literal> object as parameters. It returns the index where the <literal>Card</literal> appears in the array, or <literal>-1</literal> if it doesn’t. This version of <literal>search</literal> uses the algorithm we saw in <xref linkend="traversal" />, which is called <emphasis role="bold">sequential search</emphasis>: </para><programlisting language="java">
public static int search(Card[] cards, Card target) {
    for (int i = 0; i &lt; cards.length; i++) {
        if (cards[i].equals(target)) {
            return i;
        }
    }
    return -1;
}</programlisting><para><indexterm>
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm><indexterm>
  <primary>return</primary>
<secondary>inside loop</secondary>
</indexterm>The method returns as soon as it discovers the card, which means we don’t have to traverse the entire array if we find the target. If we get to the end of the loop, we know the card is not in the array. </para><para><indexterm>
  <primary>efficiency</primary>

</indexterm>If the cards in the array are not in order, there is no way to search faster than sequential search. We have to look at every card, because otherwise we can’t be certain the card we want is not there. But if the cards are in order, we can use better algorithms. </para><para>Sequential search is relatively inefficient, especially for large arrays. If you pay the price to keep the array sorted, finding elements becomes much easier. </para>
</sect1><sect1 id="a0000009423" remap="section">
  <title>Binary Search</title>
    <para><indexterm>
  <primary>binary search</primary>

</indexterm>When you look for a word in a dictionary, you don’t search page by page from front to back. Since the words are in alphabetical order, you probably use a <emphasis role="bold">binary search</emphasis> algorithm: </para><orderedlist>
  
  <listitem><para>Start on a page near the middle of the dictionary. </para></listitem>
  
  <listitem><para>Compare a word on the page to the word you are looking for. If you find it, stop. </para></listitem>
  
  <listitem><para>If the word on the page comes before the word you are looking for, flip to somewhere later in the dictionary and go to step 2. </para></listitem>
  
  <listitem><para>If the word on the page comes after the word you are looking for, flip to somewhere earlier in the dictionary and go to step 2. </para></listitem>
  
</orderedlist><para>This algorithm is much faster than sequential search, because it rules out half of the remaining words each time you make a comparison. If at any point you find two adjacent words on the page, and your word comes between them, you can conclude that your word is not in the dictionary. </para><para>Getting back to the array of cards, we can write a faster version of <literal>search</literal> if we know the cards are in order: </para><programlisting language="java">
public static int binarySearch(Card[] cards, Card target) {
    int low = 0;
    int high = cards.length - 1;
    while (low &lt;= high) {
        int mid = (low + high) / 2;                 // step 1
        int comp = cards[mid].compareTo(target);

        if (comp == 0) {                            // step 2
            return mid;
        } else if (comp &lt; 0) {                      // step 3
            low = mid + 1;
        } else {                                    // step 4
            high = mid - 1;
        }
    }
    return -1;
}</programlisting><para>First, we declare <literal>low</literal> and <literal>high</literal> variables to represent the range we are searching. Initially we search the entire array, from <literal>0</literal> to <literal>cards.length - 1</literal>. </para><para>Inside the <literal>while</literal> loop, we repeat the four steps of binary search: </para><orderedlist>
  
  <listitem><para>Choose an index between <literal>low</literal> and <literal>high</literal>—call it <literal>mid</literal>—and compare the card at <literal>mid</literal> to the target. </para></listitem>
  
  <listitem><para>If you found the target, return its index (which is <literal>mid</literal>). </para></listitem>
  
  <listitem><para>If the card at <literal>mid</literal> is lower than the target, search the range from <literal>mid + 1</literal> to <literal>high</literal>. </para></listitem>
  
  <listitem><para>If the card at <literal>mid</literal> is higher than the target, search the range from <literal>low</literal> to <literal>mid - 1</literal>. </para></listitem>
  
</orderedlist><para>If <literal>low</literal> exceeds <literal>high</literal>, there are no cards in the range, so we terminate the loop and return <literal>-1</literal>. </para><para>This algorithm only depends on the <literal>compareTo</literal> method of the object, so we can use this code with any object type that provides <literal>compareTo</literal>. </para>
</sect1><sect1 id="a0000009500" remap="section">
  <title>Tracing the Code</title>
    <para><indexterm>
  <primary>tracing</primary>

</indexterm>To see how binary search works, it’s helpful to add the following print statement at the beginning of the loop: </para><programlisting language="java">
System.out.println(low + ", " + high);</programlisting><para>Using a sorted deck of cards, we can search for the “Jack of Clubs” like this: </para><programlisting language="java">
Card card = new Card(11, 0);
System.out.println(binarySearch(cards, card));</programlisting><para>We expect to find this card at position 10 (since the “Ace of Clubs” is at position 0). Here is the output of <literal>binarySearch</literal>: </para><programlisting>0, 51
0, 24
0, 11
6, 11
9, 11
10</programlisting><para>You can see the range of cards shrinking as the <literal>while</literal> loop runs, until eventually index 10 is found. If we search for a card that’s not in the array, like <literal>new Card(15, 1)</literal> the “15 of Diamonds”, we get the following: </para><programlisting>0, 51
26, 51
26, 37
26, 30
26, 27
-1</programlisting><para>Each time through the loop, we cut the distance between <literal>low</literal> and <literal>high</literal> in half. After <emphasis role="math">k</emphasis> iterations, the number of remaining cards is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>52</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inlineequation>. To find the number of iterations it takes to complete, we set <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>52</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation> and solve for <emphasis role="math">k</emphasis>. The result is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mn>52</mml:mn></mml:mrow></mml:math></inlineequation>, which is about 5.7. So we might have to look at 5 or 6 cards, as opposed to all 52 if we did a sequential search. </para><para>More generally, if the array contains <emphasis role="math">n</emphasis> elements, binary search requires <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation> comparisons, and sequential search requires <emphasis role="math">n</emphasis>. For large values of <emphasis role="math">n</emphasis>, binary search is substantially faster. </para>
</sect1><sect1 id="a0000009541" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>encode:</term>
      <listitem><para><indexterm>
  <primary>encode</primary>

</indexterm>To represent one set of values using another set of values by constructing a mapping between them. </para></listitem>
  </varlistentry><varlistentry>
    <term>class variable:</term>
      <listitem><para><indexterm>
  <primary>class variable</primary>

</indexterm>A variable declared within a class as <literal>static</literal>. There is only one copy of a class variable, no matter how many objects there are. </para></listitem>
  </varlistentry><varlistentry>
    <term>sequential search:</term>
      <listitem><para><indexterm>
  <primary>sequential search</primary>

</indexterm>An algorithm that searches array elements, one by one, until a target value is found. </para></listitem>
  </varlistentry><varlistentry>
    <term>binary search:</term>
      <listitem><para><indexterm>
  <primary>binary search</primary>

</indexterm>An algorithm that searches a sorted array by starting in the middle, comparing an element to the target, and eliminating half of the remaining elements. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000009554" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch12</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000009563" role="exercise">
  <title></title>
  <para>Encapsulate the deck-building code from <xref linkend="cardarray" /> in a method called <literal>makeDeck</literal> that takes no parameters and returns a fully-populated array of <literal>Card</literal>s. </para>
</example> </para><para><example id="a0000009572" role="exercise">
  <title></title>
  <para>In some card games, Aces are ranked higher than Kings. Modify the <literal>compareTo</literal> method to implement this ordering. </para>
</example> </para><para><example id="a0000009577" role="exercise">
  <title></title>
  <para><indexterm>
  <primary>histogram</primary>

</indexterm>In Poker a “flush” is a hand that contains five or more cards of the same suit. A hand can contain any number of cards. </para><orderedlist>
  
  <listitem><para>Write a method called <literal>suitHist</literal> that takes an array of cards as a parameter and that returns a histogram of the suits in the hand. Your solution should only traverse the array once as in <xref linkend="singlepass" />. </para></listitem>
  
  <listitem><para>Write a method called <literal>hasFlush</literal> that takes an array of cards as a parameter and returns <literal>true</literal> if the hand contains a flush (and <literal>false</literal> otherwise). </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000009597" role="exercise">
  <title></title>
  <para>Working with cards is more fun if you can display them on the screen. If you have not already read <xref linkend="graphics" /> about 2D graphics, you should read it before working on this exercise. In the code directory for this chapter, <literal>ch12</literal>, you will find: </para><itemizedlist>
  
    <listitem><para><literal>cardset-oxymoron</literal>: A directory containing images of playing cards. </para></listitem>
  
    <listitem><para><literal>CardTable.java</literal>: A sample program that demonstrates how to read and display images. </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>array</primary>
<secondary>2D</secondary>
</indexterm>This code demonstrates the use of a 2D array, specifically an array of images. The declaration looks like this: </para><programlisting language="java">
private Image[][] images;</programlisting><para>The variable <literal>images</literal> refers to a 2D array of <literal>Image</literal> objects, which are defined in the <literal>java.awt</literal> package. Here’s the code that creates the array itself: </para><programlisting language="java">
images = new Image[14][4];</programlisting><para>The array has 14 rows (one for each rank plus an unused row for rank 0) and 4 columns (one for each suit). Here’s the loop that populates the array: </para><programlisting language="java">
String cardset = "cardset-oxymoron";
String suits = "cdhs";

for (int suit = 0; suit &lt;= 3; suit++) {
    char c = suits.charAt(suit);

    for (int rank = 1; rank &lt;= 13; rank++) {
        String s = String.format("%s/%02d%c.gif",
                                 cardset, rank, c);
        images[rank][suit] = new ImageIcon(s).getImage();
    }
}</programlisting><para>The variable <literal>cardset</literal> contains the name of the directory that contains the image files. <literal>suits</literal> is a string that contains the single-letter abbreviations for the suits. These strings are used to assemble <literal>s</literal>, which contains the filename for each image. For example, when <literal>rank=1</literal> and <literal>suit=2</literal>, the value of <literal>s</literal> is <literal>"cardset-oxymoron/01h.gif"</literal>, which is an image of the Ace of Hearts. </para><para>The last line of the loop reads the image file, extracts an <literal>Image</literal> object, and assigns it to a location in the array, as specified by the indexes <literal>rank</literal> and <literal>suit</literal>. For example, the image of the Ace of Hearts is stored in row 1, column 2. </para><para>If you compile and run <literal>CardTable.java</literal>, you should see images of a deck of cards laid out on a green table. You can use this class as a starting place to implement your own card games. </para><para>As a starting place, try placing cards on the table in the starting configuration for the solitaire game Klondike (see <ulink url="https://en.wikipedia.org/wiki/Klondike_(solitaire)"></ulink>). </para><para>You can get the image for the back of the card by reading the file <literal>back192.gif</literal>. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000009659">
  <title>Objects of Arrays</title>
  <para><indexterm>
  <primary>array</primary>
<secondary>of cards</secondary>
</indexterm>In the previous chapter, we defined a class to represent cards and used an array of <literal>Card</literal> objects to represent a deck. In this chapter, we take additional steps toward object-oriented programming. </para><para>First we define a class to represent a deck of cards. Then we present algorithms for shuffling and sorting decks. Finally, we introduce <literal>ArrayList</literal> from the Java library and use it to represent collections of cards. </para><sect1 id="deck" remap="section">
  <title>Decks of Cards</title><para><indexterm>
  <primary>Deck</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Deck</secondary>
</indexterm>Here is the beginning of a <literal>Deck</literal> class that encapsulates an array of <literal>Card</literal> objects: </para><programlisting language="java">
public class Deck {
    private Card[] cards;

    public Deck(int n) {
        this.cards = new Card[n];
    }

    public Card[] getCards() {
        return this.cards;
    }
}</programlisting><para><indexterm>
  <primary>constructor</primary>

</indexterm><indexterm>
  <primary>memory diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>memory</secondary>
</indexterm>The constructor initializes the instance variable with an array of <literal>n</literal> cards, but it doesn’t create any <literal>Card</literal> objects. <xref linkend="fig.deckobject" /> shows what a <literal>Deck</literal> looks like with no cards. </para>
  
  <figure id="fig.deckobject" float="False">
    <title>Memory diagram of an unpopulated <literal>Deck</literal> object.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/deckobject.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>We’ll add another constructor that creates a standard 52-card array and populates it with <literal>Card</literal> objects: </para><programlisting language="java">
public Deck() {
    this.cards = new Card[52];
    int index = 0;
    for (int suit = 0; suit &lt;= 3; suit++) {
        for (int rank = 1; rank &lt;= 13; rank++) {
            this.cards[index] = new Card(rank, suit);
            index++;
        }
    }
}</programlisting><para>This method is similar to the example in <xref linkend="cardarray" />; we just turned it into a constructor. We can use it to create a complete <literal>Deck</literal> like this: </para><programlisting language="java">
Deck deck = new Deck();</programlisting><para><indexterm>
  <primary>printDeck</primary>

</indexterm>Now that we have a <literal>Deck</literal> class, we have a logical place to put methods that pertain to decks. Looking at the methods we have written so far, one obvious candidate is <literal>printDeck</literal> from <xref linkend="cardarray" />. Here’s how it looks, rewritten as an instance method of <literal>Deck</literal>: </para><programlisting language="java">
public void print() {
    for (Card card : this.cards) {
        System.out.println(card);
    }
}</programlisting><para>Notice that when we transform a static method into an instance method, the code is shorter. Here’s how we invoke it: </para><programlisting language="java">
deck.print();</programlisting></sect1><sect1 id="shuffle" remap="section">
  <title>Shuffling Decks</title><para><indexterm>
  <primary>shuffle</primary>

</indexterm>For most card games, you have to shuffle the deck; that is, put the cards in a random order. In <xref linkend="random" /> we saw how to generate random numbers, but it is not obvious how to use them to shuffle a deck. </para><para>One possibility is to model the way humans shuffle; for example, we could divide the deck in two halves and then choosing alternately from each one. Since humans usually don’t shuffle perfectly, after about seven iterations the order of the deck is pretty well randomized. </para><para>But a computer program would have the annoying property of doing a perfect shuffle every time, which is not very random. In fact, after eight perfect shuffles, you would find the deck back in the order you started in! For more on this, see <ulink url="https://en.wikipedia.org/wiki/Faro_shuffle"></ulink>. </para><para><indexterm>
  <primary>shuffle</primary>

</indexterm><indexterm>
  <primary>pseudocode</primary>

</indexterm>A better shuffling algorithm is to traverse the deck one card at a time, and at each iteration, choose two cards and swap them. To outline this algorithm, we’ll use a combination of Java statements and English comments. This technique is sometimes called <emphasis role="bold">pseudocode</emphasis>. </para><programlisting language="java">
public void shuffle() {
    for each index i {
        // choose a random number between i and length - 1
        // swap the ith card and the randomly-chosen card
    }
}</programlisting><para><indexterm>
  <primary>helper method</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>helper</secondary>
</indexterm>The nice thing about pseudocode is that it often makes clear what other methods you are going to need. In this case, we need a method that chooses a random integer in a given range and a method that takes two indexes and swaps the cards at those positions. </para><programlisting language="java">
private static int randomInt(int low, int high) {
    // return a random number between low and high, 
    // including both
}

private void swapCards(int i, int j) {
    // swap the ith and the jth cards in the array
}</programlisting><para><indexterm>
  <primary>randomInt</primary>

</indexterm><indexterm>
  <primary>swapCards</primary>

</indexterm>Methods like <literal>randomInt</literal> and <literal>swapCards</literal> are called <emphasis role="bold">helper methods</emphasis>, because they help you solve parts of the problem. Helper methods are often <literal>private</literal>, because they are only used by methods in the class, and are not needed by methods in other classes. </para><para><indexterm>
  <primary>top-down design</primary>

</indexterm><indexterm>
  <primary>design process</primary>

</indexterm>The process of writing pseudocode first and then writing helper methods to make it work is a kind of <emphasis role="bold">top-down design</emphasis> (see <ulink url="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design"></ulink>). It is an alternative to “incremental development” and “encapsulation and generalization”, the other design processes you have seen in this book. </para><para>One of the exercises at the end of the chapter asks you to write the helper methods <literal>randomInt</literal> and <literal>swapCards</literal>, and use them to implement <literal>shuffle</literal>. </para><para>When you do the exercise, notice that <literal>randomInt</literal> is a class method and <literal>swapCards</literal> is an instance method. Do you understand why? </para>
</sect1><sect1 id="sorting" remap="section">
  <title>Selection Sort</title><para><indexterm>
  <primary>selection sort</primary>

</indexterm><indexterm>
  <primary>sort</primary>
<secondary>selection</secondary>
</indexterm>Now that we have shuffled the deck, we need a way to put it back in order. There is an algorithm for sorting that is ironically similar to the algorithm for shuffling. It’s called <emphasis role="bold">selection sort</emphasis>, because it works by traversing the array repeatedly and selecting the lowest (or highest) remaining card each time. </para><para>During the first iteration, we find the lowest card and swap it with the card in the 0th position. During the <emphasis role="math">i</emphasis>th iteration, we find the lowest card to the right of <emphasis role="math">i</emphasis> and swap it with the <emphasis role="math">i</emphasis>th card. Here is pseudocode for selection sort: </para><programlisting language="java">
public void selectionSort() {
    for each index i {
        // find the lowest card at or to the right of i
        // swap the ith card and the lowest card found
    }
}</programlisting><para>Again, the pseudocode helps with the design of the helper methods. For this algorithm we can reuse <literal>swapCards</literal> from the previous section, so we only need a method to find the lowest card; we’ll call it <literal>indexLowest</literal>. </para><programlisting language="java">
private int indexLowest(int low, int high) {
    // find the lowest card between low and high
}</programlisting><para>One of the exercises at the end of the chapter asks you to write <literal>indexLowest</literal>, and then use it and <literal>swapCards</literal> to implement <literal>selectionSort</literal>. </para>
</sect1><sect1 id="mergesort" remap="section">
  <title>Merge Sort</title><para><indexterm>
  <primary>efficiency</primary>

</indexterm>Selection sort is a simple algorithm, but it is not very efficient. To sort <emphasis role="math">n</emphasis> items, it has to traverse the array <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation> times. Each traversal takes an amount of time proportional to <emphasis role="math">n</emphasis>. The total time, therefore, is proportional to <emphasis role="math">n<superscript>2</superscript></emphasis>. </para><para><indexterm>
  <primary>merge sort</primary>

</indexterm><indexterm>
  <primary>sort</primary>
<secondary>merge</secondary>
</indexterm>We will develop a more efficient algorithm called <emphasis role="bold">merge sort</emphasis>. To sort <emphasis role="math">n</emphasis> items, merge sort takes time proportional to <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation>. That may not seem impressive, but as <emphasis role="math">n</emphasis> gets big, the difference between <emphasis role="math">n<superscript>2</superscript></emphasis> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation> can be enormous. </para><para>For example, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub></mml:math></inlineequation> of one million is around 20. So if you had to sort a million numbers, merge sort would require 20 million steps. But selection sort would require one trillion steps! </para><para>The idea behind merge sort is this: if you have two decks, each of which has already been sorted, you can quickly merge them into a single, sorted deck. Try this out with a deck of cards: </para><orderedlist>
  
  <listitem><para>Form two decks with about 10 cards each, and sort them so they are face up with the lowest cards on top. Place the decks in front of you. </para></listitem>
  
  <listitem><para>Compare the top card from each deck and choose the lower one. Flip it over and add it to the merged deck. </para></listitem>
  
  <listitem><para>Repeat step 2 until one of the decks is empty. Then take the remaining cards and add them to the merged deck. </para></listitem>
  
</orderedlist><para>The result should be a single sorted deck. In the next few sections, we’ll explain how to implement this algorithm in Java. </para>
</sect1><sect1 id="subdeck" remap="section">
  <title>Subdecks</title>
    <para><indexterm>
  <primary>subdeck</primary>

</indexterm>The first step of merge sort is to split the deck into two “subdecks”, each with about half of the cards. So we need a method that takes a deck, and a range of indexes, and returns a new deck that contains the specified subset of cards. </para><programlisting language="java">
public Deck subdeck(int low, int high) {
    Deck sub = new Deck(high - low + 1);
    for (int i = 0; i &lt; sub.cards.length; i++) {
        sub.cards[i] = this.cards[low + i];
    }
    return sub;
}</programlisting><para>The first line creates an unpopulated <literal>Deck</literal> object that contains an array of <literal>null</literal> references. Inside the <literal>for</literal> loop, the subdeck gets populated with references to <literal>Card</literal> objects. </para><para><indexterm>
  <primary>off-by-one</primary>

</indexterm>The length of the subdeck is <literal>high - low + 1</literal>, because both the low card and the high card are included. This sort of computation can be confusing, and forgetting the “<literal>+ 1</literal>” often leads to <emphasis role="bold">off-by-one</emphasis> errors. Drawing a picture is usually the best way to avoid them. </para><para><indexterm>
  <primary>constructor</primary>

</indexterm><indexterm>
  <primary>overload</primary>

</indexterm><xref linkend="fig.subdeck" /> is a memory diagram of a subdeck with <literal>low = 0</literal> and <literal>high = 4</literal>. The result is a hand with five cards that are <emphasis>shared</emphasis> with the original deck; that is, they are aliased. </para>
  
  <figure id="fig.subdeck" float="False">
    <title>Memory diagram showing the effect of <literal>subdeck</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/subdeck.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>aliasing</primary>

</indexterm><indexterm>
  <primary>reference</primary>

</indexterm>Aliasing might not be a good idea, because changes to shared cards would be reflected in multiple decks. But since <literal>Card</literal> objects are immutable, this kind of aliasing is not a problem. And it saves some memory because we don’t create duplicate <literal>Card</literal> objects. </para>
</sect1><sect1 id="a0000009878" remap="section">
  <title>Merging Decks</title>
    <para><indexterm>
  <primary>merge</primary>

</indexterm>The next helper method we need is <literal>merge</literal>, which takes two sorted subdecks and returns a new deck containing all cards from both decks, in order. Here’s what the algorithm looks like in pseudocode, assuming the subdecks are named <literal>d1</literal> and <literal>d2</literal>: </para><programlisting language="java">
private static Deck merge(Deck d1, Deck d2) {
    // create a new deck, d3, big enough for all the cards

    // use the index i to keep track of where we are at in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;

    // the index k traverses the result deck
    for (int k = 0; k &lt; d3.length; k++) {
        // if d1 is empty, use top card from d2
        // if d2 is empty, use top card from d1
        // otherwise, compare the top two cards

        // add lowest card to the new deck at k
        // increment i or j (depending on card)
    }
    // return the new deck
}</programlisting><para>An exercise at the end of the chapter asks you to implement <literal>merge</literal>. It’s a little tricky, so be sure to test it with different subdecks. Once your <literal>merge</literal> method is working, you can use it to write a simplified version of merge sort: </para><programlisting language="java">
public Deck almostMergeSort() {
    // divide the deck into two subdecks
    // sort the subdecks using selectionSort
    // merge the subdecks, return the result
}</programlisting><para>If you have working versions of <literal>subdeck</literal>, <literal>selectionSort</literal>, and <literal>merge</literal>, you should have no trouble getting this method working. But it is still not very efficient, because it uses <literal>selectionSort</literal> to sort the subdecks. We can make it more efficient if we use <literal>mergeSort</literal> instead, but that means we have to make it recursive! </para>
</sect1><sect1 id="a0000009907" remap="section">
  <title>Adding Recursion</title>
    <para>To make <literal>mergeSort</literal> work recursively, you have to add a base case; otherwise it repeats forever. </para><para>The simplest base case is a subdeck with 1 cards. If there is only one card, it can’t be out of order, so we consider it sorted. And if it is already sorted, we can just return it. </para><para>And it will turn out to be convenient if we handle another base case, a subdeck with 0 cards. By the same logic, if there are no cards, they can’t be out of order. So we consider an empty deck to be sorted, and return it. </para><para>With these base cases, a recursive version of <literal>mergeSort</literal> looks like this: </para><programlisting language="java">
public Deck mergeSort() {
    // if the deck has 0 or 1 cards, return it
    // otherwise, divide the deck into two subdecks
    // sort the subdecks using mergeSort
    // merge the subdecks
    // return the result
}</programlisting><para><indexterm>
  <primary>leap of faith</primary>

</indexterm>As usual, there are two ways to think about recursive programs: you can follow the flow of execution, or you can make the “leap of faith” (see <xref linkend="fibonacci" />). This example should encourage you to make the leap of faith. </para><para>When you use <literal>selectionSort</literal> to sort the subdecks, you don’t feel compelled to follow the flow of execution. You assume it works because you already debugged it. When you make <literal>mergeSort</literal> recursive, you just replace one sorting algorithm with another. There is no reason to read the program differently. </para><para>Well, almost. You have to think about the base cases and make sure that you reach them. But other than that, writing the recursive version should be no problem. </para><para>As an exercise at the end of this chapter, you’ll have a chance to finish it off. </para>
</sect1><sect1 id="a0000009929" remap="section">
  <title>Static Context</title>
    <para><indexterm>
  <primary>UML</primary>

</indexterm><indexterm>
  <primary>class diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>class</secondary>
</indexterm><xref linkend="fig.deck" /> shows a UML class diagram for <literal>Deck</literal>, including the instance variable, <literal>cards</literal>, and the methods we have so far. In UML diagrams, <literal>private</literal> attributes and methods begin with a minus sign (<literal>-</literal>) and <literal>static</literal> methods are underlined. </para>
  
  <figure id="fig.deck" float="False">
    <title>UML diagram for the <literal>Deck</literal> class.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/deck.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The helper methods <literal>randomInt</literal> and <literal>merge</literal> are <literal>static</literal>, because they do not read or write any instance variables. All other methods are instance methods, because they access the instance variable, <literal>cards</literal>. </para><para>When you have static methods and instance methods in the same class, it is easy to get them confused. </para><para>To invoke an instance method, you need an instance: </para><programlisting language="java">
Deck deck = new Deck();
deck.print();  // correct</programlisting><para><literal>Deck</literal> with a capital <literal>D</literal> is a class, and <literal>deck</literal> with a lowercase <literal>d</literal> is an object. </para><para>If you try to invoke <literal>print</literal> like this: </para><programlisting language="java">
Deck.print();  // wrong!</programlisting><para><indexterm>
  <primary>static context</primary>

</indexterm><indexterm>
  <primary>this</primary>

</indexterm>You get an compiler error like this: </para><programlisting>Non-static method print() cannot be referenced from a
static context.</programlisting><para>By “static context”, the compiler means you are trying to invoke a method in a context that requires a static method. </para><para>On the other hand, if you have a <literal>Deck</literal> object, you can use it to invoke a static method: </para><programlisting language="java">
Deck deck = new Deck();
int i = deck.randomInt(0, 51);  // legal, but not good style</programlisting><para>This is legal, but it is not considered good style, because someone reading this code would expect <literal>randomInt</literal> to be an instance method. </para><para>Another common error is to use <literal>this</literal> in a static method. For example, if you write something like this: </para><programlisting language="java">
private static Deck merge(Deck d1, Deck d2) {
    return this.cards;  // wrong!
}</programlisting><para>You get a compiler error like this: </para><programlisting>Non-static variable this cannot be referenced from a
static context.</programlisting><para>The problem is that <literal>cards</literal> is an instance variable, so it is “non-static”, so you can’t access it from a static method. In general, you can’t use <literal>this</literal> in a static method, because a static method is not invoked on an object. </para><para>For beginners, error messages about non-static context can be confusing and frustrating. We hope this section helps. </para>
</sect1><sect1 id="a0000010006" remap="section">
  <title>Piles of Cards</title>
    <para><indexterm>
  <primary>War (card game)</primary>

</indexterm>Now that we have classes that represent cards and decks, let’s use them to make a game. One of the simplest card games that children play is called “War” (see <ulink url="https://en.wikipedia.org/wiki/War_(card_game)"></ulink>). </para><para>Initially, the deck is divided evenly into two piles, one for each player. During each round, each player takes the top card from their pile and places it, face up, in the center. Whoever has the highest ranking card, ignoring suit, takes the two cards and adds them to the bottom of their pile. The game continues until one player has won the entire deck. </para><para>We could use the <literal>Deck</literal> class to represent the individual piles. However, our implementation of <literal>Deck</literal> uses a <literal>Card</literal> array, and the length of an array can’t change. As the game progresses, we need to be able to add and remove cards from the piles. </para><para><indexterm>
  <primary>ArrayList</primary>

</indexterm><indexterm>
  <primary>collection</primary>

</indexterm>We can solve this problem with an <literal>ArrayList</literal>, which is in the <literal>java.util</literal> package. An <literal>ArrayList</literal> is a <emphasis role="bold">collection</emphasis>, which is an object that contains other objects. It provides methods to add and remove elements, and it grows and shrinks automatically. </para><para><indexterm>
  <primary>Pile</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Pile</secondary>
</indexterm>We define a new class named <literal>Pile</literal> to represent a pile of cards. It uses an <literal>ArrayList</literal> to store <literal>Card</literal> objects. </para><programlisting language="java">
public class Pile {
    private ArrayList&lt;Card&gt; cards;

    public Pile() {
        this.cards = new ArrayList&lt;Card&gt;();
    }
}</programlisting><para><indexterm>
  <primary>angle brackets</primary>

</indexterm><indexterm>
  <primary>brackets</primary>
<secondary>angle</secondary>
</indexterm><indexterm>
  <primary>&lt;&gt; angle brackets</primary>

</indexterm>When you declare an <literal>ArrayList</literal>, you specify the type it contains in angle brackets (<literal>&lt;&gt;</literal>). This declaration says that <literal>cards</literal> is not just an <literal>ArrayList</literal>; it’s an <literal>ArrayList</literal> of <literal>Card</literal> objects. </para><para>The constructor initializes <literal>this.cards</literal> with an empty <literal>ArrayList</literal>. </para><para>Now let’s think about the methods we need to play the game. </para><para>At the beginning of each round, each player draws a card from the top of their pile. So we define a method to do that: </para><programlisting language="java">
public Card popCard() {
    return this.cards.remove(0);  // from the top of the pile
}</programlisting><para><literal>popCard</literal> removes the <literal>Card</literal> at the beginning of the <literal>ArrayList</literal>, which we think of as the top of the pile. </para><para>Because we use <literal>ArrayList.remove</literal>, it automatically shifts the remaining cards to fill the gap. </para><para>At the end of each round, the winner adds cards to the bottom of their pile. So we define a method to do that: </para><programlisting language="java">
public void addCard(Card card) {
    this.cards.add(card);        // to the bottom of the pile
}</programlisting><para><literal>ArrayList</literal> provides a method, <literal>add</literal>, that adds an element to the end of the collection, which we think of as the bottom of the pile. </para><para>To know when to stop the game, have to check if one of the piles is empty. Here’s a method to do that: </para><programlisting language="java">
public boolean isEmpty() {
    return this.cards.isEmpty();
}</programlisting><para>So far, these methods don’t do very much; they just invoke methods on the instance variable, <literal>cards</literal>. Methods like these are called <emphasis role="bold">wrapper methods</emphasis> because they wrap one method with another. </para><para>Finally, to start the game, we need to divide the deck into two equal parts. We can do that with <literal>subdeck</literal> from <xref linkend="subdeck" /> and a new method, <literal>addDeck</literal>: </para><programlisting language="java">
public void addDeck(Deck deck) {
    for (Card card : deck.getCards()) {
        this.cards.add(card);
    }
}</programlisting><para><literal>addDeck</literal> takes a <literal>Deck</literal> object, loops through the cards, and adds them to the <literal>Pile</literal>. Notice that it does not remove the cards from the <literal>Deck</literal>, so the <literal>Deck</literal> and the <literal>Pile</literal> share cards. But that won’t be a problem because cards are immutable. </para>
</sect1><sect1 id="a0000010109" remap="section">
  <title>Playing War</title>
    <para>Now we can use <literal>Deck</literal> and <literal>Pile</literal> to implement the game. We’ll start by creating a deck and shuffling: </para><programlisting language="java">
Deck deck = new Deck();
deck.shuffle();</programlisting><para>Then we divide the <literal>Deck</literal> into two piles: </para><programlisting language="java">
Pile p1 = new Pile();
p1.addDeck(deck.subdeck(0, 25));

Pile p2 = new Pile();
p2.addDeck(deck.subdeck(26, 51));</programlisting><para>The game itself is a loop that repeats until one of the piles is empty. At each iteration, we draw a card from each pile and compare their ranks. </para><programlisting language="java">
while (!p1.isEmpty() &amp;&amp; !p2.isEmpty()) {
    // pop a card from each pile
    Card c1 = p1.popCard();
    Card c2 = p2.popCard();

    // compare the cards
    int diff = c1.getRank() - c2.getRank();
    if (diff &gt; 0) {
        p1.addCard(c1);
        p1.addCard(c2);
    } else if (diff &lt; 0) {
        p2.addCard(c1);
        p2.addCard(c2);
    } else {  
        // it's a tie
    }</programlisting><para>If the two cards have the same rank, it’s a tie. In that case, each player draws four more cards. Whoever has the higher fourth card takes all cards in play. If there’s another tie, they draw another four cards, and so on. </para><para>One of the exercises at the end of this chapter asks you to implement the <literal>else</literal> block when there’s a tie. </para><para>After the <literal>while</literal> loop ends, we display the winner based on which pile is not empty. </para><programlisting language="java">
if (p2.isEmpty()) {
    System.out.println("Player 1 wins!");
} else {
    System.out.println("Player 2 wins!");
}</programlisting><para><literal>ArrayList</literal> provides many other methods that we didn’t use for this example. Take a minute to read the documentation, which you can find by doing a web search for “Java ArrayList”. </para>
</sect1><sect1 id="a0000010137" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>pseudocode:</term>
      <listitem><para><indexterm>
  <primary>pseudocode</primary>

</indexterm>A way of designing programs by writing rough drafts in a combination of English and Java. </para></listitem>
  </varlistentry><varlistentry>
    <term>helper method:</term>
      <listitem><para><indexterm>
  <primary>helper method</primary>

</indexterm>A method that implements part of a more complex algorithm; often it is not particularly useful on its own. </para></listitem>
  </varlistentry><varlistentry>
    <term>top-down design:</term>
      <listitem><para><indexterm>
  <primary>top-down design</primary>

</indexterm>Breaking down a problem into sub-problems, and solving each sub-problem one at a time. </para></listitem>
  </varlistentry><varlistentry>
    <term>selection sort:</term>
      <listitem><para><indexterm>
  <primary>selection sort</primary>

</indexterm>A simple sorting algorithm that searches for the smallest or largest element <emphasis role="math">n</emphasis> times. </para></listitem>
  </varlistentry><varlistentry>
    <term>merge sort:</term>
      <listitem><para><indexterm>
  <primary>merge sort</primary>

</indexterm>A recursive sorting algorithm that divides an array into two parts, sorts each part (using merge sort), and merges the results. </para></listitem>
  </varlistentry><varlistentry>
    <term>off-by-one:</term>
      <listitem><para><indexterm>
  <primary>off-by-one</primary>

</indexterm>A common programming mistake that results in iterating one time too many, or too few. </para></listitem>
  </varlistentry><varlistentry>
    <term>static context:</term>
      <listitem><para><indexterm>
  <primary>static context</primary>

</indexterm>The parts of a class that run without reference to a specific instance of the class. </para></listitem>
  </varlistentry><varlistentry>
    <term>collection:</term>
      <listitem><para><indexterm>
  <primary>collection</primary>

</indexterm>A Java library class, like <literal>ArrayList</literal>, that represents a group of objects. </para></listitem>
  </varlistentry><varlistentry>
    <term>wrapper method:</term>
      <listitem><para><indexterm>
  <primary>wrapper method</primary>

</indexterm>A method that calls another method without doing much additional work. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000010161" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch13</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000010170" role="exercise">
  <title></title>
  <para>Write a <literal>toString</literal> method for the <literal>Deck</literal> class. It should return a single string that represents the cards in the deck. When it’s printed, this string should display the same results as the <literal>print</literal> method in <xref linkend="deck" />. </para><para><indexterm>
  <primary>StringBuilder</primary>

</indexterm><indexterm>
  <primary>efficiency</primary>

</indexterm><emphasis>Hint:</emphasis> You can use the <literal>+</literal> operator to concatenate strings, but it is not very efficient. Consider using <literal>java.lang.StringBuilder</literal> instead; see <xref linkend="stringbuilder" />. </para>
</example> </para><para><example id="ex.shuffle" role="exercise">
  <title></title><para>The goal of this exercise is to implement the shuffling algorithm from this chapter. </para><orderedlist>
  
  <listitem><para>In the repository for this book, you should find the file named <literal>Deck.java</literal>. Check that you can compile it in your environment. </para></listitem>
  
  <listitem><para>Implement the <literal>randomInt</literal> method. You can use the <literal>nextInt</literal> method provided by <literal>java.util.Random</literal>, which we saw in <xref linkend="random" />. </para><para><emphasis>Hint:</emphasis> To avoid creating a <literal>Random</literal> object every time <literal>randomInt</literal> is invoked, consider defining a class variable. </para></listitem>
  
  <listitem><para>Write a <literal>swapCards</literal> method that takes two indexes and swaps the cards at the given locations. </para></listitem>
  
  <listitem><para>Fill in the <literal>shuffle</literal> method using the algorithm in <xref linkend="shuffle" />. </para></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000010228" role="exercise">
  <title></title>
  <para>The goal of this exercise is to implement the sorting algorithms from this chapter. Use the <literal>Deck.java</literal> file from the previous exercise, or create a new one from scratch. </para><orderedlist>
  
  <listitem><para>Implement the <literal>indexLowest</literal> method. Use the <literal>Card.compareTo</literal> method to find the lowest card in a given range of the deck, from <literal>lowIndex</literal> to <literal>highIndex</literal>, including both. </para></listitem>
  
  <listitem><para>Fill in <literal>selectionSort</literal> using the algorithm in <xref linkend="sorting" />. </para></listitem>
  
  <listitem><para>Using the pseudocode in <xref linkend="mergesort" />, implement the <literal>merge</literal> method. The best way to test it is to build and shuffle a deck. Then use <literal>subdeck</literal> to form two small subdecks, and use selection sort to sort them. Finally, pass the two halves to <literal>merge</literal> and see if it works.<indexterm>
  <primary>testing</primary>

</indexterm></para></listitem>
  
  <listitem><para>Fill in <literal>almostMergeSort</literal>, which divides the deck in half, then uses <literal>selectionSort</literal> to sort the two halves, and uses <literal>merge</literal> to create a new, sorted deck. You should be able to reuse code from the previous step. </para></listitem>
  
  <listitem><para>Implement <literal>mergeSort</literal> recursively. Remember that <literal>selectionSort</literal> is a modifier and <literal>mergeSort</literal> is a pure method, which means that they get invoked differently: </para><programlisting language="java">
deck.selectionSort();      // modifies an existing deck
deck = deck.mergeSort();   // replaces old deck with new</programlisting></listitem>
  
</orderedlist>
</example> </para><para><example id="a0000010279" role="exercise">
  <title></title>
  <para>You can learn more about the sorting algorithms presented in this chapter at <ulink url="https://www.toptal.com/developers/sorting-algorithms"></ulink>. This site provides explanations of the algorithms, along with animations that show how they work. It also includes an analysis of their efficiency. </para><para>For example, “insertion sort” is an algorithm that inserts elements into place, one at a time. Read about it on the website and play the animations. Then write a method named <literal>insertionSort</literal> that implements this algorithm. </para><para>One goal of this exercise is to practice top-down design. Your solution should use a helper method, named <literal>insert</literal>, that implements the inner loop of the algorithm. <literal>insertionSort</literal> should invoke this method <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inlineequation> times. </para>
</example> </para><para><example id="a0000010292" role="exercise">
  <title></title>
  <para>Find and open the file <literal>War.java</literal> in the repository. The <literal>main</literal> method contains all the code from the last section of this chapter. Check that you can compile and run this code before proceeding. </para><para>The program is incomplete; it does not handle the case when two cards have the same rank. Finish implementing the <literal>main</literal> method, beginning at the line that says: <literal>// it’s a tie</literal>. </para><para>When there’s a tie, draw three cards from each pile and store them in a collection, along with the original two. Then draw one more card from each pile and compare them. Whoever wins the tie takes all ten of these cards. </para><para>If one pile does not have at least four cards, the game ends immediately. If a tie ends with a tie, draw three more cards, and so on. </para><para>Notice that this program depends on <literal>Deck.shuffle</literal> so you might have to do <xref linkend="ex.shuffle" /> first. </para>
</example> </para>
</sect1>
</chapter><chapter id="eights">
  <title>Extending Classes</title><para><indexterm>
  <primary>Crazy Eights</primary>

</indexterm>In this chapter, we will present a comprehensive example of object-oriented programming. <emphasis>Crazy Eights</emphasis> is a classic card game for two or more players. The main objective is to be the first player to get rid of all your cards. Here’s how to play: </para><itemizedlist>
  
    <listitem><para>Deal five or more cards to each player, and then deal one card face up to create the “discard pile”. Place the remaining cards face down to create the “draw pile”. </para></listitem>
  
    <listitem><para>Each player takes turns placing a single card on the discard pile. The card must match the rank or suit of the previously played card, or be an eight, which is a “wild card”. </para></listitem>
  
    <listitem><para>When players don’t have a matching card or an eight, they must draw new cards until they get one. </para></listitem>
  
    <listitem><para>If the draw pile ever runs out, the discard pile is shuffled (except the top card) and becomes the new draw pile. </para></listitem>
  
    <listitem><para>As soon as a player has no cards, the game ends and all other players score penalty points for their remaining cards. Eights are worth 20, face cards are worth 10, and all others are worth their rank. </para></listitem>
  
</itemizedlist><para>You can read <ulink url="https://en.wikipedia.org/wiki/Crazy_Eights"></ulink> for more details, but we have enough to get started. </para><sect1 id="a0000010330" remap="section">
  <title>CardCollection</title>
    <para>To implement <emphasis>Crazy Eights</emphasis>, we need to represent a deck of cards, a discard pile, a draw pile, and a hand for each player. And we need to be able to deal, draw, and discard cards. </para><para>The <literal>Deck</literal> and <literal>Pile</literal> classes from the previous chapter meet some of these requirements. But unless we make some changes, neither of them represents a hand of cards very well. </para><para><indexterm>
  <primary>ArrayList</primary>

</indexterm>Furthermore, <literal>Deck</literal> and <literal>Pile</literal> are essentially two versions of the same code: one based on arrays, and the other based on <literal>ArrayList</literal>. It would be helpful to combine their features into one class that meets the needs of both. </para><para><indexterm>
  <primary>CardCollection</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>CardCollection</secondary>
</indexterm>We will define a class named <literal>CardCollection</literal> and add the code we want one step at a time. Since this class will represent different piles and hands of cards, we’ll add a <literal>label</literal> attribute to tell them apart. </para><programlisting language="java">
public class CardCollection {

    private String label;
    private ArrayList&lt;Card&gt; cards;

    public CardCollection(String label) {
        this.label = label;
        this.cards = new ArrayList&lt;Card&gt;();
    }
}</programlisting><para>As with the <literal>Pile</literal> class, we need a way to add cards to the collection. Here is the <literal>addCard</literal> method from the previous chapter: </para><programlisting language="java">
public void addCard(Card card) {
    this.cards.add(card);
}</programlisting><para><indexterm>
  <primary>this</primary>

</indexterm>Until now, we have used <literal>this</literal> explicitly to make it easy to identify attributes. Inside <literal>addCard</literal> and other instance methods, you can access instance variables without using the keyword <literal>this</literal>. So from here on, we will drop it: </para><programlisting language="java">
public void addCard(Card card) {
    cards.add(card);
}</programlisting><para>We also need to be able to remove cards from the collection. The following method takes an index, removes the card at that location, and shifts the following cards left to fill the gap: </para><programlisting language="java">
public Card popCard(int i) {
    return cards.remove(i);
}</programlisting><para><indexterm>
  <primary>efficiency</primary>

</indexterm>If we are dealing cards from a shuffled deck, we don’t care which card gets removed. It is most efficient to choose the last one, so we don’t have to shift any cards left. Here is an overloaded version of <literal>popCard</literal> that removes and returns the last card: </para><programlisting language="java">
public Card popCard() {
    int i = cards.size() - 1;    // from the end of the list
    return popCard(i);
}</programlisting><para><literal>CardCollection</literal> also provides <literal>isEmpty</literal>, returns <literal>true</literal> if there are no cards left: </para><programlisting language="java">
public boolean isEmpty() {
    return cards.isEmpty()
}</programlisting><para>To access the elements of an <literal>ArrayList</literal>, you can’t use the array <literal>[]</literal> operator. Instead, you have to use the methods <literal>get</literal> and <literal>set</literal>. Here is a wrapper for <literal>get</literal>: </para><programlisting language="java">
public Card getCard(int i) {
    return cards.get(i);
}</programlisting><para><literal>lastCard</literal> gets the last card (but doesn’t remove it): </para><programlisting language="java">
public Card lastCard() {
    int i = size() - 1;
    return cards.get(i);
}</programlisting><para><indexterm>
  <primary>modifier method</primary>

</indexterm><indexterm>
  <primary>method</primary>
<secondary>modifier</secondary>
</indexterm>In order to control the ways card collections are modified, we don’t provide a wrapper for <literal>set</literal>. The only modifiers we provide are the two versions of <literal>popCard</literal> and the following version of <literal>swapCards</literal>: </para><programlisting language="java">
public void swapCards(int i, int j) {
    Card temp = cards.get(i);
    cards.set(i, cards.get(j));
    cards.set(j, temp);
}</programlisting><para>Finally, we use <literal>swapCards</literal> to implement <literal>shuffle</literal>, which we described in <xref linkend="shuffle" />: </para><programlisting language="java">
public void shuffle() {
    Random random = new Random();
    for (int i = size() - 1; i &gt; 0; i--) {
        int j = random.nextInt(i + 1);
        swapCards(i, j);
    }
}</programlisting></sect1><sect1 id="a0000010427" remap="section">
  <title>Inheritance</title>
    <para>At this point we have a class that represents a collection of cards. It provides functionality common to decks of cards, piles of cards, hands of cards, and potentially other collections. </para><para><indexterm>
  <primary>inheritance</primary>

</indexterm><indexterm>
  <primary>subclass</primary>

</indexterm><indexterm>
  <primary>extends</primary>

</indexterm>However, each kind of collection will be slightly different. Rather than add every possible feature to <literal>CardCollection</literal>, we can use <emphasis role="bold">inheritance</emphasis> to define subclasses. A <emphasis role="bold">subclass</emphasis> is a class that “extends” an existing class; that is, it has the attributes and methods of the existing class, plus more. </para><para>Here is the complete definition of our new and improved <literal>Deck</literal> class: </para><programlisting language="java">
public class Deck extends CardCollection {

    public Deck(String label) {
        super(label);
        for (int suit = 0; suit &lt;= 3; suit++) {
            for (int rank = 1; rank &lt;= 13; rank++) {
                addCard(new Card(rank, suit));
            }
        }
    }
}</programlisting><para><indexterm>
  <primary>extends</primary>

</indexterm><indexterm>
  <primary>superclass</primary>

</indexterm>The first line uses the keyword <literal>extends</literal> to indicate that <literal>Deck</literal> extends the class <literal>CardCollection</literal>. That means a <literal>Deck</literal> object has the same instance variables and methods as a <literal>CardCollection</literal>. Another way to say the same thing is that <literal>Deck</literal> “inherits from” <literal>CardCollection</literal>. We could also say that <literal>CardCollection</literal> is a <emphasis role="bold">superclass</emphasis>, and <literal>Deck</literal> is one of its subclasses. </para><para><indexterm>
  <primary>Object class</primary>

</indexterm>In Java, classes may only extend one superclass. Classes that do not specify a superclass with <literal>extends</literal> automatically inherit from <literal>java.lang.Object</literal>. So in this example, <literal>Deck</literal> extends <literal>CardCollection</literal>, which in turn extends <literal>Object</literal>. The <literal>Object</literal> class provides the default <literal>equals</literal> and <literal>toString</literal> methods, among other things. </para><para>Constructors are <emphasis>not</emphasis> inherited, but all other <literal>public</literal> attributes and methods are. The only additional method in <literal>Deck</literal>, at least for now, is a constructor. So you can create a <literal>Deck</literal> object like this: </para><programlisting language="java">
Deck deck = new Deck("Deck");</programlisting><para>The first line of the constructor uses <literal>super</literal>, which is a keyword that refers to the superclass of the current class. When <literal>super</literal> is used like a method, as in this example, it invokes the constructor of the superclass. </para><para>So in this case, <literal>super</literal> invokes the <literal>CardCollection</literal> constructor, which initializes the attributes <literal>label</literal> and <literal>cards</literal>. When it returns, the <literal>Deck</literal> constructor resumes and populates the (empty) <literal>ArrayList</literal> with <literal>Card</literal> objects. </para><para><indexterm>
  <primary>Hand</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Hand</secondary>
</indexterm>That’s it for the <literal>Deck</literal> class. Next we need a way to represent a hand, which is the collection of cards held by a player, and a pile, which is a collection of cards on the table. We could define two classes, one for hands and one for piles, but there is not much difference between them. So we’ll use one class, called <literal>Hand</literal>, for both hands and piles. Here’s what the definition looks like: </para><programlisting language="java">
public class Hand extends CardCollection {

    public Hand(String label) {
        super(label);
    }

    public void display() {
        System.out.println(getLabel() + ": ");
        for (int i = 0; i &lt; size(); i++) {
            System.out.println(getCard(i));
        }
        System.out.println();
    }
}</programlisting><para>Like <literal>Deck</literal>, the <literal>Hand</literal> class extends <literal>CardCollection</literal>. So it inherits methods like <literal>getLabel</literal>, <literal>size</literal>, and <literal>getCard</literal>, which are used in <literal>display</literal>. <literal>Hand</literal> also provides a constructor, which invokes the constructor of <literal>CardCollection</literal>. </para><para>In summary, a <literal>Deck</literal> is just like a <literal>CardCollection</literal>, but it provides a different constructor. And a <literal>Hand</literal> is just like a <literal>CardCollection</literal>, but it provides an additional method, <literal>display</literal>. </para>
</sect1><sect1 id="dealing" remap="section">
  <title>Dealing Cards</title><para>To begin the game, we need to deal cards to each of the players. And during the game, we need to move cards between hands and piles. If we add the following method to <literal>CardCollection</literal>, it can meet both of these requirements. </para><programlisting language="java">
public void deal(CardCollection that, int n) {
    for (int i = 0; i &lt; n; i++) {
        Card card = popCard();
        that.addCard(card);
    }
}</programlisting><para>The <literal>deal</literal> method removes cards from the collection it is invoked on, <literal>this</literal>, and adds them to the collection it gets as a parameter, <literal>that</literal>. The second parameter, <literal>n</literal>, is the number of cards to deal. We will use this method to implement <literal>dealAll</literal>, which deals (or moves) all of the remaining cards. </para><programlisting language="java">
public void dealAll(CardCollection that) {
    int n = size();
    deal(that, n);
}</programlisting><para>At this point we can create a <literal>Deck</literal> and start dealing cards. Here’s a simple example that deals five cards to a hand, and deals the rest into a draw pile: </para><programlisting language="java">
Deck deck = new Deck("Deck");
deck.shuffle();

Hand hand = new Hand("Hand");
deck.deal(hand, 5);
hand.display();

Hand drawPile = new Hand("Draw Pile");
deck.dealAll(drawPile);
System.out.printf("Draw Pile has %d cards.\n",
                  drawPile.size());</programlisting><para>Because the deck is shuffled randomly, you should get a different hand each time you run this example. The output will look something like: </para><programlisting>Hand:
5 of Diamonds
Ace of Hearts
6 of Clubs
6 of Diamonds
2 of Clubs

Draw Pile has 47 cards.</programlisting><para>If you are a careful reader, you might notice something strange about this example. Take another look at the definition of <literal>deal</literal>. Notice that the first parameter is supposed to be a <literal>CardCollection</literal>. But we invoked it like this: </para><programlisting language="java">
Hand hand = new Hand("Hand");
deck.deal(hand, 5);</programlisting><para>The argument is a <literal>Hand</literal>, not a <literal>CardCollection</literal>. So why is this example legal? </para><para>It’s because <literal>Hand</literal> is a subclass of <literal>CardCollection</literal>, so a <literal>Hand</literal> object is also considered to be a <literal>CardCollection</literal> object. If a method expects a <literal>CardCollection</literal>, you can give it a <literal>Hand</literal>, a <literal>Deck</literal>, or a <literal>CardCollection</literal>. </para><para>But it doesn’t work the other way around: not every <literal>CardCollection</literal> is a <literal>Hand</literal>, so if a method expects a <literal>Hand</literal>, you have to give it a <literal>Hand</literal>, not a <literal>CardCollection</literal> or a <literal>Deck</literal>. </para><para>If it seems strange that an object can belong to more than one type, remember that this happens in real life, too. Every cat is also a mammal, and every mammal is also an animal. But not every animal is a mammal, and not every mammal is a cat. </para>
</sect1><sect1 id="a0000010622" remap="section">
  <title>The Player Class</title>
    <para>The <literal>Deck</literal> and <literal>Hand</literal> classes we have defined so far could be used for any card game; we have not yet implemented any of the rules specific to <emphasis>Crazy Eights</emphasis>. And that’s probably a good thing, since it makes it easy to reuse these classes if we want to make another game in the future. </para><para><indexterm>
  <primary>Player</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Player</secondary>
</indexterm>But now it’s time to implement the rules. We’ll use two classes: <literal>Player</literal>, which encapsulates player strategy, and <literal>Eights</literal>, which creates and maintains the state of the game. Here is the beginning of the <literal>Player</literal> definition: </para><programlisting language="java">
public class Player {

    private String name;
    private Hand hand;

    public Player(String name) {
        this.name = name;
        this.hand = new Hand(name);
    }</programlisting><para>A <literal>Player</literal> has two <literal>private</literal> attributes: a name and a hand. The constructor takes the player’s name as a string and saves it in an instance variable. In this example, we have to use <literal>this</literal> to distinguish between the instance variable and the parameter with the same name. </para><para>The primary method that <literal>Player</literal> provides is <literal>play</literal>, which decides which card to discard during each turn: </para><programlisting language="java">
public Card play(Eights eights, Card prev) {
    Card card = searchForMatch(prev);
    if (card == null) {
        card = drawForMatch(eights, prev);
    }
    return card;
}</programlisting><para>The first parameter is a reference to the <literal>Eights</literal> object that encapsulates the state of the game (coming up in the next section). The second parameter, <literal>prev</literal>, is the card on top of the discard pile. </para><para><literal>play</literal> invokes two helper methods: <literal>searchForMatch</literal> and <literal>drawForMatch</literal>. Since we have not written them yet, this is an example of top-down development. </para><para><indexterm>
  <primary>top-down development</primary>

</indexterm>Here’s <literal>searchForMatch</literal>, which looks in the player’s hand for a card that matches the previously played card: </para><programlisting language="java">
public Card searchForMatch(Card prev) {
    for (int i = 0; i &lt; hand.size(); i++) {
        Card card = hand.getCard(i);
        if (cardMatches(card, prev)) {
            return hand.popCard(i);
        }
    }
    return null;
}</programlisting><para>The strategy is pretty simple: the <literal>for</literal> loop searches for the first card that’s legal to play and returns it. If there are no cards that match, it returns <literal>null</literal>. In that case, we have to draw cards until we get a match, which is what <literal>drawForMatch</literal> does: </para><programlisting language="java">
public Card drawForMatch(Eights eights, Card prev) {
    while (true) {
        Card card = eights.drawCard();
        System.out.println(name + " draws " + card);
        if (cardMatches(card, prev)) {
            return card;
        }
        hand.addCard(card);
    }
}</programlisting><para>The <literal>while</literal> loop runs until it finds a match (we’ll assume for now that it always does). It uses the <literal>Eights</literal> object to draw a card. If it matches, it returns the card. Otherwise it adds the card to the player’s hand and repeats. </para><para>Both <literal>searchForMatch</literal> and <literal>drawForMatch</literal> use <literal>cardMatches</literal>, which is a static method, also defined in <literal>Player</literal>. This method is a straightforward translation of the rules of the game: </para><programlisting language="java">
public static boolean cardMatches(Card card1, Card card2) {
    return card1.getSuit() == card2.getSuit()
        || card1.getRank() == card2.getRank()
        || card1.getRank() == 8;
}</programlisting><para>Finally, <literal>Player</literal> provides a <literal>score</literal> method, which computes penalty points for cards left in a player’s hand at the end of the game. </para>
</sect1><sect1 id="a0000010702" remap="section">
  <title>The Eights Class</title>
    <para><indexterm>
  <primary>top-down development</primary>

</indexterm>In <xref linkend="shuffle" /> we introduced top-down development, which is a way of developing programs by identifying high-level goals, like shuffling a deck, and breaking them into smaller problems, like choosing a random element or swapping two elements. </para><para><indexterm>
  <primary>bottom-up design</primary>

</indexterm><indexterm>
  <primary>design process</primary>

</indexterm>In this section we present <emphasis role="bold">bottom-up design</emphasis>, which goes the other way around: first we identify simple pieces we need, then we assemble them into more complex algorithms. </para><para>Looking at the rules of <emphasis>Crazy Eights</emphasis>, we can identify some of the methods we’ll need: </para><itemizedlist>
  
    <listitem><para>Create the deck, the players, and the discard and draw piles. Deal the cards and set up the game. (<literal>Eights</literal> constructor) </para></listitem>
  
    <listitem><para>Check whether the game is over. (<literal>isDone</literal>) </para></listitem>
  
    <listitem><para>If the draw pile is empty, shuffle the discard pile and move the cards into the draw pile. (<literal>reshuffle</literal>) </para></listitem>
  
    <listitem><para>Draw a card, reshuffling the discard pile if necessary. (<literal>drawCard</literal>) </para></listitem>
  
    <listitem><para>Keep track of whose turn it is, and switch from one player to the next. (<literal>nextPlayer</literal>) </para></listitem>
  
    <listitem><para>Display the state of the game, and wait for the user before running the next turn. (<literal>displayState</literal>) </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>Eights</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Eights</secondary>
</indexterm>Now we can start implementing the pieces. Here is the beginning of the class definition for <literal>Eights</literal>, which encapsulates the state of the game: </para><programlisting language="java">
public class Eights {

    private Player one;
    private Player two;
    private Hand drawPile;
    private Hand discardPile;
    private Scanner in;</programlisting><para>In this version, there are always two players. One of the exercises at the end of the chapter asks you to modify this code to handle more players. The <literal>Eights</literal> class also includes a draw pile, a discard pile, and a <literal>Scanner</literal>, which we will use to prompt the user after each turn. </para><para>The constructor for <literal>Eights</literal> initializes the instance variables and deals the cards, similar to <xref linkend="dealing" />. The next piece we’ll need is a method that checks whether the game is over. If either hand is empty, we’re done: </para><programlisting language="java">
public boolean isDone() {
    return one.getHand().isEmpty() || two.getHand().isEmpty();
}</programlisting><para>When the draw pile is empty, we have to shuffle the discard pile. Here is a method for that: </para><programlisting language="java">
public void reshuffle() {
    Card prev = discardPile.popCard();
    discardPile.dealAll(drawPile);
    discardPile.addCard(prev);
    drawPile.shuffle();
}</programlisting><para>The first line saves the top card from <literal>discardPile</literal>. The next line transfers the rest of the cards to <literal>drawPile</literal>. Then we put the saved card back into <literal>discardPile</literal> and shuffle <literal>drawPile</literal>. We can use <literal>reshuffle</literal> as part of the <literal>draw</literal> method: </para><programlisting language="java">
public Card drawCard() {
    if (drawPile.isEmpty()) {
        reshuffle();
    }
    return drawPile.popCard();
}</programlisting><para>The <literal>nextPlayer</literal> method takes the current player as a parameter and returns the player who should go next. </para><programlisting language="java">
public Player nextPlayer(Player current) {
    if (current == one) {
        return two;
    } else {
        return one;
    }
}</programlisting><para>The last method from our bottom-up design is <literal>displayState</literal>. It displays the hand of each player, the contents of the discard pile, and how many cards are in the draw pile. Finally, it waits for the user to press the Enter key. </para><programlisting language="java">
public void displayState() {
    one.display();
    two.display();
    discardPile.display();
    System.out.println("Draw pile:");
    System.out.println(drawPile.size() + " cards");
    in.nextLine();
}</programlisting><para>Using these pieces, we can write <literal>takeTurn</literal>, which executes one player’s turn. It reads the top card off the discard pile and passes it to <literal>player.play</literal>, which we saw in the previous section. The result is the card the player chose, which is added to the discard pile. </para><programlisting language="java">
public void takeTurn(Player player) {
    Card prev = discardPile.lastCard();
    Card next = player.play(this, prev);
    discardPile.addCard(next);

    System.out.println(player.getName() + " plays " + next);
    System.out.println();
}</programlisting><para>Finally, we use <literal>takeTurn</literal> and the other methods to write <literal>playGame</literal>: </para><programlisting language="java">
public void playGame() {
    Player player = one;

    // keep playing until there's a winner
    while (!isDone()) {
        displayState();
        takeTurn(player);
        player = nextPlayer(player);
    }

    // display the final score
    one.displayScore();
    two.displayScore();
}</programlisting><para>Done! The result of bottom-up design is similar to top-down: we have a high-level method that calls helper methods. The difference is the development process we used to arrive at this solution. </para>
</sect1><sect1 id="a0000010803" remap="section">
  <title>Class Relationships</title>
    <para><indexterm>
  <primary>class</primary>
<secondary>relationships</secondary>
</indexterm>This chapter demonstrates two common relationships between classes: </para><variablelist>
  <varlistentry>
    <term>composition:</term>
      <listitem><para><indexterm>
  <primary>composition</primary>

</indexterm>Instances of one class contain references to instances of another class. For example, an instance of <literal>Eights</literal> contains references to two <literal>Player</literal> objects, two <literal>Hand</literal> objects, and a <literal>Scanner</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>inheritance:</term>
      <listitem><para><indexterm>
  <primary>inheritance</primary>

</indexterm>One class extends another class. For example, <literal>Hand</literal> extends <literal>CardCollection</literal>, so every instance of <literal>Hand</literal> is also a <literal>CardCollection</literal>. </para></listitem>
  </varlistentry>
</variablelist><para><indexterm>
  <primary>HAS-A</primary>

</indexterm><indexterm>
  <primary>IS-A</primary>

</indexterm><indexterm>
  <primary>object-oriented</primary>

</indexterm>Composition is also known as a <emphasis role="bold">HAS-A</emphasis> relationship, as in “<literal>Eights</literal> HAS-A <literal>Scanner</literal>”. Inheritance is also known as an <emphasis role="bold">IS-A</emphasis> relationship, as in “a <literal>Hand</literal> IS-A <literal>CardCollection</literal>”. This vocabulary provides a concise way to talk about an object-oriented design. </para><para><indexterm>
  <primary>UML</primary>

</indexterm><indexterm>
  <primary>class diagram</primary>

</indexterm><indexterm>
  <primary>diagram</primary>
<secondary>class</secondary>
</indexterm>There is also a standard way to represent these relationships graphically in UML class diagrams. As we saw in <xref linkend="UML" />, the UML representation of a class is a box with three sections: the class name, the attributes, and the methods. The latter two sections are optional when showing relationships. </para>
  
  <figure id="fig.uml1" float="False">
    <title>UML diagram for the classes in this chapter.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/uml1.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Relationships between classes are represented by arrows: composition arrows have a standard arrow head, and inheritance arrows have a hollow triangle head (usually pointing up). <xref linkend="fig.uml1" /> shows the classes defined in this chapter and the relationships among them. </para><para>UML is an international standard, so almost any software engineer in the world could look at this diagram and understand our design. And class diagrams are only one of many graphical representations defined in the UML standard. </para>
</sect1><sect1 id="a0000010857" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>inheritance:</term>
      <listitem><para><indexterm>
  <primary>inheritance</primary>

</indexterm>The ability to define a new class that has the same instance variables and methods of an existing class. </para></listitem>
  </varlistentry><varlistentry>
    <term>subclass:</term>
      <listitem><para><indexterm>
  <primary>subclass</primary>

</indexterm>A class that inherits from, or extends, an existing class. </para></listitem>
  </varlistentry><varlistentry>
    <term>superclass:</term>
      <listitem><para><indexterm>
  <primary>superclass</primary>

</indexterm>An existing class that is extended by another class. </para></listitem>
  </varlistentry><varlistentry>
    <term>bottom-up design:</term>
      <listitem><para><indexterm>
  <primary>bottom-up design</primary>

</indexterm>A way of developing programs by identifying simple pieces, implementing them, and then assembling them into more complex algorithms. </para></listitem>
  </varlistentry><varlistentry>
    <term>HAS-A:</term>
      <listitem><para><indexterm>
  <primary>HAS-A</primary>

</indexterm>A relationship between two classes where one class “has” an instance of another class as one of its attributes. </para></listitem>
  </varlistentry><varlistentry>
    <term>IS-A:</term>
      <listitem><para><indexterm>
  <primary>IS-A</primary>

</indexterm>A relationship between two classes where one class extends another class; the subclass “is” an instance of the superclass. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000010872" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch14</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000010881" role="exercise">
  <title></title>
  <para>Design a better strategy for the <literal>Player.play</literal> method. For example, if there are multiple cards you can play, and one of them is an eight, you might want to play the eight. </para><para><indexterm>
  <primary>override</primary>

</indexterm>Think of other ways you can minimize penalty points, such as playing the highest-ranking cards first. Write a new class that extends <literal>Player</literal> and overrides <literal>play</literal> to implement your strategy. </para>
</example> </para><para><example id="a0000010892" role="exercise">
  <title></title>
  <para>Write a loop that plays the game 100 times and keeps track of how many times each player wins. If you implemented multiple strategies in the previous exercise, you can play them against each other to evaluate which one works best. </para><para><emphasis>Hint:</emphasis> Design a <literal>Genius</literal> class that extends <literal>Player</literal> and overrides the <literal>play</literal> method, and then replace one of the players with a <literal>Genius</literal> object. </para>
</example> </para><para><example id="a0000010906" role="exercise">
  <title></title>
  <para>One limitation of the program we wrote in this chapter is that it only handles two players. Modify the <literal>Eights</literal> class to create an <literal>ArrayList</literal> of players, and modify <literal>nextPlayer</literal> to select the next player. </para>
</example> </para><para><example id="a0000010915" role="exercise">
  <title></title>
  <para>When we designed the program for this chapter, we tried to minimize the number of classes. As a result, we ended up with a few awkward methods. For example, <literal>cardMatches</literal> is a static method in <literal>Player</literal>, but it would be more natural if it were an instance method in <literal>Card</literal>. </para><para>The problem is that <literal>Card</literal> is supposed to be useful for any card game, not just <emphasis>Crazy Eights</emphasis>. You can solve this problem by adding a new class, <literal>EightsCard</literal>, that extends <literal>Card</literal> and provides a method, <literal>match</literal>, that checks whether two cards match according to the rules of <emphasis>Crazy Eights</emphasis>. </para><para>At the same time, you could create a new class, <literal>EightsHand</literal>, that extends <literal>Hand</literal> and provides a method, <literal>scoreHand</literal>, that adds up the scores of the cards in the hand. And while you’re at it, you could add a method named <literal>scoreCard</literal> to <literal>EightsCard</literal>. </para><para>Whether or not you actually make these changes, draw a UML class diagram that shows this alternative object hierarchy. </para>
</example> </para>
</sect1>
</chapter><chapter id="conway">
  <title>Arrays of Arrays</title><para>The last two chapters of this book use 2D graphics to illustrate more advanced object-oriented concepts. If you haven’t yet read <xref linkend="graphics" />, you might want to read it now and get familiar with the <literal>Canvas</literal>, <literal>Color</literal>, and <literal>Graphics</literal> classes from the <literal>java.awt</literal> package. In this chapter we use these classes to draw images and animations, and to run graphical simulations. </para><sect1 id="a0000010961" remap="section">
  <title>Conway’s Game of Life</title>
    <para><emphasis>The Game of Life</emphasis>, or GoL for short, was developed by John Conway and popularized in 1970 in Martin Gardner’s column in Scientific American. Conway calls it a “zero-player game” because no players are needed to choose strategies or make decisions. After you set up the initial conditions, you watch the game play itself. That turns out to be more interesting than it sounds; you can read about it at <ulink url="http://en.wikipedia.org/wiki/Conway’s_Game_of_Life"></ulink>. </para>
  
  <figure id="fig..glider" float="False">
    <title>A “Glider” in the Game of Life.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/glider.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The game board is a two-dimensional grid of square cells. Each cell is either “alive” or “dead”; the color of the cell indicates its state. <xref linkend="fig..glider" /> shows an example grid configuration; the five black cells are alive. </para><para><indexterm>
  <primary>neighbor</primary>

</indexterm>The game proceeds in time steps, during which each cell interacts with its neighbors in the eight adjacent cells. At each time step, the following rules are applied: </para><orderedlist>
  
  <listitem><para>A live cell with fewer than two live neighbors dies, as if by underpopulation. </para><para>A live cell with more than three live neighbors dies, as if by overpopulation. </para><para>A dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. </para></listitem>
  
</orderedlist><para><indexterm>
  <primary>stable configuration</primary>

</indexterm>Notice some consequences of these rules. If you start with a single live cell, it dies. If all cells are dead, no cells come to life. But if you have four cells in a square, they keep each other alive, so that’s a “stable” configuration. </para><para>Another initial configuration is shown in <xref linkend="fig..blinker" />. If you start with three horizontal cells, the center cell lives, the left and right cells die, and the top and bottom cells come to life. The result after the first time step is three vertical cells. </para><para>During the next time step, the center cell lives, the top and bottom cells die, and the left and right cells come to life. The result is three horizontal cells, so we’re back where we started, and the cycle repeats forever. </para>
  
  <figure id="fig..blinker" float="False">
    <title>A “Blinker” in the Game of Life.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/blinker-0.png"></imagedata>
  </imageobject>
</mediaobject> 
  
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/img-0001.png" contentwidth="74px" contentdepth="27px"></imagedata>
    </imageobject>
    <textobject>
      <phrase>\raisebox{38pt}{~ $\longrightarrow $~ }</phrase>
    </textobject>
  </mediaobject>
 <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/blinker-1.png"></imagedata>
  </imageobject>
</mediaobject> 
  
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/img-0001.png" contentwidth="74px" contentdepth="27px"></imagedata>
    </imageobject>
    <textobject>
      <phrase>\raisebox{38pt}{~ $\longrightarrow $~ }</phrase>
    </textobject>
  </mediaobject>
 <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/blinker-0.png"></imagedata>
  </imageobject>
</mediaobject> 
  
  <mediaobject>
    <imageobject>
      <imagedata fileref="images/img-0002.png" contentwidth="162px" contentdepth="27px"></imagedata>
    </imageobject>
    <textobject>
      <phrase>\raisebox{38pt}{~ $\longrightarrow $~  \ldots }</phrase>
    </textobject>
  </mediaobject></figure>
<para>Patterns like this are called “periodic”, because they repeat after a period of two or more time steps. But they are also considered stable, because the total number of live cells doesn’t grow over time. </para><para>Most simple starting configurations either die out quickly or reach a stable configuration. But there are a few starting conditions that display remarkable complexity. One of those is the R-pentomino: it starts with only five cells, runs for 1103 time steps, and ends in a stable configuration with 116 live cells (see <ulink url="http://www.conwaylife.com/wiki/R-pentomino"></ulink>). </para><para>In the following sections, we’ll implement the Game of Life in Java. We’ll first implement the cells, then the grid of cells, and finally the game itself. </para>
</sect1><sect1 id="a0000011020" remap="section">
  <title>The Cell Class</title>
    <para>When drawing a cell, we’ll need to know its location on the screen and size in pixels. To represent the location, we use the <literal>x</literal> and <literal>y</literal> coordinates of the upper-left corner. And to represent the size, we use an integer, <literal>size</literal>. </para><para>To represent the state of a cell, we use an integer, <literal>state</literal>, which is <literal>0</literal> for dead cells and <literal>1</literal> for live cells. We could use a <literal>boolean</literal> instead, but it’s good practice to design classes to be reusable (e.g., for other games that have more states). </para><para>Here is a <literal>Cell</literal> class that declares these instance variables: </para><programlisting language="java">
public class Cell {
    private final int x;
    private final int y;
    private final int size;
    private int state;
}</programlisting><para>Notice that <literal>x</literal>, <literal>y</literal>, and <literal>size</literal> are constants. Once the cell is created, we don’t want it to move or change size. But <literal>state</literal> can and should change, so it is not a constant. </para><para>The next step is to write a constructor. Here’s one that takes <literal>x</literal>, <literal>y</literal>, and <literal>size</literal> as parameters, and sets <literal>state</literal> to a default value. </para><programlisting language="java">
public Cell(int x, int y, int size) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.state = 0;
}</programlisting><para>The following method draws a cell. Like the <literal>paint</literal> method in <xref linkend="graphics" />, it takes a graphics context as a parameter. </para><programlisting language="java">
public static final Color[] COLORS = {Color.WHITE, Color.BLACK};

public void draw(Graphics g) {
    g.setColor(COLORS[state]);
    g.fillRect(x + 1, y + 1, size - 1, size - 1);
    g.setColor(Color.LIGHT_GRAY);
    g.drawRect(x, y, size, size);
}</programlisting><para>The <literal>draw</literal> method uses the state of the cell to select a color from an array of <literal>Color</literal> objects. Then it uses to <literal>fillRect</literal> to draw the center of the cell and <literal>drawRect</literal> to draw a light gray border. </para><para>We also need methods to get and set the cell’s state. We could just provide <literal>getState</literal> and <literal>setState</literal>, but the code will be more readable if we provide methods customized for the Game of Life: </para><programlisting language="java">
public boolean isOff() {
    return state == 0;
}

public boolean isOn() {
    return state == 1;
}

public void turnOff() {
    state = 0;
}

public void turnOn() {
    state = 1;
}</programlisting></sect1><sect1 id="a0000011085" remap="section">
  <title>Two-Dimensional Arrays</title>
    <para><indexterm>
  <primary>multidimensional array</primary>

</indexterm>To represent a grid of cells, we can use a <emphasis role="bold">multidimensional array</emphasis>. To create a two-dimensional (2D) array, we specify the number of rows and columns: </para><programlisting language="java">
int rows = 4;
int cols = 3;
Cell[][] array = new Cell[rows][cols];</programlisting><para>The result is an array with 4 rows and 3 columns. Initially, the elements of the array are <literal>null</literal>. We can fill the array with <literal>Cell</literal> objects like this: </para><programlisting language="java">
for (int r = 0; r &lt; rows; r++) {
    int y = r * size;
    for (int c = 0; c &lt; cols; c++) {
        int x = c * size;
        array[r][c] = new Cell(x, y, size);
    }
}</programlisting><para>The loop variables <literal>r</literal> and <literal>c</literal> are the row and column indexes of the cells. The variables <literal>x</literal> and <literal>y</literal> are the coordinates. For example, if <literal>size</literal> is 10 pixels, the cell at index (1, 2) would be at coordinates (10, 20) on the screen. </para><para>In Java, a 2D array is really an array of arrays. You can think of it as an array of rows, where each row is an array. <xref linkend="fig..2D-array" /> shows what it looks like. </para>
  
  <figure id="fig..2D-array" float="False">
    <title>Storing rows and columns with a 2D array.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/2D-array.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>row-major order</primary>

</indexterm>When we write <literal>array[r][c]</literal>, Java uses the first index to select a row and the second index to select an element from the row. This way of representing two-dimensional data is know as <emphasis role="bold">row-major order</emphasis>. </para>
</sect1><sect1 id="a0000011125" remap="section">
  <title>The GridCanvas Class</title>
    <para>Now that we have a <literal>Cell</literal> class and a way to represent a 2D array of cells, we can write a class to represent a grid of cells. We encapsulate the code from the previous section and generalize it to construct a grid with any number of rows and columns: </para><programlisting language="java">
public class GridCanvas extends Canvas {
    private Cell[][] array;

    public GridCanvas(int rows, int cols, int size) {
        array = new Cell[rows][cols];
        for (int r = 0; r &lt; rows; r++) {
            int y = r * size;
            for (int c = 0; c &lt; cols; c++) {
                int x = c * size;
                array[r][c] = new Cell(x, y, size);
            }
        }

        // set the canvas size
        setSize(cols * size, rows * size);
    }
}</programlisting><para><indexterm>
  <primary>IS-A</primary>

</indexterm><indexterm>
  <primary>HAS-A</primary>

</indexterm><indexterm>
  <primary>Graphics</primary>

</indexterm>Using vocabulary from the previous chapter, <literal>GridCanvas</literal> “is a” <literal>Canvas</literal> that “has a” two-dimensional array of cells. By extending the <literal>Canvas</literal> class from <literal>java.awt</literal>, we inherit methods for drawing graphics on the screen. </para><para>In fact, the code is surprisingly straightforward: to draw the grid, we simply draw each cell. We use nested <literal>for</literal> loops to traverse the 2D array: </para><programlisting language="java">
public void draw(Graphics g) {
    for (Cell[] row : array) {
        for (Cell cell : row) {
            cell.draw(g);
        }
    }
}</programlisting><para>The outer loop traverses the rows; the inner loop traverses the cells in each row. You can almost read this method in English: “For each <literal>row</literal> in the <literal>array</literal>, and for each <literal>cell</literal> in the <literal>row</literal>, draw the <literal>cell</literal> in the graphics context.” Each cell contains its coordinates and size, so it knows how to draw itself. </para><para>Classes that extend <literal>Canvas</literal> are supposed to provide a method called <literal>paint</literal> that “paints” the contents of the <literal>Canvas</literal>. It gets invoked when the <literal>Canvas</literal> is created and any time it needs to be redrawn, for example, when its window is moved or resized. </para><para>Here’s the <literal>paint</literal> method for <literal>GridCanvas</literal>. When the window management system calls <literal>paint</literal>, <literal>paint</literal> calls <literal>draw</literal>, which draws the cells. </para><programlisting language="java">
public void paint(Graphics g) {
    draw(g);
}</programlisting></sect1><sect1 id="a0000011181" remap="section">
  <title>Other Grid Methods</title>
    <para>In addition to <literal>draw</literal> and <literal>paint</literal>, the <literal>Grid</literal> class provides methods for working with the grid itself. <literal>numRows</literal> and <literal>numCols</literal> return the number of rows and columns. We can get this information from the 2D array, using <literal>length</literal>: </para><programlisting language="java">
public int numRows() {
    return array.length;
}

public int numCols() {
    return array[0].length;
}</programlisting><para>Because we are using row-major order, the 2D array is an array of rows. <literal>numRows</literal> simply returns the length of the rows array. <literal>numCols</literal> returns the length of the first row, which is the number of columns. Since the rows all have the same length, we only have to check one. </para><para><literal>GridCanvas</literal> also provides a method that gets the <literal>Cell</literal> at a given location, and for convenience when starting the game, a method that turns on the <literal>Cell</literal> at a given location. </para><programlisting language="java">
public Cell getCell(int r, int c) {
    return array[r][c];
}

public void turnOn(int r, int c) {
    array[r][c].turnOn();
}</programlisting></sect1><sect1 id="conwaymain" remap="section">
  <title>Starting the Game</title><para>Now we’re ready to implement the game. To encapsulate the rules of GoL, we define a class named <literal>Conway</literal>. The <literal>Conway</literal> class “has a” <literal>GridCanvas</literal> that represents the state of the game. </para><para>This constructor makes a <literal>GridCanvas</literal> with 5 rows and 10 columns, with cells that are 20 pixels wide and high. It then sets up the initial conditions. </para><programlisting language="java">
public class Conway {
    private GridCanvas grid;

    public Conway() {
        grid = new GridCanvas(5, 10, 20);
        grid.turnOn(2, 1);
        grid.turnOn(2, 2);
        grid.turnOn(2, 3);
        grid.turnOn(1, 7);
        grid.turnOn(2, 7);
        grid.turnOn(3, 7);
    }
}</programlisting><para>Before we implement the rest of the game, we’ll write a <literal>main</literal> method that creates a <literal>Conway</literal> object and displays it. We can use this method to test <literal>Cell</literal> and <literal>GridCanvas</literal>, and to develop the other methods we need. </para><programlisting language="java">
public static void main(String[] args) {
    String title = "Conway's Game of Life";
    Conway game = new Conway();
    JFrame frame = new JFrame(title);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);
    frame.add(game.grid);
    frame.pack();
    frame.setVisible(true);
    game.mainloop();
}</programlisting><para><indexterm>
  <primary>JFrame</primary>

</indexterm>After constructing the <literal>game</literal> object, <literal>main</literal> constructs a <literal>JFrame</literal>, which creates a window on the screen. The <literal>JFrame</literal> is configured to exit the program when closed. Resizing the window is disabled. </para><para><literal>main</literal> then adds the <literal>GridCanvas</literal> inside the frame, resizes (“packs”) the frame to fit the canvas, and makes the frame visible. <xref linkend="fig..conway" /> shows the result. </para>
  
  <figure id="fig..conway" float="False">
    <title>Screenshot of the initial <literal>Conway</literal> application.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/conway.png"></imagedata>
  </imageobject>
</mediaobject></figure>

</sect1><sect1 id="mainloop" remap="section">
  <title>The Simulation Loop</title><para>At the end of <literal>main</literal>, we call <literal>mainloop</literal>, which uses a <literal>while</literal> loop to simulate the time steps of the Game of Life. Here’s a rough draft of this method: </para><programlisting language="java">
private void mainloop() {
    while (true) {
        this.update();
        grid.repaint();
        Thread.sleep(500);    // compiler error
    }
}</programlisting><para>During each time step, we update the state of the game and repaint the <literal>grid</literal>. We will present the <literal>update</literal> method in <xref linkend="sec..update" />. </para><para><literal>repaint</literal> comes from the <literal>Canvas</literal> class. By default, it calls the <literal>paint</literal> method we provided, which calls <literal>draw</literal>. The reason we use it here is that <literal>repaint</literal> does not require a <literal>Graphics</literal> object as a parameter. </para><para><indexterm>
  <primary>Thread.sleep</primary>

</indexterm><indexterm>
  <primary>sleep</primary>

</indexterm><literal>Thread.sleep(500)</literal> causes the program to “sleep” for 500 milliseconds, or a half second. Otherwise the program would run so fast we would not be able to see the animation. </para><para><indexterm>
  <primary>InterruptedException</primary>

</indexterm><indexterm>
  <primary>Exception</primary>
<secondary>Interrupted</secondary>
</indexterm>There’s just one problem: compiling this code results in the error “unreported exception InterruptedException”. This message means we need to do some exception handling. </para>
</sect1><sect1 id="a0000011313" remap="section">
  <title>Exception Handling</title>
    <para>So far, the only exceptions we have seen are run-time errors like “array index out of bounds” and “null pointer”. When one of these exceptions occur, Java displays a message and ends the program. </para><para><indexterm>
  <primary>try</primary>

</indexterm><indexterm>
  <primary>catch</primary>

</indexterm><indexterm>
  <primary>Statement</primary>
<secondary>try</secondary>
</indexterm><indexterm>
  <primary>Statement</primary>
<secondary>catch</secondary>
</indexterm>If you don’t want the program to end, you can handle exceptions with a <literal>try</literal>-<literal>catch</literal> statement. The syntax is similar to an <literal>if</literal>-<literal>else</literal> statement, and the logic is, too. Here’s what it looks like: </para><programlisting language="java">
try {
    Thread.sleep(500);
} catch (InterruptedException e) {
    // do nothing
}</programlisting><para>First, Java runs the code in the try block, which calls <literal>Thread.sleep</literal> in this example. If an <literal>InterruptedException</literal> occurs during the try block, Java executes the catch block. In this example, the catch block contains a comment, so it doesn’t do anything. </para><para>If a different exception occurs during the try block, Java does whatever it would do otherwise, which is probably to display a message and end the program. If no exceptions occur during the try block, the catch block doesn’t run and the program continues. </para><para>In this example, the effect of the <literal>try</literal>-<literal>catch</literal> statement is to ignore an “interrupted” exception if it occurs. As an alternative, we could use the catch block to display a customized message, end the program, or handle the exception in whatever way is appropriate. For example, if user input causes an exception, we could catch the exception and prompt the user to try again later. </para><para>There’s more to learn about exception handling. You can read about exceptions in the Java tutorials at <ulink url="https://thinkjava.org/exceptions"></ulink>. </para>
</sect1><sect1 id="a0000011340" remap="section">
  <title>Counting Neighbors</title>
    <para><indexterm>
  <primary>neighbor</primary>

</indexterm>Now that you know about <literal>try</literal> and <literal>catch</literal>, we can use them to implement a useful method in <literal>GridCanvas</literal>. Part of the GoL logic is to count the number of live neighbors. Most cells have eight neighbors, as shown in <xref linkend="fig..neighbors" />. </para><para>However, cells on the edges and in the corners have fewer neighbors. If we try to count all possible neighbors, we’ll go out of bounds. The following method uses a <literal>try</literal>-<literal>catch</literal> statement to deal with these special cases. </para><programlisting language="java">
public int test(int r, int c) {
    try {
        if (array[r][c].isOn()) {
            return 1;
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        // cell doesn't exist
    }
    return 0;
}</programlisting><figure id="fig..neighbors" float="False">
    <title>Cells in the interior of the grid have eight neighbors. Cells in the corners and along the edges have fewer neighbors.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/grid.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The <literal>test</literal> method takes a row index, <literal>r</literal>, and a column index, <literal>c</literal>. It tries to look up the <literal>Cell</literal> at that location. If both of the indexes are in bounds, the <literal>Cell</literal> exists. In that case, <literal>test</literal> returns 1 if the <literal>Cell</literal> is on. Otherwise, it skips the catch block and returns 0. </para><para>If either of the indexes is out of bounds, the array lookup throws an exception, but the catch block ignores it. Then <literal>test</literal> resumes and returns 0. So the non-existent cells around the perimeter are considered to be off. </para><para>Now we can use <literal>test</literal> to implement <literal>countAlive</literal>, which takes a grid location, <literal>(r, c)</literal>, and returns the number of live neighbors surrounding that location. </para><programlisting language="java">
private int countAlive(int r, int c) {
    int count = 0;
    count += grid.test(r - 1, c - 1);
    count += grid.test(r - 1, c);
    count += grid.test(r - 1, c + 1);
    count += grid.test(r, c - 1);
    count += grid.test(r, c + 1);
    count += grid.test(r + 1, c - 1);
    count += grid.test(r + 1, c);
    count += grid.test(r + 1, c + 1);
    return count;
}</programlisting><para>Because <literal>test</literal> handles “out of bounds” exceptions, <literal>countAlive</literal> works for any values of <literal>r</literal> and <literal>c</literal>. </para>
</sect1><sect1 id="sec..update" remap="section">
  <title>Updating the Grid</title><para>Now we are ready to write <literal>update</literal>, which gets invoked each time through the simulation loop. It uses the GoL rules to compute the state of the grid after the next time step. </para><programlisting language="java">
public void update() {
    int[][] counts = countNeighbors();
    updateGrid(counts);
}</programlisting><para>The rules of GoL specify that you have to update the cells “simultaneously”; that is, you have to count the neighbors for all cells before you can update any of them. </para><para>We do that by traversing the grid twice: first, <literal>countNeighbors</literal> counts the live neighbors for each cell and puts the results in an array named <literal>counts</literal>; second, <literal>updateGrid</literal> updates the cells. Here’s <literal>countNeighbors</literal>: </para><programlisting language="java">
private int[][] countNeighbors() {
    int rows = grid.numRows();
    int cols = grid.numCols();

    int[][] counts = new int[rows][cols];
    for (int r = 0; r &lt; rows; r++) {
        for (int c = 0; c &lt; cols; c++) {
            counts[r][c] = countAlive(r, c);
        }
    }
    return counts;
}</programlisting><para><literal>countNeighbors</literal> traverses the cells in the grid and uses <literal>countAlive</literal> from the previous section to count the neighbors. The return value is a 2D array of integers with the same size as <literal>grid</literal>. <xref linkend="fig..countNeigh" /> illustrates an example. </para>
  
  <figure id="fig..countNeigh" float="False">
    <title>The result of <literal>countNeighbors</literal> for the grid in <xref linkend="conwaymain" />.</title>
      <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/conway.png"></imagedata>
  </imageobject>
</mediaobject><programlisting>{{0, 0, 0, 0, 0, 0, 1, 1, 1, 0},
 {1, 2, 3, 2, 1, 0, 2, 1, 2, 0},
 {1, 1, 2, 1, 1, 0, 3, 2, 3, 0},
 {1, 2, 3, 2, 1, 0, 2, 1, 2, 0},
 {0, 0, 0, 0, 0, 0, 1, 1, 1, 0}}</programlisting></figure>
<para>In contrast to the <literal>draw</literal> method of <literal>GridCanvas</literal>, which uses enhanced <literal>for</literal> loops, <literal>countNeighbors</literal> uses standard <literal>for</literal> loops. The reason is that, in this example, we need the indexes <literal>r</literal> and <literal>c</literal> to store the neighbor counts. </para><para><literal>updateGrid</literal> uses <literal>getCell</literal> to select each <literal>Cell</literal> in the grid and <literal>updateCell</literal> to do the update. </para><programlisting language="java">
private void updateGrid(int[][] counts) {
    int rows = grid.numRows();
    int cols = grid.numCols();

    for (int r = 0; r &lt; rows; r++) {
        for (int c = 0; c &lt; cols; c++) {
            Cell cell = grid.getCell(r, c);
            updateCell(cell, counts[r][c]);
        }
    }
}</programlisting><para><literal>updateCell</literal> implements the GoL rules: if the cell is alive, it dies if it has fewer than 2 or more than 3 neighbors; if the cell is dead, it comes to life if it has exactly 3. </para><programlisting language="java">
private static void updateCell(Cell cell, int count) {
    if (cell.isOn()) {
        if (count &lt; 2 || count &gt; 3) {
            cell.turnOff();
        }
    } else {
        if (count == 3) {
            cell.turnOn();
        }
    }
}</programlisting><para>Notice that <literal>updateGrid</literal> and <literal>updateCell</literal> are both <literal>private</literal>, because they are helper methods not intended to be invoked from outside the class. <literal>updateCell</literal> is also <literal>static</literal>, because it does not depend on <literal>grid</literal>. </para><para>Now our implementation of the Game of Life is complete. We think it’s is pretty fun, and we hope you agree. But more importantly, this example is meant to demonstrate the use of 2D arrays and an object-oriented design that’s a little more substantial than previous chapters. </para>
</sect1><sect1 id="a0000011486" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>multidimensional array:</term>
      <listitem><para><indexterm>
  <primary>multidimensional array</primary>

</indexterm>An array with more than one dimension; two-dimensional arrays are “arrays of arrays”. </para></listitem>
  </varlistentry><varlistentry>
    <term>row-major order:</term>
      <listitem><para><indexterm>
  <primary>row-major order</primary>

</indexterm>Storing data in a two-dimensional array first by rows and then by columns. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000011493" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch15</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000011502" role="exercise">
  <title></title>
  <para> In <literal>GridCanvas</literal>, write a method named <literal>countOn</literal> that returns the total number of cells that are “on”. This method can be used, for example, to track the population in Game of Life over time. </para>
</example> </para><para><example id="a0000011508" role="exercise">
  <title></title>
  <para> In our version of the Game of Life, the grid has a finite size. As a result, moving objects such as gliders either crash into the wall or go out of bounds. </para><para>An interesting variation of the Game of Life is a “toroidal” grid, meaning that the cells “wrap around” on the edges. Modify the <literal>test</literal> method of <literal>GridCanvas</literal> so that the coordinates <literal>r</literal> and <literal>c</literal> map to the opposite side of the grid if they are too low or two high. </para><para>Run your code with a Glider (see <xref linkend="fig..glider" />) to see if it works. You can initialize the Glider by modifying the constructor in the <literal>Conway</literal> class, or by reading it from a file (see the next exercise). </para>
</example> </para><para><example id="a0000011525" role="exercise">
  <title></title>
  <para>The “LifeWiki” <ulink url="http://conwaylife.com/wiki/"></ulink> has a fascinating collection of patterns for the Game of Life. These patterns are stored in a file format that is easy to read, in files with the suffix “<literal remap="verb">.cells</literal>”. </para><para>For example, here is an 8x10 grid with a glider near the upper-left corner: </para><programlisting>!Name: Glider
..........
..O.......
...O......
.OOO......
..........
..........
..........
..........</programlisting><para>Lines that begin with <literal>!</literal> are comments and should be ignored. The rest of the file describes the grid, row by row. A period represents a dead cell, and an uppercase O represents a live cell. See <ulink url="http://conwaylife.com/wiki/Plaintext"></ulink> for more examples. </para><orderedlist>
  
  <listitem><para>Create a plain text file with the contents shown above, and save the file as <literal remap="verb">glider.cells</literal> in the same directory as your code. </para></listitem>
  
  <listitem><para>Define a constructor for the <literal>Conway</literal> class that takes a string representing the name (or path) of a “.cells” file. Here is a starting point: </para><programlisting language="java">
public Conway(String path) {
    File file = new File(path);
    Scanner scan = new Scanner(file);
}</programlisting></listitem>
  
  <listitem><para>Modify the main method to invoke the constructor as follows: </para><programlisting language="java">
Conway game = new Conway("glider.cells");</programlisting></listitem>
  
  <listitem><para>Handle the <literal>FileNotFoundException</literal> that may be thrown when creating a <literal>Scanner</literal> for a <literal>File</literal> by invoking <literal>printStackTrace</literal> on the exception object and calling <literal>System.exit()</literal> with a status of 1, indicating an error. </para></listitem>
  
  <listitem><para>Continue implementing the constructor by reading all non-comment lines into an <literal>ArrayList</literal> using <literal>hasNextLine</literal> and <literal>nextLine</literal> of the <literal>Scanner</literal>. </para></listitem>
  
  <listitem><para>Determine the number of rows and columns of the grid by examining the <literal>ArrayList</literal> contents. </para></listitem>
  
  <listitem><para>Create and initialize a <literal>GridCanvas</literal> based on the <literal>ArrayList</literal>. </para></listitem>
  
</orderedlist><para>Once your constructor is working, you will be able to run many of the patterns on the LifeWiki. You might want to add a margin of empty cells around the initial pattern, to give it room to grow. </para>
</example> </para><para><example id="a0000011585" role="exercise">
  <title></title>
  <para> Some files on the LifeWiki use “Run Length Encoding” (RLE) instead of plain text. The basic idea of RLE is to describe the number of dead and alive cells, rather than type out each individual cell. </para><para>For example, <literal remap="verb">glider.cells</literal> from the previous exercise could be represented this way with RLE: </para><programlisting>#C Name: Glider
x = 10, y = 8
$2bo$3bo$b3o!</programlisting><para>The first line specifies <literal remap="verb">x</literal> (the number of columns) and <literal remap="verb">y</literal> (the number of rows). Subsequent lines consist of the letters <literal remap="verb">b</literal> (dead), <literal remap="verb">o</literal> (alive), and <literal remap="verb">$</literal> (end of line), optionally preceded by a count. The pattern ends with <literal remap="verb">!</literal>, after which any remaining file contents are ignored. </para><para>Lines beginning with <literal>#</literal> have special meaning and are not part of the pattern. For example, <literal>#C</literal> is a comment line. You can read more about RLE format on <ulink url="http://conwaylife.com/wiki/RLE"></ulink>. </para><orderedlist>
  
  <listitem><para>Create a plain text file with the contents shown above, and save the file as <literal remap="verb">glider.rle</literal> in the same directory as your code. </para></listitem>
  
  <listitem><para>Modify your constructor from the previous exercise to check the last three characters of the <literal>path</literal>. If they are <literal>"rle"</literal>, then you will need to process the file as RLE. Otherwise, assume the file is in “.cells” format. </para></listitem>
  
  <listitem><para>In the end, your constructor should be able to read and initialize grids in both formats. Test your constructor by modifying the <literal>main</literal> method to read different files. </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</chapter><chapter id="a0000011619">
  <title>Reusing Classes</title>
  <para>In <xref linkend="conway" />, we developed classes to implement Conway’s Game of Life. We can reuse the <literal>Cell</literal> and <literal>GridCanvas</literal> classes to implement other simulations. One of the most interesting zero-player games is <emphasis>Langton’s Ant</emphasis>, which models an “ant” that walks around a grid. The ant follows only two simple rules: </para><orderedlist>
  
  <listitem><para>If the ant is on a white cell, it turns to the right, makes the cell black, and moves forward. </para></listitem>
  
  <listitem><para>If the ant is on a black cell, it turns to the left, makes the cell white, and moves forward. </para></listitem>
  
</orderedlist><para>Because the rules are simple, you might expect the ant to do something simple, like make a square or repeat a simple pattern. But starting on a grid with all white cells, the ant makes more than 10,000 steps in a seemingly random pattern before it settles into a repeating loop of 104 steps. You can read more about it at <ulink url="http://en.wikipedia.org/wiki/Langton’s_ant"></ulink>. </para><para>In this chapter, we present a solution to Langton’s Ant and use it to demonstrate more advanced object-oriented techniques. </para><sect1 id="a0000011638" remap="section">
  <title>Langton’s Ant</title>
    <para>We begin by defining a <literal>Langton</literal> class that has a grid and information about the ant. The constructor takes the grid dimensions as parameters. </para><programlisting language="java">
public class Langton {
    private GridCanvas grid;
    private int xpos;
    private int ypos;
    private int head; // 0=North, 1=East, 2=South, 3=West

    public Langton(int rows, int cols) {
        grid = new GridCanvas(rows, cols, 10);
        xpos = rows / 2;
        ypos = cols / 2;
        head = 0;
    }
}</programlisting><para><literal>grid</literal> is a <literal>GridCanvas</literal> object, which represents the state of the cells. <literal>xpos</literal> and <literal>ypos</literal> are the coordinates of the ant, and <literal>head</literal> is the “heading” of the ant, that is, what direction it is facing. <literal>head</literal> is an integer with four possible values, where 0 means the ant is facing “north”, that is, toward the top of the screen, 1 means “east”, etc. </para><para>Here’s an <literal>update</literal> method that implements the rules for Langton’s ant: </para><programlisting language="java">
public void update() {
    flipCell();
    moveAnt();
}</programlisting><para>The <literal>flipCell</literal> method gets the <literal>Cell</literal> at the ant’s location, figures out which way to turn, and changes the state of the cell. </para><programlisting language="java">
private void flipCell() {
    Cell cell = grid.getCell(xpos, ypos);
    if (cell.isOff()) {
        head = (head + 1) % 4;    // turn right
        cell.turnOn();
    } else {
        head = (head + 3) % 4;    // turn left
        cell.turnOff();
    }
}</programlisting><para>We use the remainder operator, <literal remap="verb">%</literal>, to make <literal>head</literal> wrap around: if <literal>head</literal> is 3 and we turn right, it wraps around to 0; if <literal>head</literal> is 0 and we turn left, it wraps around to 3. </para><para>Notice that to turn right, we add 1 to <literal>head</literal>. To turn left, we could subtract 1, but <literal remap="verb">-1 % 4</literal> is <literal remap="verb">-1</literal> in Java. So we add 3 instead, since one left turn is the same as three right turns. </para><para>The <literal>moveAnt</literal> method moves the ant forward one square, using <literal>head</literal> to determine which way is forward. </para><programlisting language="java">
private void moveAnt() {
    if (head == 0) {
        ypos -= 1;
    } else if (head == 1) {
        xpos += 1;
    } else if (head == 2) {
        ypos += 1;
    } else {
        xpos -= 1;
    }
}</programlisting><para>Here is the <literal>main</literal> method we use to create and display the <literal>Langton</literal> object: </para><programlisting language="java">
public static void main(String[] args) {
    String title = "Langton's Ant";
    Langton game = new Langton(61, 61);
    JFrame frame = new JFrame(title);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);
    frame.add(game.grid);
    frame.pack();
    frame.setVisible(true);
    game.mainloop();
}</programlisting><para>Most of this code is the same as the <literal>main</literal> we used to create and run <literal>Conway</literal>, in <xref linkend="conwaymain" />. It creates and configures a <literal>JFrame</literal> and runs <literal>mainloop</literal>. </para><para>And that’s everything! If you run this code with a grid size of 61x61 or larger, you will see the ant eventually settle into a repeating pattern. </para><para>Because we designed <literal>Cell</literal> and <literal>GridCanvas</literal> to be reusable, we didn’t have to modify them at all. However, we now have two copies of the <literal>main</literal> method—one on <literal>Conway</literal>, and one in <literal>Langton</literal>. </para>
</sect1><sect1 id="a0000011719" remap="section">
  <title>Refactoring</title>
    <para>Whenever you see repeated code like <literal>main</literal>, you should think about ways to remove it. In the <xref linkend="eights" />, we used inheritance to eliminate repeated code. We’ll do something similar with <literal>Conway</literal> and <literal>Langton</literal>. </para><para>First, we define a superclass named <literal>Automaton</literal> where we will put the code that <literal>Conway</literal> and <literal>Langton</literal> have in common. </para><programlisting language="java">
public class Automaton {
    private GridCanvas grid;

    public void run(String title, int rate) {
        JFrame frame = new JFrame(title);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setResizable(false);
        frame.add(this.grid);
        frame.pack();
        frame.setVisible(true);
        this.mainloop(rate);
    }
}</programlisting><para><literal>Automaton</literal> declares <literal>grid</literal> as an instance variable, so every <literal>Automaton</literal> “has a” <literal>GridCanvas</literal>. It also provides <literal>run</literal>, which contains the code that creates and configures the <literal>JFrame</literal>. </para><para>The <literal>run</literal> method takes two parameters: the window <literal>title</literal> and the frame <literal>rate</literal>, that is, the number of time steps to show per second. It uses <literal>title</literal> when creating the <literal>JFrame</literal>, and it passes <literal>rate</literal> to <literal>mainloop</literal>: </para><programlisting language="java">
private void mainloop(int rate) {
    while (true) {

        // update the drawing
        this.update();
        grid.repaint();

        // delay the simulation
        try {
            Thread.sleep(1000 / rate);
        } catch (InterruptedException e) {
            // do nothing
        }
    }
}</programlisting><para><literal>mainloop</literal> contains the code we first saw in <xref linkend="mainloop" />. It runs a <literal>while</literal> loop forever (or until the window closes). Each time through the loop, it runs <literal>update</literal> to update <literal>grid</literal> and then <literal>repaint</literal> to redraw the grid. </para><para>Then it calls <literal>Thread.sleep</literal> with a delay that depends on <literal>rate</literal>. For example, if <literal>rate</literal> is 2, we should draw two frames per second, so the delay is a half second, or 500 milliseconds. </para><para><indexterm>
  <primary>refactoring</primary>

</indexterm>This process of reorganizing existing code, without changing its behavior, is known as <emphasis role="bold">refactoring</emphasis>. We’re almost finished; we just need to redesign <literal>Conway</literal> and <literal>Langton</literal> to extend <literal>Automaton</literal>. </para>
</sect1><sect1 id="a0000011799" remap="section">
  <title>Abstract Classes</title>
    <para>So far the implementation works, and if we are not planning to implement any other zero-person games, we could leave well enough alone. But there are a few problems with the current design: </para><orderedlist>
  
  <listitem><para>The <literal>grid</literal> attribute is <literal>private</literal>, making it inaccessible in <literal>Conway</literal> and <literal>Langton</literal>. We could make it <literal>public</literal>, but then other (unrelated) classes would have access to it as well. </para></listitem>
  
  <listitem><para>The <literal>Automaton</literal> class has no constructors, and even if it did, there would be no reason to create an instance of this class. </para></listitem>
  
  <listitem><para>The <literal>Automaton</literal> class does not provide an implementation of <literal>update</literal>. In order to work properly, subclasses need to provide one. </para></listitem>
  
</orderedlist><para><indexterm>
  <primary>protected</primary>

</indexterm><indexterm>
  <primary>abstract</primary>

</indexterm>Java provides language features to solve these problems: </para><orderedlist>
  
  <listitem><para>We can make the <literal>grid</literal> attribute <literal>protected</literal>, which means it’s accessible to subclasses but not other classes. </para></listitem>
  
  <listitem><para>We can make the class <literal>abstract</literal>, which means it cannot be instantiated. If you attempt to create an object for an abstract class, you will get a compiler error. </para></listitem>
  
  <listitem><para>We can declare <literal>update</literal> as an <literal>abstract</literal> method, meaning that it must be overridden in subclasses. If the subclass does not override an abstract method, you will get a compiler error. </para></listitem>
  
</orderedlist><para>Here’s what <literal>Automaton</literal> looks like as an abstract class: </para><programlisting language="java">
public abstract class Automaton {
    protected GridCanvas grid;

    public abstract void update();

    public void run(String title, int delay) {
        // body of this method omitted
    }

    private void mainloop(int rate) {
        // body of this method omitted
    }
}</programlisting><para>Notice that the <literal>update</literal> method has no body. The declaration specifies the name, arguments, and return type. But it does not provide an implementation, because it is an abstract method. </para><para>Notice also the word <literal>abstract</literal> on the first line, which declares that <literal>Automaton</literal> is an abstract class. In order to have any abstract methods, a class must be declared as abstract. </para><para>Any class that extends <literal>Automaton</literal> must provide an implementation of <literal>update</literal>; the declaration here allows the compiler to check. </para><para>Here’s what <literal>Conway</literal> looks like as a subclass of <literal>Automaton</literal>: </para><programlisting language="java">
public class Conway extends Automaton {

    // same methods as before, except mainloop is removed

    public static void main(String[] args) {
        String title = "Conway's Game of Life";
        Conway game = new Conway("pulsar.cells", 2);
        game.run(title, 2);
    }
}</programlisting><para><literal>Conway</literal> extends <literal>Automaton</literal>, so it inherits the <literal>protected</literal> instance variable <literal>grid</literal> and the methods <literal>run</literal> and <literal>mainloop</literal>. But because <literal>Automaton</literal> is abstract, <literal>Conway</literal> has to provide <literal>update</literal> and a constructor (which it has already). </para><para>Abstract classes are essentially “incomplete” class definitions that specify methods to be implemented by subclasses. But they also provide attributes and methods to be inherited, thus eliminating repeated code. </para>
</sect1><sect1 id="a0000011890" remap="section">
  <title>UML Diagram</title>
    <para>At the beginning of the chapter, with had three classes: <literal>Cell</literal>, <literal>GridCanvas</literal>, and <literal>Conway</literal>. We then developed <literal>Langton</literal>, which had almost the same <literal>main</literal> method as <literal>Conway</literal>. So we refactored the code and created <literal>Automaton</literal>. <xref linkend="fig..uml2" /> summarizes the final design. </para>
  
  <figure id="fig..uml2" float="False">
    <title>UML class diagram of <literal>Conway</literal> and <literal>Langton</literal> applications.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/uml2.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>IS-A</primary>

</indexterm><indexterm>
  <primary>HAS-A</primary>

</indexterm>The diagram shows three examples of inheritance: <literal>Conway</literal> is an <literal>Automaton</literal>, <literal>Langton</literal> is an <literal>Automaton</literal>, and <literal>GridCanvas</literal> is a Canvas. It also shows two examples of composition: <literal>Automaton</literal> has a <literal>GridCanvas</literal>, and <literal>GridCanvas</literal> has a 2D array of <literal>Cell</literal>s. </para><para>The diagram also shows that <literal>Automaton</literal> uses <literal>JFrame</literal>, <literal>GridCanvas</literal> uses <literal>Graphics</literal>, and <literal>Cell</literal> uses <literal>Graphics</literal> and <literal>Color</literal>. </para><para><literal>Automaton</literal> is in italics to indicate that it is an abstract class. As it happens, <literal>Graphics</literal> is an abstract class, too. </para><para>One of the challenges of object-oriented programming is keeping track of a large number of classes and the relationships between them. UML class diagrams can help. </para>
</sect1><sect1 id="a0000011960" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>refactor:</term>
      <listitem><para><indexterm>
  <primary>refactor</primary>

</indexterm>The process of restructuring or reorganizing existing code without changing its behavior. </para></listitem>
  </varlistentry><varlistentry>
    <term>abstract class:</term>
      <listitem><para><indexterm>
  <primary>abstract class</primary>

</indexterm>A class that is declared as <literal>abstract</literal>; it cannot be instantiated, and it may (or may not) include abstract methods. </para></listitem>
  </varlistentry><varlistentry>
    <term>concrete class:</term>
      <listitem><para><indexterm>
  <primary>concrete class</primary>

</indexterm>A class that is <emphasis>not</emphasis> declared as <literal>abstract</literal>; each of its methods must have an implementation. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000011975" remap="section">
  <title>Exercises</title>
    <para><example id="a0000011977" role="exercise">
  <title></title>
  <para>The last section of this chapter introduced <literal>Automaton</literal> as an abstract class and rewrote <literal>Conway</literal> as a subclass of <literal>Automaton</literal>. Now it’s your turn: rewrite <literal>Langton</literal> as a subclass of <literal>Automaton</literal>, removing the code that’s no longer needed. </para>
</example> </para><para><example id="a0000011990" role="exercise">
  <title></title>
  <para>Mathematically speaking, Game of Life and Langton’s Ant are cellular automata, where “cellular” means it has cells, and “automaton” means it runs itself. See <ulink url="https://en.wikipedia.org/wiki/Cellular_automaton"></ulink> for more discussion. </para><para>Implement another cellular automaton of your choice. You may have to modify <literal>Cell</literal> and/or <literal>GridCanvas</literal>, in addition to extending <literal>Automaton</literal>. For example, Brian’s Brain (<ulink url="https://en.wikipedia.org/wiki/Brian’s_Brain"></ulink>) requires three states: “on”, “dying”, and “off”. </para>
</example> </para>
</sect1>
</chapter><chapter id="a0000012001">
  <title>Advanced Topics</title>
  <para><indexterm>
  <primary>inheritance</primary>

</indexterm><indexterm>
  <primary>generalization</primary>

</indexterm>When we first looked at inheritance in <xref linkend="eights" />, our purpose was to avoid duplicating code. We noticed that “decks of cards” and “hands of cards” had common functionality, and we designed a <literal>CardCollection</literal> class to provide it. This technique is an example of <emphasis role="bold">generalization</emphasis>. By generalizing the code, we were able to reuse it in the <literal>Deck</literal> and <literal>Hand</literal> classes. </para><para><indexterm>
  <primary>specialization</primary>

</indexterm>In <xref linkend="conway" />, we looked at inheritance from a different point of view. When designing <literal>GridCanvas</literal> to represent a grid of cells, we extended <literal>Canvas</literal> and overrode its <literal>paint</literal> method. This design is an example of <emphasis role="bold">specialization</emphasis>. Using the code provided by <literal>Canvas</literal>, we created a specialized subclass with minimal additional code. </para><para>We didn’t write the code for <literal>Canvas</literal>; it’s part of the Java Library. But we were able to customize it for our own purposes. In fact, the <literal>Canvas</literal> class was explicitly designed to be extended. </para><para>In this chapter, we’ll explore the concept of inheritance more fully and explore event-driven programming. We’ll continue to develop graphical simulations as a running example, but this time in varying shapes and colors! </para><sect1 id="a0000012034" remap="section">
  <title>Polygon Objects</title>
    <para>The word polygon means “many angles”; the most basic polygons are triangles (3 angles), rectangles (4 angles), pentagons (5 angles), and so forth. Polygons are an important part of computer graphics because they are used to compose more complex images. </para><para>Java provides a <literal>Polygon</literal> class (in <literal>java.awt</literal>) that we can use to represent and draw polygons. The following code creates an empty <literal>Polygon</literal> and adds three points, forming a triangle. </para><programlisting language="java">
Polygon p = new Polygon();
p.addPoint(57, 110);
p.addPoint(100, 35);
p.addPoint(143, 110);</programlisting><para>Internally, <literal>Polygon</literal> objects have three attributes: </para><itemizedlist>
  
    <listitem><para><literal>public int npoints;</literal> <literal>   </literal> <literal>// total number of points</literal> </para></listitem>
  
    <listitem><para><literal>public int[] xpoints;</literal> <literal> </literal> <literal>// array of X coordinates</literal> </para></listitem>
  
    <listitem><para><literal>public int[] ypoints;</literal> <literal> </literal> <literal>// array of Y coordinates</literal> </para></listitem>
  
</itemizedlist><para>When a <literal>Polygon</literal> is created, <literal>npoints</literal> is 0 and the two arrays are initialized with length 4. As points are added, <literal>npoints</literal> is incremented. If <literal>npoints</literal> exceeds the length of the arrays, larger arrays are created, and the previous values are copied over (similar to how <literal>ArrayList</literal> works). </para><para>The <literal>Polygon</literal> class provides many useful methods, like <literal>contains</literal>, <literal>intersects</literal>, and <literal>translate</literal>. We’ll get to those later, but first we’re going to do some specialization. </para>
</sect1><sect1 id="a0000012099" remap="section">
  <title>Adding Color</title>
    <para>Specialization is useful for adding new features to an existing class, especially when you can’t (or don’t want to) change its design. For example, we can extend the <literal>Polygon</literal> class by adding a <literal>draw</literal> method and a <literal>Color</literal> attribute: </para><programlisting language="java">
public class DrawablePolygon extends Polygon {
    public Color color;

    public DrawablePolygon() {
        super();
        color = Color.GRAY;
    }

    public void draw(Graphics g) {
        g.setColor(color);
        g.fillPolygon(this);
    }
}</programlisting><para>As a reminder, constructors are not inherited when you extend a class. If you don’t define a constructor, the compiler will generate one that does nothing. </para><para>The constructor for <literal>DrawablePolygon</literal> uses <literal>super</literal> to invoke the constructor for <literal>Polygon</literal>, which initializes the attributes <literal>npoints</literal>, <literal>xpoints</literal>, and <literal>ypoints</literal>. Then <literal>DrawablePolygon</literal> initializes the <literal>color</literal> attribute to <literal>GRAY</literal>. </para><para><literal>DrawablePolygon</literal> has the same attributes and methods that <literal>Polygon</literal> has, so you can use <literal>addPoint</literal> as before, or you can directly access <literal>npoints</literal>, <literal>xpoints</literal>, and <literal>ypoints</literal> (since they are <literal>public</literal>). You can also use methods like <literal>contains</literal>, <literal>intersects</literal>, and <literal>translate</literal>. </para><para>The following code creates a <literal>DrawablePolygon</literal> with the same points as in the previous section and sets its color to <literal>GREEN</literal>: </para><programlisting language="java">
DrawablePolygon p = new DrawablePolygon();
p.addPoint(57, 110);
p.addPoint(100, 35);
p.addPoint(143, 110);
p.color = Color.GREEN;</programlisting></sect1><sect1 id="a0000012157" remap="section">
  <title>Regular Polygons</title>
    <para>A “regular” polygon has all sides the same length and all angles equal in measure. Regular polygons are a special case of polygons, so we will use specialization to define a class for them. </para><para>We could extend the <literal>Polygon</literal> class, like we did in the previous section. But then we would not have the <literal>Color</literal> functionality we just added. So we will make <literal>RegularPolygon</literal> extend <literal>DrawablePolygon</literal>. </para><para>To construct a <literal>RegularPolygon</literal>, we specify the number of sides, the radius (distance from the center to a vertex), and the color. For example: </para><programlisting language="java">
RegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);</programlisting><figure id="fig..hexagon" float="False">
    <title>Determining the <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> coordinates of vertex V1, given the radius <emphasis role="math">r</emphasis> and angle <emphasis role="math">θ</emphasis>. The center of the polygon is at the origin <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/hexagon.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The constructor uses trigonometry to find the coordinates of each vertex. <xref linkend="fig..hexagon" /> illustrates the process. The number of sides (<inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inlineequation>) and the radius (<inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inlineequation>) are given as parameters. </para><itemizedlist>
  
    <listitem><para>Imagine a clock hand starting at V0 and rotating counterclockwise to V1, V2, and so forth. In <xref linkend="fig..hexagon" />, the hand is currently at V1. </para></listitem>
  
    <listitem><para>The angle <emphasis role="math">θ</emphasis> is <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inlineequation>, since there are <emphasis role="math">2π</emphasis> radians in a circle. In other words, we are dividing the rotation of the clock hand into <emphasis role="math">n</emphasis> equal angles. </para></listitem>
  
    <listitem><para>By definition, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">cos</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>/</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>/</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:math></inlineequation>. Therefore, <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mo form="prefix">cos</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> and <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mo form="prefix">sin</mml:mo><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. </para></listitem>
  
    <listitem><para>We can determine the other <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> coordinates by multiplying <emphasis role="math">θ</emphasis> by <emphasis role="math">i</emphasis>, where <emphasis role="math">i</emphasis> is the vertex number. </para></listitem>
  
</itemizedlist><para>Here is the constructor for <literal>RegularPolygon</literal>: </para><programlisting language="java">
public RegularPolygon(int nsides, int radius, Color color) {

    // initialize DrawablePolygon attributes
    this.npoints = nsides;
    this.xpoints = new int[nsides];
    this.ypoints = new int[nsides];
    this.color = color;

    // the amount to rotate for each vertex (in radians)
    double theta = 2.0 * Math.PI / nsides;

    // compute x and y coordinates, centered at the origin
    for (int i = 0; i &lt; nsides; i++) {
        double x = radius * Math.cos(i * theta);
        double y = radius * Math.sin(i * theta);
        xpoints[i] = (int) Math.round(x);
        ypoints[i] = (int) Math.round(y);
    }
}</programlisting><para>This constructor initializes all four <literal>DrawablePolygon</literal> attributes, so it doesn’t have to invoke <literal>super()</literal>. </para><para>It initializes <literal>xpoints</literal> and <literal>ypoints</literal> by creating arrays of integer coordinates. Inside the <literal>for</literal> loop, it uses <literal>Math.sin</literal> and <literal>Math.cos</literal> (see <xref linkend="mathmeth" />) to compute the coordinates of the vertices as floating-point numbers. Then it rounds them off to integers, and stores them in the arrays. </para><para>When we construct a <literal>RegularPolygon</literal>, the vertices are centered at the point <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. If we want the center of the polygon to be somewhere else, we can use <literal>translate</literal>, which we inherit from <literal>Polygon</literal>: </para><programlisting language="java">
RegularPolygon rp = new RegularPolygon(6, 50, Color.BLUE);
rp.translate(100, 100);</programlisting><para>The result is a 6-sided polygon with radius 50 centered at the point <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>100</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation>. </para>
</sect1><sect1 id="a0000012263" remap="section">
  <title>More Constructors</title>
    <para>Classes in the Java library often have more than one constructor for convenience. We can do the same with <literal>RegularPolygon</literal>. For example, we can make the <literal>color</literal> parameter optional by defining a second constructor: </para><programlisting language="java">
public RegularPolygon(int nsides, int radius) {
    this(nsides, radius, Color.GRAY);
}</programlisting><para>The keyword <literal>this</literal>, when used in a constructor, invokes another constructor in the same class. It has a similar syntax as the keyword <literal>super</literal>, which invokes a constructor in the superclass. </para><para>Similarly, we could make the <literal>radius</literal> parameter optional too: </para><programlisting language="java">
public RegularPolygon(int nsides) {
    this(nsides, 50);
}</programlisting><para>Now, suppose we invoke the <literal>RegularPolygon</literal> constructor like this: </para><programlisting language="java">
RegularPolygon rp = new RegularPolygon(6);</programlisting><para>Because we provide only one integer argument, Java calls the third constructor, which calls the second one, which calls the first one. The result is a <literal>RegularPolygon</literal> with the specified value of <literal>nsides</literal>, 6, the default value of <literal>radius</literal>, 50, and the default color, <literal>GRAY</literal>. </para><para>When writing constructors, it’s a good idea to validate the values you get as arguments. Doing so prevents run-time errors later in the program, which makes the code easier to debug. </para><para>For <literal>RegularPolygon</literal>, the number of sides should be at least three, the radius should be greater than zero, and the color should not be <literal>null</literal>. We can add the following lines to the first constructor: </para><programlisting language="java">
public RegularPolygon(int nsides, int radius, Color color) {

    // validate the arguments
    if (nsides &lt; 3) {
        throw new IllegalArgumentException("invalid nsides");
    }
    if (radius &lt;= 0) {
        throw new IllegalArgumentException("invalid radius");
    }
    if (color == null) {
        throw new NullPointerException("invalid color");
    }

    // the rest of the method is omitted</programlisting><para><indexterm>
  <primary>throw</primary>

</indexterm><indexterm>
  <primary>Statement</primary>
<secondary>throw</secondary>
</indexterm>In this example, we <literal>throw</literal> an exception to indicate that one of the arguments is invalid. By default, these exceptions terminate the program and display an error message along with the stack trace. </para><para>Because we added this code to the most general constructor, we don’t have to add it to the others. </para>
</sect1><sect1 id="sec..drawing" remap="section">
  <title>An Initial Drawing</title><para>Now that we have <literal>DrawablePolygon</literal> and <literal>RegularPolygon</literal>, let’s take them for a test drive. We’ll need a <literal>Canvas</literal> for drawing them, so we define a new class, <literal>Drawing</literal>, that extends <literal>Canvas</literal>: </para><programlisting language="java">
public class Drawing extends Canvas {
    private ArrayList&lt;DrawablePolygon&gt; list;

    public Drawing(int width, int height) {
        setSize(width, height);
        setBackground(Color.WHITE);
        list = new ArrayList&lt;DrawablePolygon&gt;();
    }</programlisting><programlisting language="java">
    public void add(DrawablePolygon cp) {
        list.add(cp);
    }

    public void paint(Graphics g) {
        for (DrawablePolygon dp : list) {
            dp.draw(g);
        }
    }
}</programlisting><para>The <literal>Drawing</literal> class has an <literal>ArrayList</literal> of <literal>DrawablePolygon</literal> objects. When we create a <literal>Drawing</literal> object, the list is initially empty. The <literal>add</literal> method takes a <literal>DrawablePolygon</literal> and adds it to the list. </para><para><literal>Drawing</literal> overrides the <literal>paint</literal> method that it inherits from <literal>Canvas</literal>. <literal>paint</literal> loops through the list of <literal>DrawablePolygon</literal> objects and invokes <literal>draw</literal> on each one. </para><para>Here is an example that creates three <literal>RegularPolygon</literal> objects and draws them. <xref linkend="fig..drawing" /> shows the result. </para><programlisting language="java">
public static void main(String[] args) {

    // create some regular polygons
    DrawablePolygon p1 = new RegularPolygon(3, 50, Color.GREEN);
    DrawablePolygon p2 = new RegularPolygon(6, 50, Color.ORANGE);
    DrawablePolygon p3 = new RegularPolygon(360, 50, Color.BLUE);

    // move them out of the corner
    p1.translate(100, 80);
    p2.translate(250, 120);
    p3.translate(400, 160);

    // create drawing, add polygons
    Drawing drawing = new Drawing(500, 250);
    drawing.add(p1);
    drawing.add(p2);
    drawing.add(p3);</programlisting><programlisting language="java">
    // set up the window frame
    JFrame frame = new JFrame("Drawing");
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.add(drawing);
    frame.pack();
    frame.setVisible(true);
}</programlisting><figure id="fig..drawing" float="False">
    <title>Initial drawing of three <literal>RegularPolygon</literal> objects.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/drawing.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>The first block of code creates <literal>RegularPolygon</literal> objects with 3, 6, and 360 sides. As you can see, a polygon with 360 sides is a pretty good approximation of a circle. </para><para>The second block of code translates the polygons to different locations. The third block of code creates the <literal>Drawing</literal> and adds the polygons to it. And the fourth block of code creates a <literal>JFrame</literal>, adds the <literal>Drawing</literal> to it, and displays the result. </para><para>Most of these pieces should be familiar, but there is one part of this program that might surprise you. When we create the <literal>RegularPolygon</literal> objects, we assign them to <literal>DrawablePolygon</literal> variables. It might not be obvious why that’s legal. </para><para><indexterm>
  <primary>IS-A</primary>

</indexterm><literal>RegularPolygon</literal> extends <literal>DrawablePolygon</literal>, so every <literal>RegularPolygon</literal> object is also a <literal>DrawablePolygon</literal>. The parameter of <literal>Drawing.add</literal> has to be a <literal>DrawablePolygon</literal>, but it can be any type of <literal>DrawablePolygon</literal>, including <literal>RegularPolygon</literal> and other subclasses. </para><para><indexterm>
  <primary>polymorphism</primary>

</indexterm>This design is an example of <emphasis role="bold">polymorphism</emphasis>, a fancy word that means “having many forms”. <literal>Drawing.add</literal> is polymorphic method, because the parameter can be one of many types. And the <literal>ArrayList</literal> in <literal>Drawing</literal> is a polymorphic data structure, because the elements can be different types. </para>
</sect1><sect1 id="a0000012411" remap="section">
  <title>Blinking Polygons</title>
    <para>At this point, we have a simple program that draws polygons; we can make it more fun by adding animation. <xref linkend="conway" /> introduced the idea of simulating time steps. Here’s a loop that runs the animation. </para><programlisting language="java">
while (true) {
    drawing.step();
    try {
        Thread.sleep(1000 / 30);
    } catch (InterruptedException e) {
        // do nothing
    }
}</programlisting><para>Each time through the loop, we call <literal>step</literal> to update the <literal>Drawing</literal>. Then we sleep with a delay calculated to update about 30 times per second. </para><para>Here’s what the <literal>step</literal> method of <literal>Drawing</literal> looks like: </para><programlisting language="java">
public void step() {
    for (DrawablePolygon dp : list) {
        dp.step();
    }
    repaint();
}</programlisting><para>It invokes <literal>step</literal> on each <literal>DrawablePolygon</literal> in the list and then repaints (clears and redraws) the canvas. </para><para>In order for this code to compile, we need <literal>DrawablePolygon</literal> to provide a <literal>step</literal> method. Here’s a version that doesn’t do anything; we’ll override it in subclasses. </para><programlisting language="java">
public void step() {
    // do nothing
}</programlisting><para>Now let’s design a new type of polygon that blinks. We’ll define a class named <literal>BlinkingPolygon</literal> that extends <literal>RegularPolygon</literal> and adds two more attributes: <literal>visible</literal>, which indicates whether the polygon is visible, and <literal>count</literal>, which counts the number of time steps since the last blink. </para><programlisting language="java">
public class BlinkingPolygon extends RegularPolygon {
    public boolean visible;
    public int count;

    public BlinkingPolygon(int nsides, int radius, Color c) {
        super(nsides, radius, c);
        visible = true;
        count = 0;
    }

    public void draw(Graphics g) {
        if (visible) {
            super.draw(g);
        }
    }

    public void step() {
        count++;
        if (count == 10) {
            visible = !visible;
            count = 0;
        }
    }
}</programlisting><para>The constructor uses <literal>super</literal> to call the <literal>RegularPolygon</literal> constructor. Then it initializes <literal>visible</literal> and <literal>count</literal>. Initially the <literal>BlinkingPolygon</literal> is visible. </para><para>The <literal>draw</literal> method draws the polygon only if it is visible. It uses <literal>super</literal> to call <literal>draw</literal> in the parent class. But the parent class is <literal>RegularPolygon</literal>, which does not provide a <literal>draw</literal> method. In this case, <literal>super</literal> invokes <literal>draw</literal> from the <literal>DrawablePolygon</literal> class. </para><para>The <literal>step</literal> method increments <literal>count</literal>. Every 10 time steps, it toggles <literal>visible</literal> and resets <literal>count</literal> to 0. </para>
</sect1><sect1 id="a0000012489" remap="section">
  <title>Interfaces</title>
    <para>You might be getting tired of polygons at this point. Can’t we draw anything else? Of course we can, but <literal>Drawing</literal> is currently based on <literal>DrawablePolygon</literal>. To draw other types of objects, we have to generalize the code. </para><para>The <literal>Drawing</literal> class does essentially three things: (1) it maintains a <literal>list</literal> of objects, (2) it invokes the <literal>draw</literal> method on each object, and (3) it invokes the <literal>step</literal> method on each object. </para><para>So here’s one way we could make the code more general: </para><orderedlist>
  
  <listitem><para>Define a new superclass, which we call <literal>Actor</literal>, that provides the two methods needed by <literal>Drawing</literal>: </para><programlisting language="java">
public class Actor {
    public void draw(Graphics g) {
        // do nothing
    }
    public void step() {
        // do nothing
    }
}</programlisting></listitem>
  
  <listitem><para>In the <literal>Drawing</literal> class, replace <literal>DrawablePolygon</literal> with <literal>Actor</literal>. </para></listitem>
  
  <listitem><para>Any class that we want to draw must now extend <literal>Actor</literal>. </para></listitem>
  
</orderedlist><para>There’s just one problem: <literal>DrawablePolygon</literal> already extends <literal>Polygon</literal>, and classes can only extend one superclass. Also, the <literal>Actor</literal> class seems pointless, since the methods it defines don’t do anything. </para><para><indexterm>
  <primary>inheritance</primary>

</indexterm>Java provides another mechanism for inheritance that solves these problems. We can define <literal>Actor</literal> as an <literal>interface</literal> instead of a <literal>class</literal>, like this: </para><programlisting language="java">
public interface Actor {
    void draw(Graphics g);
    void step();
}</programlisting><para><indexterm>
  <primary>interface</primary>

</indexterm>Like a class definition, an <emphasis role="bold">interface</emphasis> definition contains methods. But it contains only the declarations of the methods, not their implementations. </para><para>Like an abstract class, an interface specifies methods that must be provided by subclasses. The difference is that an abstract class can implement some methods; an interface cannot. </para><para>All interface methods are <literal>public</literal> by default, since they are intended to be used by other classes. So there is no need to declare them as <literal>public</literal>. </para><para>To inherit from an interface, you use the keyword <literal>implements</literal> instead of <literal>extends</literal>. Here’s a version of <literal>DrawablePolygon</literal> that extends <literal>Polygon</literal> and implements <literal>Actor</literal>. So it inherits methods from <literal>Polygon</literal>, and it is required to provide the methods in <literal>Actor</literal>, namely <literal>step</literal> and <literal>draw</literal>. </para><programlisting language="java">
public class DrawablePolygon extends Polygon implements Actor {
    // rest of the class omitted
}</programlisting><para>In terms of inheritance, <literal>DrawablePolygon</literal> is both a <literal>Polygon</literal> and an <literal>Actor</literal>. So the following assignments are legal: </para><programlisting language="java">
Polygon p1 = new DrawablePolygon();
Actor a2 = new DrawablePolygon();</programlisting><para>And the same is true for subclasses of <literal>DrawablePolygon</literal>; these assignments are legal, too: </para><programlisting language="java">
Polygon p2 = new RegularPolygon(5, 50, Color.YELLOW);
Actor a2 = new RegularPolygon(5, 50, Color.YELLOW);</programlisting><para><indexterm>
  <primary>polymorphism</primary>

</indexterm>Interfaces are another example of polymorphism. <literal>a1</literal> and <literal>a2</literal> are the same type of variable, but they refer to objects with different types. And similarly with <literal>p1</literal> and <literal>p2</literal>. </para><para>Classes may extend only one superclass, but they may implement as many interfaces as needed. Java Library classes often implement multiple interfaces. </para>
</sect1><sect1 id="a0000012600" remap="section">
  <title>Event Listeners</title>
    <para><indexterm>
  <primary>sprite</primary>

</indexterm>Now that our <literal>Drawing</literal> is based on <literal>Actor</literal> instead of <literal>DrawablePolygon</literal>, we can draw other types of graphics. Here is the beginning of a class that reads an image from a file and shows the image moving across the canvas. The class is called <literal>Sprite</literal> because a moving image is sometimes called a <emphasis role="bold">sprite</emphasis>, in the context of computer graphics. </para><programlisting language="java">
public class Sprite implements Actor, KeyListener {
    private int xpos;
    private int ypos;
    private int dx;
    private int dy;
    private Image image;

    public Sprite(String path, int xpos, int ypos) {
        this.xpos = xpos;
        this.ypos = ypos;
        try {
            this.image = ImageIO.read(new File(path));
        } catch (IOException exc) {
            exc.printStackTrace();
        }
    }
}</programlisting><para>The instance variables <literal>xpos</literal> and <literal>ypos</literal> represent the location of the sprite. <literal>dx</literal> and <literal>dy</literal> represent the velocity of the sprite in the <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> directions. </para><para>The constructor takes as parameters the name of a file and the initial position. It uses <literal>ImageIO</literal>, from the <literal>javax.imageio</literal> package, to read the file. If an error occurs during reading, an <literal>IOException</literal> is caught, and the program displays the stack trace for debugging. </para><para><literal>Sprite</literal> implements two interfaces: <literal>Actor</literal> and <literal>KeyListener</literal>. <literal>Actor</literal> requires that we provide <literal>draw</literal> and <literal>step</literal> methods: </para><programlisting language="java">
    public void draw(Graphics g) {
        g.drawImage(image, xpos, ypos, null);
    }

    public void step() {
        xpos += dx;
        ypos += dy;
    }</programlisting><para>The <literal>draw</literal> method draws the image at the sprite’s current position. The <literal>step</literal> method changes the position based on <literal>dx</literal> and <literal>dy</literal>, which are initially zero. </para><para><literal>KeyListener</literal> is an interface for receiving keyboard events, which means we can detect and respond to key presses. A class that implements <literal>KeyListener</literal> has to provide the following methods: </para><itemizedlist>
  
    <listitem><para><literal>void keyPressed(KeyEvent e);</literal> Invoked when a key has been “pressed”. This method is invoked repeatedly while a key is being held down. </para></listitem>
  
    <listitem><para><literal>void keyReleased(KeyEvent e);</literal> Invoked when a key has been “released”, meaning it is no longer down. </para></listitem>
  
    <listitem><para><literal>void keyTyped(KeyEvent e);</literal> Invoked when a key has been “typed”, which generally means it has been both pressed and released. </para></listitem>
  
</itemizedlist><para>These methods get invoked when the user presses and releases <emphasis>any</emphasis> key. They take a <literal>KeyEvent</literal> object as a parameter, which specifies which key was pressed, released, or typed. </para><para>We can use these methods to design a simple animation using the arrow keys. When the user presses up or down, the sprite will move up or down. When the user presses left or right, the sprite will move left or right. </para><para>Here’s an implementation of <literal>keyPressed</literal> that uses a <literal>switch</literal> statement to test which arrow key was pressed and sets <literal>dx</literal> or <literal>dy</literal> accordingly. (There is no <literal>default</literal> branch, so we ignore all other keys.) </para><programlisting language="java">
public void keyPressed(KeyEvent e) {
    switch (e.getKeyCode()) {
        case KeyEvent.VK_UP:
            dy = -5;
            break;
        case KeyEvent.VK_DOWN:
            dy = +5;
            break;
        case KeyEvent.VK_LEFT:
            dx = -5;
            break;
        case KeyEvent.VK_RIGHT:
            dx = +5;
            break;
    }
}</programlisting><para>The values of <literal>dx</literal> and <literal>dy</literal> determine how much the sprite moves each time <literal>step</literal> is invoked. While the user holds down an arrow key, the sprite will move at a constant speed. </para><para>Here’s an implementation of <literal>keyReleased</literal> that runs when the user releases the key. </para><programlisting language="java">
public void keyReleased(KeyEvent e) {
    switch (e.getKeyCode()) {
        case KeyEvent.VK_UP:
        case KeyEvent.VK_DOWN:
            dy = 0;
            break;
        case KeyEvent.VK_LEFT:
        case KeyEvent.VK_RIGHT:
            dx = 0;
            break;
    }
}</programlisting><para>When the user releases the key, <literal>keyReleased</literal> sets <literal>dx</literal> or <literal>dy</literal> to 0, so the sprite stops moving in that direction. </para><para>We don’t need the <literal>keyTyped</literal> method for this example, but it’s required by the interface; if we don’t provide one, the compiler will complain. So we provide an implementation that does nothing: </para><programlisting language="java">
public void keyTyped(KeyEvent e) {
    // do nothing
}</programlisting><para>Now, here’s the code we need to create a <literal>Sprite</literal>, add it to a <literal>Drawing</literal>, and configure it as a <literal>KeyListener</literal>: </para><programlisting language="java">
Sprite sprite = new Sprite("face-smile.png", 25, 150);
drawing.add(sprite);
drawing.addKeyListener(sprite);
drawing.setFocusable(true);</programlisting><para>Recall that the <literal>add</literal> method is one that we wrote in <xref linkend="sec..drawing" />. It adds an <literal>Actor</literal> to the list of objects to be drawn. </para><para>The <literal>addKeyListener</literal> method is inherited from <literal>Canvas</literal>. It adds a <literal>KeyListener</literal> to the list of objects that will receive key events. </para><para>In graphical applications, key events are only sent to components when they have the keyboard focus. The <literal>setFocusable</literal> method ensures that <literal>drawing</literal> will be have the focus initially, without the user having to click on it first. </para>
</sect1><sect1 id="a0000012750" remap="section">
  <title>Timers</title>
    <para>Now that you know about interfaces and events, we can show you a better way to create animations. Previously, we implemented the animation loop using <literal>while (true)</literal> and <literal>Thread.sleep</literal>. Java provides a <literal>Timer</literal> class (in <literal>javax.swing</literal>) that encapsulates this behavior. </para><para>A <literal>Timer</literal> is useful for executing code at regular intervals. The constructor for <literal>Timer</literal> takes two parameters: </para><itemizedlist>
  
    <listitem><para><literal>int delay</literal> <literal>               </literal> <literal>// milliseconds between events</literal> </para></listitem>
  
    <listitem><para><literal>ActionListener listener</literal> <literal> </literal> <literal>// for handling timer events</literal> </para></listitem>
  
</itemizedlist><para>The <literal>ActionListener</literal> interface requires only one method, <literal>actionPerformed</literal>. This is the method the <literal>Timer</literal> invokes after the given delay. </para><para>Using a <literal>Timer</literal>, we can reorganize the code in <literal>main</literal> by defining a class that implements <literal>ActionListener</literal>. </para><programlisting language="java">
public class VideoGame implements ActionListener {
    private Drawing drawing;

    public VideoGame() {
        Sprite sprite = new Sprite("face-smile.png", 50, 50);
        drawing = new Drawing(800, 600);
        drawing.add(sprite);
        drawing.addKeyListener(sprite);
        drawing.setFocusable(true);

        JFrame frame = new JFrame("Video Game");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(drawing);
        frame.pack();
        frame.setVisible(true);
    }

    public void actionPerformed(ActionEvent e) {
        drawing.step();
    }

    public static void main(String[] args) {
        VideoGame game = new VideoGame();
        Timer timer = new Timer(33, game);
        timer.start();
    }
}</programlisting><para>The <literal>main</literal> method constructs a <literal>VideoGame</literal> object, which creates a <literal>Sprite</literal>, a <literal>Drawing</literal>, and a <literal>JFrame</literal>. Then it constructs a <literal>Timer</literal> object and starts the timer. Every 33 milliseconds, the <literal>Timer</literal> invokes <literal>actionPerformed</literal>, which invokes <literal>step</literal> on the <literal>Drawing</literal>. </para><para><literal>Drawing.step</literal> invokes <literal>step</literal> on all of its <literal>Actor</literal> objects, which causes them to update their position, color, or other aspects of their appearance. The <literal>Drawing.step</literal> then repaints the <literal>Canvas</literal>, and the time step is done. </para><para>At this point you have all of the elements you need to write your own video games. In the exercises at the end of this chapter, we have some suggestions for getting started. </para><para>We hope this final chapter has been a helpful summary of topics presented throughout the book, including input and output, decisions and loops, classes and methods, arrays and objects, inheritance, and graphics. Congratulations on making it to the end! </para>
</sect1><sect1 id="a0000012849" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>generalization:</term>
      <listitem><para><indexterm>
  <primary>generalization</primary>

</indexterm>The process of extracting common code from two or more classes and moving it into a superclass. </para></listitem>
  </varlistentry><varlistentry>
    <term>specialization:</term>
      <listitem><para><indexterm>
  <primary>specialization</primary>

</indexterm>Extending a class to add new attributes or methods, or to modify existing behavior. </para></listitem>
  </varlistentry><varlistentry>
    <term>polymorphism:</term>
      <listitem><para><indexterm>
  <primary>polymorphism</primary>

</indexterm>A language feature that allows objects to be assigned to variables of related types. </para></listitem>
  </varlistentry><varlistentry>
    <term>sprite:</term>
      <listitem><para><indexterm>
  <primary>sprite</primary>

</indexterm>A computer graphic which may be moved or otherwise manipulated on the screen. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000012860" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>ch16</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para>The following exercises give you a chance to practice using the features in this chapter by extending the example code. </para><para><example id="a0000012870" role="exercise">
  <title></title>
  <para> The <literal>Polygon</literal> class does not provide a <literal>toString</literal> method; it inherits the default <literal>toString</literal> from <literal>java.lang.Object</literal>, which only includes the class’s name and memory location. Write a more useful <literal>toString</literal> method for <literal>DrawablePolygon</literal> that includes its <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inlineequation> points. </para>
</example> </para><para><example id="a0000012885" role="exercise">
  <title></title>
  <para> Write a class <literal>MovingPolygon</literal> that extends <literal>RegularPolygon</literal> and implements <literal>Actor</literal>. It should have instance variables <literal>posx</literal> and <literal>posy</literal> that specify its position and <literal>dx</literal> and <literal>dy</literal> that specify its velocity (and direction). During each time step, it should update its position. If it gets to the edge of the <literal>Drawing</literal>, it should reverse direction by changing the sign of <literal>dx</literal> or <literal>dy</literal>. </para>
</example> </para><para><example id="a0000012907" role="exercise">
  <title></title>
  <para> Modify the <literal>VideoGame</literal> class so it displays a <literal>Sprite</literal> and a <literal>MovingPolygon</literal> (from the previous exercise). Add code that detects collisions between <literal>Actor</literal> objects in the same <literal>Drawing</literal>, and invoke a method on both objects when they collide. Hint: You might want to add a method to the <literal>Actor</literal> interface, guaranteeing that all <literal>Actor</literal> objects know how to handle collisions. </para>
</example> </para><para><example id="a0000012923" role="exercise">
  <title></title>
  <para> Java provides other event listeners that you can implement to make your programs interactive. For example, the interfaces <literal>MouseListener</literal>, <literal>MouseMotionListener</literal>, and <literal>MouseWheelListener</literal> allow you to respond to mouse input. Use the <literal>MouseListener</literal> interface to implement an <literal>Actor</literal> that can respond to mouse clicks. </para>
</example> </para></sect1>
</chapter><appendix id="tools">
  <title>Tools</title><para><indexterm>
  <primary>IDE</primary>

</indexterm>The steps for compiling, running, and debugging Java code depend on your development environment and operating system. We avoided putting these details in the main text, because they can be distracting. Instead, we provide this appendix with a brief introduction to DrJava—an <emphasis role="bold">integrated development environment</emphasis> (IDE) that is helpful for beginners—and other development tools, including Checkstyle for code quality and JUnit for testing. </para><sect1 id="drjava" remap="section">
  <title>Installing DrJava</title><para>The easiest way to start programming in Java is to use a website that compiles and runs Java code in the browser. Examples include <ulink url="https://repl.it/"></ulink>, <ulink url="https://trinket.io/"></ulink>, <ulink url="https://jdoodle.com/"></ulink>, and others. </para><para>If you are unable to install software on your computer (which is often the case in public schools and Internet cafés), you can use these online development environments for almost everything in this book. </para><para>But if you want to compile and run Java programs on your own computer, you will need: </para><itemizedlist>
  
    <listitem><para><indexterm>
  <primary>JDK</primary>

</indexterm><indexterm>
  <primary>JVM</primary>

</indexterm><indexterm>
  <primary>virtual machine</primary>

</indexterm><indexterm>
  <primary>Javadoc</primary>

</indexterm>The <emphasis role="bold">Java Development Kit</emphasis> (JDK), which includes the compiler, the <emphasis role="bold">Java Virtual Machine</emphasis> (JVM) that interprets the compiled byte code, and other tools such as Javadoc. </para><para><indexterm>
  <primary>text editor</primary>

</indexterm><indexterm>
  <primary>DrJava</primary>

</indexterm></para></listitem>
  
    <listitem><para>A <emphasis role="bold">text editor</emphasis> such as Atom, Notepad++, or Sublime Text, and/or an IDE such as DrJava, Eclipse, jGrasp, or NetBeans. </para></listitem>
  
</itemizedlist><para>The JDK we recommend is OpenJDK, an open-source implementation of Java SE (Standard Edition). The IDE we recommend is DrJava, which is an open-source development environment written in Java (see <xref linkend="fig.drjava1" />). </para><para>To install OpenJDK, visit <ulink url="https://adoptopenjdk.net"></ulink>. Download and run the installer for your operating system. </para><para><indexterm>
  <primary>JAR</primary>

</indexterm>To install DrJava, visit <ulink url="http://drjava.org/"></ulink> and download the <emphasis role="bold">JAR</emphasis> file. We recommend that you save it to your Desktop or another convenient location. Simply double-click the JAR file to run DrJava. Refer to the DrJava documentation (<ulink url="http://drjava.org/docs/quickstart/"></ulink>) for more details. </para>
  
  <figure id="fig.drjava1" float="False">
    <title>Screenshot of DrJava editing the hello world program.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/drjava-hello.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>When running DrJava for the first time, we recommend you change three settings from the Edit <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mo>&gt;</mml:mo></mml:math></inlineequation> Preferences menu under Miscellaneous: set the Indent Level to 4, check the Automatically Close Block Comments box, and uncheck the Keep Emacs-style Backup Files box. </para>
</sect1><sect1 id="interactions" remap="section">
  <title>DrJava Interactions</title><para><indexterm>
  <primary>interactions</primary>

</indexterm>One of the most useful features of DrJava is the “Interactions Pane” at the bottom of the window. It provides the ability to try out code quickly, without having to write a class definition and save/compile/run the program. <xref linkend="fig.drjava2" /> shows an example. </para>
  
  <figure id="fig.drjava2" float="False">
    <title>Screenshot of the Interactions Pane in DrJava.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/drjava-logic.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>There is one subtle detail to note when using the Interactions feature. If you don’t end an expression (or statement) with a semicolon, DrJava automatically displays its value. Notice in <xref linkend="fig.drjava2" /> how the variable declarations end with semicolons, but the logic expressions in the following lines do not. This feature saves you from having to type <literal>System.out.println</literal> every time. </para><para>What’s nice about this feature is that you don’t have to create a new class, declare a <literal>main</literal> method, write arbitrary expressions inside <literal>System.out.println</literal> statements, save the source file, and get all of your code to compile in advance. Also, you can press the up/down arrows on the keyboard to repeat previous commands and experiment with incremental differences. </para>
</sect1><sect1 id="commandline" remap="section">
  <title>Command-Line Interface</title><para><indexterm>
  <primary>command-line interface</primary>

</indexterm><indexterm>
  <primary>terminal</primary>

</indexterm>One of the most powerful and useful skills you can learn is how to use the <emphasis role="bold">command-line interface</emphasis>, also called the “terminal”. The command line is a direct interface to the operating system. It allows you to run programs, manage files and directories, and monitor system resources. Many advanced tools, both for software development and general-purpose computing, are available only at the command line. </para><para>There are many good tutorials online for learning the command line for your operating system; just search the web for “command line tutorial”. On Unix systems like Linux and OS X, you can get started with just four commands: change the working directory (<literal>cd</literal>), list directory contents (<literal>ls</literal>), compile Java programs (<literal>javac</literal>), and run Java programs (<literal>java</literal>). </para><para><xref linkend="fig.terminal" /> shows an example where the <literal>Hello.java</literal> source file is stored in the <literal>Desktop</literal> directory. After changing to that location and listing the files, we use the <literal>javac</literal> command to compile <literal>Hello.java</literal>. Running <literal>ls</literal> again, we see that the compiler generated a new file, <literal>Hello.class</literal>, which contains the byte code. We run the program using the <literal>java</literal> command, which displays the output on the following line. </para>
  
  <figure id="fig.terminal" float="False">
    <title>Compiling and running <literal>Hello.java</literal> from the command line.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/terminal.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Note that the <literal>javac</literal> command requires a <emphasis>filename</emphasis> (or multiple source files separated by spaces), whereas the <literal>java</literal> command requires a single <emphasis>class name</emphasis>. If you use DrJava, it runs these commands for you behind the scenes and displays the output in the Interactions Pane. </para><para>Taking time to learn this efficient and elegant way of interacting with the operating system will make you more productive. People who don’t use the command line don’t know what they’re missing. </para>
</sect1><sect1 id="cltesting" remap="section">
  <title>Command-Line Testing</title><para><indexterm>
  <primary>testing</primary>

</indexterm>As described in <xref linkend="sec..examples" />, it’s more effective to program and debug your code little by little than to attempt writing everything all at once. And after you’ve completed programming an algorithm, it’s important to test that it works correctly on a variety of inputs. </para><para>Throughout the book, we illustrate techniques for testing your programs. Most, if not all, testing is based on a simple idea: does the program do what we expect it to do? For simple programs, it’s not difficult to run them several times and see what happens. But at some point, you will get tired of typing the same test cases over and over. </para><para>We can automate the process of entering input and comparing “expected output” with “actual output” using the command line. The basic idea is to store the test cases in plain text files and trick Java into thinking they are coming from the keyboard. Here are step-by-step instructions: </para><orderedlist>
  
  <listitem><para>Make sure you can compile and run the <literal>Convert.java</literal> example in the <literal>ch03</literal> directory of <literal>ThinkJavaCode2</literal>. (See <xref linkend="code" /> for instructions on how to download the repository.) </para></listitem>
  
  <listitem><para>In the same directory as <literal>Convert.java</literal>, create a plain text file named <literal>test.in</literal> (“in” is for input). Enter the following line and save the file: </para><programlisting>193.04</programlisting></listitem>
  
  <listitem><para>Create a second plain text file named <literal>test.exp</literal> (“exp” is for expected). Enter the following line and save the file: </para><programlisting>193.04 cm = 6 ft, 4 in</programlisting></listitem>
  
  <listitem><para>Open a terminal, and change to the directory with these files. Run the following command to test the program: </para><programlisting>java Convert &lt; test.in &gt; test.out</programlisting></listitem>
  
</orderedlist><para><indexterm>
  <primary>redirection operator</primary>

</indexterm><indexterm>
  <primary>operator</primary>
<secondary>redirection</secondary>
</indexterm><indexterm>
  <primary>System.in</primary>

</indexterm><indexterm>
  <primary>System.out</primary>

</indexterm>On the command line, <literal>&lt;</literal> and <literal>&gt;</literal> are <emphasis role="bold">redirection operators</emphasis>. The first one redirects the contents of <literal>test.in</literal> to <literal>System.in</literal>, as if it were entered from the keyboard. The second one redirects the contents of <literal>System.out</literal> to a new file <literal>test.out</literal>, much like a screen capture. In other words, the <literal>test.out</literal> file contains the output of your program. </para><para>By the way, it’s perfectly okay to compile your programs in DrJava (or some other environment) and run them from the command line. Knowing both techniques allows you to use the right tool for the job. </para>
  
  <figure id="fig.meld" float="False">
    <title>Using <literal>meld</literal> to compare expected output with the actual output.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/meld.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>At this point, we just need to compare the contents <literal>test.out</literal> with <literal>test.exp</literal>. If the files are the same, then the program outputted what we expected it to output. If not, then we found a bug, and we can use the output to begin debugging our program. Fortunately, there’s a simple way to compare files on the command line: </para><programlisting>diff test.exp test.out</programlisting><para>The <literal>diff</literal> utility summarizes the differences between two files. If there are no differences, then it displays nothing, which in our case is what we want. If the expected output differs from the actual output, then we need to continue debugging. Usually the program is at fault, and <literal>diff</literal> provides some insight about what is broken. But there’s also a chance that we have a correct program and the expected output is wrong. </para><para>Interpreting the results from <literal>diff</literal> can be confusing, but fortunately there are many graphical tools that show the differences between two files. For example, on Windows you can install <literal>WinMerge</literal>, on Mac you can use <literal>opendiff</literal> (which comes with Xcode), and on Linux there’s <literal>meld</literal>, shown in <xref linkend="fig.meld" />. </para><para>Regardless of what tool you use, the goal is the same. Debug your program until the actual output is <emphasis>identical</emphasis> to the expected output. </para>
</sect1><sect1 id="checkstyle" remap="section">
  <title>Running Checkstyle</title><para><indexterm>
  <primary>Checkstyle</primary>

</indexterm>Checkstyle is a command-line tool that can be used to determine if your source code follows a set of style rules. It also checks for common programming mistakes, such as class and method design problems. </para><para>You can download the latest version as a JAR file from <ulink url="https://checkstyle.sourceforge.io/"></ulink>. To run Checkstyle, move (or copy) the JAR file to the same directory as your program. Open a terminal in that location, and run the following command: </para><programlisting>java -jar checkstyle-*-all.jar -c /google_checks.xml *.java</programlisting><para><indexterm>
  <primary>wildcard</primary>

</indexterm>The <literal>*</literal> characters are <emphasis role="bold">wildcards</emphasis> that match whatever version of Checkstyle you have and whatever Java source files are present. The output indicates the file and line number of each problem. This example refers to a method beginning on line 93, column 5 of <literal>Hello.java</literal>: </para><programlisting>Hello.java:93:5: Missing a Javadoc comment</programlisting><para>The file <literal>/google_checks.xml</literal> is inside the JAR file and represents most of Google’s style rules. You can alternatively use <literal>/sun_checks.xml</literal> or provide your own configuration file. See Checkstyle’s website for more information. </para><para>If you apply Checkstyle to your source code often, you will likely internalize good style habits over time. But there are limits to what automatic style checkers can do. In particular, they can’t evaluate the <emphasis>quality</emphasis> of your comments, the <emphasis>meaning</emphasis> of your variable names, or the <emphasis>structure</emphasis> of your algorithms. </para><para>Good comments make it easier for experienced developers to identify errors in your code. Good variable names communicate the intent of your program and how the data is organized. And good programs are designed to be efficient and demonstrably correct. </para>
</sect1><sect1 id="debugger" remap="section">
  <title>Tracing with a Debugger</title><para><indexterm>
  <primary>breakpoint</primary>

</indexterm><indexterm>
  <primary>debugger</primary>

</indexterm>A great way to visualize the flow of execution, including how parameters and arguments work, is to use a <emphasis role="bold">debugger</emphasis>. Most debuggers make it possible to: </para><orderedlist>
  
  <listitem><para>Set a <emphasis role="bold">breakpoint</emphasis>, a line where you want the program to pause. </para></listitem>
  
  <listitem><para>Step through the code one line at a time and watch what it does. </para></listitem>
  
  <listitem><para>Check the values of variables and see when and how they change. </para></listitem>
  
</orderedlist><para>For example, open any program in DrJava and move the cursor to the first line of <literal>main</literal>. Press Ctrl+B to toggle a breakpoint on the current line; it should now be highlighted in red. Press Ctrl+Shift+D to turn on Debug Mode; a new pane should appear at the bottom of the window. These commands are also available from the Debugger menu, in case you forget the shortcut keys. </para><para><indexterm>
  <primary>call stack</primary>

</indexterm>When you run the program, execution pauses at the first breakpoint. The debug pane displays the <emphasis role="bold">call stack</emphasis>, with the current method on top of the stack, as shown in <xref linkend="fig.debugger" />. You might be surprised to see how many methods were called before the <literal>main</literal> method! </para>
  
  <figure id="fig.debugger" float="False">
    <title>Screenshot of the DrJava debugger. Execution is currently paused on the first line of <literal>printTwice</literal>. There is a breakpoint on the first line of <literal>main</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/debugger.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>tracing</primary>

</indexterm>To the right are several buttons that allow you to step through the code at your own pace. You can also press Automatic Trace to watch DrJava run your code one line at a time. </para><para>Using a debugger is like having the computer proofread your code out loud. When the program is paused, you can examine (or even change) the value of any variable using the Interactions Pane. </para><para>Tracing allows you to follow the flow of execution and see how data pass from one method to another. You might expect the code do one thing, but then the debugger shows it doing something else. At that moment, you gain insight about what may be wrong with the code. </para><para>You can edit your code while debugging it, but we don’t recommend it. If you add or delete multiple lines of code while the program is paused, the results can be confusing. </para><para>See <ulink url="http://drjava.org/docs/user/ch09.html"></ulink> for more information about using the debugger feature of DrJava. </para>
</sect1><sect1 id="JUnit" remap="section">
  <title>Testing with JUnit</title><para><indexterm>
  <primary>unit test</primary>

</indexterm>When beginners start writing methods, they usually test them by invoking them from <literal>main</literal> and checking the results by hand. For example, to test <literal>fibonacci</literal> from <xref linkend="fibonacci" />, we could write: </para><programlisting language="java">
public static void main(String[] args) {
    if (fibonacci(1) != 1) {
        System.err.println("fibonacci(1) is incorrect");
    }
    if (fibonacci(2) != 1) {
        System.err.println("fibonacci(2) is incorrect");
    }
    if (fibonacci(3) != 2) {
        System.err.println("fibonacci(3) is incorrect");
    }
}</programlisting><para>This test code is self-explanatory, but it’s longer than it needs to be, and it doesn’t scale very well. In addition, the error messages provide limited information. For cases where we know the right answer, we can do better by writing <emphasis role="bold">unit tests</emphasis>. </para><para>JUnit is a common testing tool for Java programs (see <ulink url="https://junit.org/"></ulink>). To use it, you have to create a test class that contains test methods. </para><para>For example, suppose that the <literal>fibonacci</literal> method belongs to a class named <literal>Series</literal>. Here is the corresponding JUnit test class and test method: </para><programlisting language="java">
import junit.framework.TestCase;

public class SeriesTest extends TestCase {

    public void testFibonacci() {
        assertEquals(1, Series.fibonacci(1));
        assertEquals(1, Series.fibonacci(2));
        assertEquals(2, Series.fibonacci(3));
    }
}</programlisting><para>This example uses the keyword <literal>extends</literal>, which indicates that the new class, <literal>SeriesTest</literal> is based on an existing class, <literal>TestCase</literal>. The <literal>TestCase</literal> class is imported from the package <literal>junit.framework</literal>. </para><para>The names in this example follow convention: if the name of your class is <literal>Something</literal>, the name of the test class should be <literal>SomethingTest</literal>. And if there is a method in <literal>Something</literal> named <literal>someMethod</literal>, there should be a method in <literal>SomethingTest</literal> named <literal>testSomeMethod</literal>. </para><para>Many development environments can generate test classes and test methods automatically. In DrJava, you can select New JUnit Test Case from the File menu to generate an empty test class. </para><para><literal>assertEquals</literal> is provided by the <literal>TestCase</literal> class. It takes two arguments and checks whether they are equal. If so, it does nothing; otherwise it displays a detailed error message. The first argument is the “expected value”, which we consider correct, and the second argument is the “actual value” we want to check. If they are not equal, the test fails. </para><para><indexterm>
  <primary>System.err</primary>

</indexterm>Using <literal>assertEquals</literal> is more concise than writing your own <literal>if</literal> statements and <literal>System.err</literal> messages. JUnit provides additional assert methods, such as <literal>assertNull</literal>, <literal>assertSame</literal>, and <literal>assertTrue</literal>, that can be used to design a variety of tests. </para><para>To run JUnit directly from DrJava, click the Test button on the toolbar. If all your test methods pass, you will see a green bar in the lower-right corner. Otherwise, DrJava will take you directly to the first assertion that failed. </para>
</sect1><sect1 id="a0000013323" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>IDE:</term>
      <listitem><para><indexterm>
  <primary>IDE</primary>

</indexterm>An “integrated development environment” that includes tools for editing, compiling, and debugging programs. </para></listitem>
  </varlistentry><varlistentry>
    <term>JDK:</term>
      <listitem><para><indexterm>
  <primary>JDK</primary>

</indexterm>The “Java Development Kit” that contains the compiler, Javadoc, and other tools. </para></listitem>
  </varlistentry><varlistentry>
    <term>JVM:</term>
      <listitem><para><indexterm>
  <primary>JVM</primary>

</indexterm>The “Java Virtual Machine” that interprets the compiled byte code. </para></listitem>
  </varlistentry><varlistentry>
    <term>text editor:</term>
      <listitem><para><indexterm>
  <primary>text editor</primary>

</indexterm>A program that edits plain text files, the format used by most programming languages. </para></listitem>
  </varlistentry><varlistentry>
    <term>JAR:</term>
      <listitem><para><indexterm>
  <primary>JAR</primary>

</indexterm>A “Java Archive”, which is essentially a ZIP file containing classes and other resources. </para></listitem>
  </varlistentry><varlistentry>
    <term>command-line interface:</term>
      <listitem><para><indexterm>
  <primary>command-line interface</primary>

</indexterm>A means of interacting with the computer by issuing commands in the form of successive lines of text. </para></listitem>
  </varlistentry><varlistentry>
    <term>redirection operator:</term>
      <listitem><para><indexterm>
  <primary>redirection operator</primary>

</indexterm>A command-line feature that substitutes <literal>System.in</literal> and/or <literal>System.out</literal> with a plain text file. </para></listitem>
  </varlistentry><varlistentry>
    <term>wildcard:</term>
      <listitem><para><indexterm>
  <primary>wildcard</primary>

</indexterm>A command-line feature that allows you to specify a pattern of filenames using the <literal>*</literal> character. </para></listitem>
  </varlistentry><varlistentry>
    <term>debugger:</term>
      <listitem><para><indexterm>
  <primary>debugger</primary>

</indexterm>A tool that allows you to run one statement at a time and see the contents of variables. </para></listitem>
  </varlistentry><varlistentry>
    <term>breakpoint:</term>
      <listitem><para><indexterm>
  <primary>breakpoint</primary>

</indexterm>A line of code where the debugger will pause a running program. </para></listitem>
  </varlistentry><varlistentry>
    <term>call stack:</term>
      <listitem><para><indexterm>
  <primary>call stack</primary>

</indexterm>The history of method calls and where to resume execution after each method returns. </para></listitem>
  </varlistentry><varlistentry>
    <term>unit test:</term>
      <listitem><para><indexterm>
  <primary>unit test</primary>

</indexterm>Code that exercises a single method of a program, testing for correctness and/or efficiency. </para></listitem>
  </varlistentry>
</variablelist>
</sect1>
</appendix><appendix id="javadoc">
  <title>Javadoc</title><para><indexterm>
  <primary>comment</primary>
<secondary>end-of-line</secondary>
</indexterm><indexterm>
  <primary>comment</primary>
<secondary>multi-line</secondary>
</indexterm><indexterm>
  <primary>comment</primary>
<secondary>documentation</secondary>
</indexterm>Java programs have three different types of comments: </para><orderedlist>
  
  <listitem><para><emphasis role="bold">End-of-line comments</emphasis> (<literal>//</literal>), which generally contain short phrases that explain specific lines of code. </para></listitem>
  
  <listitem><para><emphasis role="bold">Multi-line comments</emphasis> (with <literal>/*</literal> at the beginning and <literal>*/</literal> at the end), which are typically used for copyright statements. </para></listitem>
  
  <listitem><para><emphasis role="bold">Documentation comments</emphasis> (with <literal>/**</literal> at the beginning and <literal>*/</literal> at the end), which describe what each class and method does. </para></listitem>
  
</orderedlist><para>End-of-line and multi-line comments are written primarily for yourself. They help you remember specific details about your source code. Documentation comments, on the other hand, are written for others. They explain how to use your classes and methods in other programs. </para><para><indexterm>
  <primary>HTML</primary>

</indexterm><indexterm>
  <primary>Javadoc</primary>

</indexterm>A nice feature of the Java language is the ability to embed documentation in the source code itself. That way, you can write it as you go, and as things change, it is easier to keep the documentation consistent with the code. </para><para>You can extract documentation from your source code, and generate well-formatted HTML pages, using a tool called <emphasis role="bold">Javadoc</emphasis>. This tool is included with the Java compiler, and it is widely used. In fact, the official documentation for the Java library (see <ulink url="https://thinkjava.org/apidoc"></ulink>) is generated by Javadoc. </para><sect1 id="a0000013394" remap="section">
  <title>Reading Documentation</title>
    <para><indexterm>
  <primary>documentation</primary>

</indexterm>As an example, let’s look at the documentation for <literal>Scanner</literal>, a class we first used in <xref linkend="scanner" />. You can find the documentation quickly by doing a web search for “Java Scanner”. <xref linkend="fig.scanner" /> shows a screenshot of the page. </para>
  
  <figure id="fig.scanner" float="False">
    <title>Screenshot of the documentation for <literal>Scanner</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/scanner.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>Documentation for other classes uses a similar format. The first line is the package that contains the class, such as <literal>java.util</literal>. The second line is the name of the class. The “Implemented Interfaces” section lists some of the functionality a <literal>Scanner</literal> has. </para><para>The next section of the documentation is a narrative that explains the purpose of the class and includes examples of how to use it. This text can be difficult to read, because it may use terms you have not yet learned. But the examples are often very useful. A good way to get started with a new class is to paste the examples into a test file and see if you can compile and run them. </para><para>One of the examples shows how you can use a <literal>Scanner</literal> to read input from a <literal>String</literal> instead of <literal>System.in</literal>: </para><programlisting language="java">
String input = "1 fish 2 fish red fish blue fish";
Scanner s = new Scanner(input);</programlisting><para>After the narrative, code examples, and some other details, you will find the following tables: </para><variablelist>
  <varlistentry>
    <term>Constructor summary:</term>
      <listitem><para>Ways of creating, or “constructing”, a <literal>Scanner</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>Method summary:</term>
      <listitem><para>The list of methods that the <literal>Scanner</literal> class provides. </para></listitem>
  </varlistentry><varlistentry>
    <term>Constructor detail:</term>
      <listitem><para>More information about how to create a <literal>Scanner</literal>. </para></listitem>
  </varlistentry><varlistentry>
    <term>Method detail:</term>
      <listitem><para>More information about each method. </para></listitem>
  </varlistentry>
</variablelist><para>For example, here is the summary information for <literal>nextInt</literal>: </para><programlisting>public int nextInt()
Scans the next token of the input as an int.</programlisting><para><indexterm>
  <primary>signature</primary>

</indexterm>The first line is the method’s <emphasis role="bold">signature</emphasis>, which specifies the name of the method, its parameters (none), and what type it returns (<literal>int</literal>). The next line is a short description of what it does. </para><para>The “Method detail” explains more: </para><programlisting>public int nextInt()
Scans the next token of the input as an int.

An invocation of this method of the form nextInt() behaves in
exactly the same way as the invocation nextInt(radix), where
radix is the default radix of this scanner.

Returns:
the int scanned from the input

Throws:
InputMismatchException - if the next token does not match
    the Integer regular expression, or is out of range
NoSuchElementException - if input is exhausted
IllegalStateException - if this scanner is closed</programlisting><para>The “Returns” section describes the result when the method succeeds. In contrast, the “Throws” section describes possible errors and exceptions that may occur. Exceptions are said to be “thrown”, like a referee throwing a flag, or like a toddler throwing a fit. </para><para>It might take you some time to get comfortable reading documentation and learning which parts to ignore. But it’s worth the effort. Knowing what’s available in the library helps you avoid reinventing the wheel. And a little bit of documentation can save you a lot of debugging. </para>
</sect1><sect1 id="a0000013460" remap="section">
  <title>Writing Documentation</title>
    <para>As you benefit from reading good documentation, you should “pay it forward” by writing good documentation. </para><para><indexterm>
  <primary>comment</primary>
<secondary>documentation</secondary>
</indexterm><indexterm>
  <primary>documentation</primary>
<secondary>Javadoc comments</secondary>
</indexterm>Javadoc scans your source files looking for documentation comments, also known as “Javadoc comments”. They begin with <literal>/**</literal> (two stars) and end with <literal>*/</literal> (one star). Anything in between is considered part of the documentation. </para><para>Here’s a class definition with two Javadoc comments, one for the <literal>Goodbye</literal> class and one for the <literal>main</literal> method: </para><programlisting language="java">
/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {

    /**
     * Prints a greeting.
     */
    public static void main(String[] args) {
        System.out.print("Goodbye, ");  // note the space
        System.out.println("cruel world");
    }
}</programlisting><para>The class comment explains the purpose of the class. The method comment explains what the method does. </para><para>Notice that this example also has an end-of-line comment (<literal>//</literal>). In general, these comments are short phrases that help explain complex parts of a program. They are intended for other programmers reading and maintaining the source code. </para><para>In contrast, Javadoc comments are longer, usually complete sentences. They explain what each method does, but they omit details about how the method works. And they are intended for people who will use the methods without looking at the source code. </para><para>Appropriate comments and documentation are essential for making source code readable. And remember that the person most likely to read your code in the future, and appreciate good documentation, is you. </para>
</sect1><sect1 id="a0000013482" remap="section">
  <title>Javadoc Tags</title>
    <para>It’s generally a good idea to document each class and method, so that other programmers can understand what they do without having to read the code. </para><para><indexterm>
  <primary>tag</primary>

</indexterm><indexterm>
  <primary>param tag</primary>

</indexterm><indexterm>
  <primary>return tag</primary>

</indexterm><indexterm>
  <primary>documentation</primary>
<secondary>Javadoc tags</secondary>
</indexterm>To organize the documentation into sections, Javadoc supports optional <emphasis role="bold">tags</emphasis> that begin with the at sign (<literal>@</literal>). For example, we can use <literal>@author</literal> and <literal>@version</literal> to provide information about the class. </para><programlisting language="java">
/**
 * Utility class for extracting digits from integers.
 *
 * @author Chris Mayfield
 * @version 1.0
 */
public class DigitUtil {</programlisting><para><indexterm>
  <primary>description</primary>

</indexterm>Documentation comments should begin with a <emphasis role="bold">description</emphasis> of the class or method, followed by the tags. These two sections are separated by a blank line (not counting the <literal>*</literal>). </para><para>For methods, we can use <literal>@param</literal> and <literal>@return</literal> to provide information about parameters and return values. </para><programlisting language="java">
/**
 * Tests whether x is a single digit integer.
 *
 * @param x the integer to test
 * @return true if x has one digit, false otherwise
 */
public static boolean isSingleDigit(int x) {</programlisting><para><indexterm>
  <primary>HTML</primary>

</indexterm><indexterm>
  <primary>Javadoc</primary>

</indexterm><xref linkend="fig.javadoc" /> shows part of the resulting HTML page generated by Javadoc. Notice the relationship between the Javadoc comment (in the source code) and the resulting documentation (in the HTML page). </para>
  
  <figure id="fig.javadoc" float="False">
    <title>HTML documentation for <literal>isSingleDigit</literal>.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/javadoc.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>When writing parameter comments, do not include a hyphen (<literal>-</literal>) after the <literal>@param</literal> tag. Otherwise, you will have two hyphens in the resulting HTML documentation. </para><para>Notice also that the <literal>@return</literal> tag should not specify the type of the method. Comments like <literal>@return boolean</literal> are not useful, because you already know the return type from the method’s signature. </para><para>Methods with multiple parameters should have separate <literal>@param</literal> tags that describe each one. Void methods should have no <literal>@return</literal> tag, since they do not return a value. Each tag should be on its own line in the source code. </para>
</sect1><sect1 id="a0000013538" remap="section">
  <title>Example Source File</title>
    <para>Now let’s take a look at a more complete example. The code for this section is in the <literal>appb</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. </para><para><indexterm>
  <primary>Convert.java</primary>

</indexterm>Professional-grade source files often begin with a copyright statement. This text spans multiple lines, but it is not part of the documentation. So we use a multi-line comment (<literal>/*</literal>) rather than a documentation comment (<literal>/**</literal>). Our example source file, <literal>Convert.java</literal>, includes the MIT License (<ulink url="https://opensource.org/licenses/MIT"></ulink>). </para><para> <programlisting language="java">
/*
 * Copyright (c) 2019 Allen Downey and Chris Mayfield
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</programlisting></para><para>Import statements generally follow the copyright text. After that, we can define the class itself and begin writing the documentation (<literal>/**</literal>). </para><programlisting language="java">
import java.util.Scanner;

/**
 * Methods for converting to/from the metric system.
 *
 * @author Allen Downey
 * @author Chris Mayfield
 * @version 6.1.5
 */
public class Convert {</programlisting><para>A common mistake that beginners make is to put <literal>import</literal> statements between the documentation and the <literal>public class</literal> line. Doing so separates the documentation from the class itself. To avoid this issue, always make the end of the comment (the <literal>*/</literal>) “touch” the word <literal>public</literal>. </para><para>This class has two constants and three methods. The constants are self-explanatory, so there is no need to write documentation for them. </para><programlisting language="java">
public static final double CM_PER_INCH = 2.54;

public static final int IN_PER_FOOT = 12;</programlisting><para>The methods, on the other hand, could use some explanation. Each documentation comment includes a description, followed by a blank line, followed by a <literal>@param</literal> tag for each parameter, followed by a <literal>@return</literal> tag. </para><programlisting language="java">
/**
 * Converts a measurement in centimeters to inches.
 *
 * @param cm length in centimeters
 * @return length in inches
 */
public static double toImperial(double cm) {
    return cm / CM_PER_INCH;
}

/**
 * Converts a length in feet and inches to centimeters.
 *
 * @param feet how many feet
 * @param inches how many inches
 * @return length in centimeters
 */
public static double toMetric(int feet, int inches) {
    int total = feet * IN_PER_FOOT + inches;
    return total * CM_PER_INCH;
}</programlisting><para>The <literal>main</literal> method has a similar documentation comment, except there is no <literal>@return</literal> tag since the method is <literal>void</literal>. </para><programlisting language="java">
/**
 * Tests the conversion methods.
 *
 * @param args command-line arguments
 */
public static void main(String[] args) {
    double cm, result;
    int feet, inches;
    Scanner in = new Scanner(System.in);

    // test the Imperial conversion
    System.out.print("Exactly how many cm? ");
    cm = in.nextDouble();
    result = toImperial(cm);
    System.out.printf("That's %.2f inches\n", result);
    System.out.println();

    // test the Metric conversion
    System.out.print("Now how many feet? ");
    feet = in.nextInt();
    System.out.print("And how many inches? ");
    inches = in.nextInt();
    result = toMetric(feet, inches);
    System.out.printf("That's %.2f cm\n", result);
}</programlisting><para>Here are two ways you can run the Javadoc tool on this example program: </para><orderedlist>
  
  <listitem></listitem>
  
  <listitem> </listitem>
  
  <listitem><para>From the command line, go to the location for <literal>Convert.java</literal>. The <literal>-d</literal> option of <literal>javadoc</literal> indicates where to generate the HTML files. </para><programlisting>javadoc -d doc Convert.java</programlisting><para>From DrJava, click the Javadoc button on the toolbar. The IDE will then prompt you for a location to generate the HTML files. </para></listitem>
  
</orderedlist><para>For more examples of what you can do with Javadoc comments, see the source code of any Java library class (e.g., <literal>Scanner.java</literal>). <xref linkend="src.zip" /> explains how to find the source files for the Java library on your computer. </para>
</sect1><sect1 id="a0000013616" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>documentation:</term>
      <listitem><para><indexterm>
  <primary>documentation</primary>

</indexterm>Comments that describe the technical operation of a class or method. </para></listitem>
  </varlistentry><varlistentry>
    <term>Javadoc:</term>
      <listitem><para><indexterm>
  <primary>Javadoc</primary>

</indexterm>A tool that reads Java source code and generates documentation in HTML format. </para></listitem>
  </varlistentry><varlistentry>
    <term>signature:</term>
      <listitem><para><indexterm>
  <primary>signature</primary>

</indexterm>The first line of a method that defines its name, return type, and parameters. </para></listitem>
  </varlistentry><varlistentry>
    <term>tag:</term>
      <listitem><para><indexterm>
  <primary>tag</primary>

</indexterm>A label that begins with an at sign (<literal>@</literal>) and is used by Javadoc to organize documentation into sections. </para></listitem>
  </varlistentry><varlistentry>
    <term>description:</term>
      <listitem><para><indexterm>
  <primary>description</primary>

</indexterm>The first line of a documentation comment that explains what the class/method does. </para></listitem>
  </varlistentry>
</variablelist>
</sect1>
</appendix><appendix id="graphics">
  <title>Graphics</title><para><indexterm>
  <primary>AWT</primary>

</indexterm><indexterm>
  <primary>java.awt</primary>

</indexterm>The Java library includes the package <literal>java.awt</literal> for drawing 2D graphics. <emphasis role="bold">AWT</emphasis> stands for “Abstract Window Toolkit”. We are only going to scratch the surface of graphics programming. You can read more about it in the Java tutorials at <ulink url="https://thinkjava.org/java2d"></ulink>. </para><sect1 id="a0000013640" remap="section">
  <title>Creating Graphics</title>
    <para><indexterm>
  <primary>Canvas</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Canvas</secondary>
</indexterm><indexterm>
  <primary>Graphics</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>Graphics</secondary>
</indexterm>There are several ways to create graphics in Java; the simplest way is to use <literal>java.awt.Canvas</literal> and <literal>java.awt.Graphics</literal>. A <literal>Canvas</literal> is a blank rectangular area of the screen onto which the application can draw. The <literal>Graphics</literal> class provides basic drawing methods such as <literal>drawLine</literal>, <literal>drawRect</literal>, and <literal>drawString</literal>. </para><para>Here is an example program that draws a circle using the <literal>fillOval</literal> method: </para><programlisting language="java">
import java.awt.Canvas;
import java.awt.Graphics;
import javax.swing.JFrame;

public class Drawing extends Canvas {</programlisting><programlisting language="java">
    public static void main(String[] args) {
        JFrame frame = new JFrame("My Drawing");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        Drawing drawing = new Drawing();
        drawing.setSize(400, 400);
        frame.add(drawing);
        frame.pack();
        frame.setVisible(true);
    }

    public void paint(Graphics g) {
        g.fillOval(100, 100, 200, 200);
    }
}</programlisting><para>The <literal>Drawing</literal> class extends <literal>Canvas</literal>, so it has all the methods provided by <literal>Canvas</literal>, including <literal>setSize</literal>. You can read about the other methods in the documentation, which you can find by doing a web search for “Java Canvas”. </para><para><indexterm>
  <primary>JFrame</primary>

</indexterm><indexterm>
  <primary>class</primary>
<secondary>JFrame</secondary>
</indexterm>In the <literal>main</literal> method, we: </para><orderedlist>
  
  <listitem><para>Create a <literal>JFrame</literal> object, which is the window that will contain the canvas. </para></listitem>
  
  <listitem><para>Create a <literal>Drawing</literal> object (which is the canvas), set its width and height, and add it to the frame. </para></listitem>
  
  <listitem><para>Pack the frame (resize it) to fit the canvas, and display it on the screen. </para></listitem>
  
</orderedlist><para><indexterm>
  <primary>paint</primary>

</indexterm>Once the frame is visible, the <literal>paint</literal> method is called whenever the canvas needs to be drawn; for example, when the window is moved or resized. If you run this code, you should see a black circle on a gray background. </para><para>The application doesn’t end after the <literal>main</literal> method returns; instead, it waits for the <literal>JFrame</literal> to close. When the <literal>JFrame</literal> closes, it calls <literal>System.exit</literal>, which ends the program. </para>
</sect1><sect1 id="a0000013702" remap="section">
  <title>Graphics Methods</title>
    <para><indexterm>
  <primary>coordinate</primary>

</indexterm>You are probably used to Cartesian <emphasis role="bold">coordinates</emphasis>, where <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> values can be positive or negative. In contrast, Java uses a coordinate system where the origin is in the upper-left corner. That way, <emphasis role="math">x</emphasis> and <emphasis role="math">y</emphasis> can always be positive integers. <xref linkend="fig.coordinates" /> shows these coordinate systems side-by-side. </para>
  
  <figure id="fig.coordinates" float="False">
    <title>Diagram of the difference between Cartesian coordinates and Java graphical coordinates.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/coordinates.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>pixel</primary>

</indexterm>Graphical coordinates are measured in <emphasis role="bold">pixels</emphasis>; each pixel corresponds to a dot on the screen. </para><para>To draw on the canvas, you invoke methods on a <literal>Graphics</literal> object. You don’t have to create the <literal>Graphics</literal> object; it gets created when you create the <literal>Canvas</literal>, and it gets passed as an argument to <literal>paint</literal>. </para><para>The previous example used <literal>fillOval</literal>, which has the following signature: </para><programlisting language="java">
/**
 * Fills an oval bounded by the specified rectangle with
 * the current color.
 */
public void fillOval(int x, int y, int width, int height)</programlisting><para><indexterm>
  <primary>bounding box</primary>

</indexterm>The four parameters specify a <emphasis role="bold">bounding box</emphasis>, which is the rectangle in which the oval is drawn. <literal>x</literal> and <literal>y</literal> specify the location of the upper-left corner of the bounding box. The bounding box itself is not drawn (see <xref linkend="fig.circle" />). </para>
  
  <figure id="fig.circle" float="False">
    <title>Diagram of an oval inside its bounding box.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/circle.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
<para><indexterm>
  <primary>Color</primary>

</indexterm>To choose the color of a shape, invoke <literal>setColor</literal> on the <literal>Graphics</literal> object: </para><programlisting language="java">
g.setColor(Color.RED);</programlisting><para>The <literal>setColor</literal> method determines the color of everything that gets drawn afterward. <literal>Color.red</literal> is a constant provided by the <literal>Color</literal> class; to use it you have to <literal>import java.awt.Color</literal>. Other colors include: </para><programlisting>BLACK       BLUE      CYAN     DARKGRAY   GRAY    LIGHTGRAY
GREEN       MAGENTA   ORANGE   PINK       WHITE   YELLOW</programlisting><para><indexterm>
  <primary>RGB</primary>

</indexterm>You can create your own colors by specifying the red, green, and blue (<emphasis role="bold">RGB</emphasis>) components. For example: </para><programlisting language="java">
Color purple = new Color(128, 0, 128);</programlisting><para>Each value is an integer in the range 0 (darkest) to 255 (lightest). The color <literal>(0, 0, 0)</literal> is black, and <literal>(255, 255, 255)</literal> is white. </para><para>You can set the background color of the <literal>Canvas</literal> by invoking <literal>setBackground</literal>: </para><programlisting language="java">
canvas.setBackground(Color.WHITE);</programlisting></sect1><sect1 id="a0000013790" remap="section">
  <title>Example Drawing</title>
    <para><indexterm>
  <primary>Mickey Mouse</primary>

</indexterm>Suppose we want to draw a “Hidden Mickey”, which is an icon that represents Mickey Mouse (see <ulink url="https://en.wikipedia.org/wiki/Hidden_Mickey"></ulink>). We can use the oval we just drew as the face, and then add two ears. To make the code more readable, let’s use <literal>Rectangle</literal> objects to represent bounding boxes. </para><para>Here’s a method that takes a <literal>Rectangle</literal> and invokes <literal>fillOval</literal>: </para><programlisting language="java">
public void boxOval(Graphics g, Rectangle bb) {
    g.fillOval(bb.x, bb.y, bb.width, bb.height);
}</programlisting><para>And here’s a method that draws Mickey Mouse: </para><programlisting language="java">
public void mickey(Graphics g, Rectangle bb) {
    boxOval(g, bb);

    int hx = bb.width / 2;
    int hy = bb.height / 2;
    Rectangle half = new Rectangle(bb.x, bb.y, hx, hy);

    half.translate(-hx / 2, -hy / 2);
    boxOval(g, half);

    half.translate(hx * 2, 0);
    boxOval(g, half);
}</programlisting><para>The first line draws the face. The next three lines create a smaller rectangle for the ears. We <literal>translate</literal> the rectangle up and left for the first ear, then to the right for the second ear. The result is shown in <xref linkend="fig.mickey" />. </para>
  
  <figure id="fig.mickey" float="False">
    <title>A “Hidden Mickey” drawn using Java graphics.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/mickey.png"></imagedata>
  </imageobject>
</mediaobject></figure>
<para>You can read more about <literal>Rectangle</literal> and <literal>translate</literal> in <xref linkend="mutable" />. See the exercises at the end of this appendix for more example drawings. </para>
</sect1><sect1 id="a0000013824" remap="section">
  <title>Vocabulary</title>
    <variablelist>
  <varlistentry>
    <term>AWT:</term>
      <listitem><para><indexterm>
  <primary>AWT</primary>

</indexterm>The “Abstract Window Toolkit”, a Java package for creating graphical user interfaces. </para></listitem>
  </varlistentry><varlistentry>
    <term>coordinate:</term>
      <listitem><para><indexterm>
  <primary>coordinate</primary>

</indexterm>A value that specifies a location in a 2D graphical window. </para></listitem>
  </varlistentry><varlistentry>
    <term>pixel:</term>
      <listitem><para><indexterm>
  <primary>pixel</primary>

</indexterm>The unit in which coordinates are measured. </para></listitem>
  </varlistentry><varlistentry>
    <term>bounding box:</term>
      <listitem><para><indexterm>
  <primary>bounding box</primary>

</indexterm>A way to specify the coordinates of a rectangular area. </para></listitem>
  </varlistentry><varlistentry>
    <term>RGB:</term>
      <listitem><para><indexterm>
  <primary>RGB</primary>

</indexterm>A color model based on adding red, green, and blue light. </para></listitem>
  </varlistentry>
</variablelist>
</sect1><sect1 id="a0000013837" remap="section">
  <title>Exercises</title>
    <para>The code for this chapter is in the <literal>appc</literal> directory of <literal>ThinkJavaCode2</literal>. See <xref linkend="code" /> for instructions on how to download the repository. Before you start the exercises, we recommend that you compile and run the examples. </para><para><example id="a0000013846" role="exercise">
  <title></title>
  <para>Draw the flag of Japan: a red circle on a white background that is wider than it is tall. </para>
</example> </para><para><example id="a0000013849" role="exercise">
  <title></title>
  <para>Modify <literal>Mickey.java</literal> to draw ears on the ears, and ears on those ears, and more ears all the way down until the smallest ears are only 3 pixels wide. The result should look like “Mickey Moose”, shown in <xref linkend="fig.moose" />. <emphasis>Hint:</emphasis> You should only have to add or modify a few lines of code. </para>
  
  <figure id="fig.moose" float="False">
    <title>A recursive shape we call “Mickey Moose”.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/moose.png"></imagedata>
  </imageobject>
</mediaobject></figure>

</example> </para><para><example id="a0000013864" role="exercise">
  <title></title>
  <para>In this exercise, you will draw “Moiré patterns” that seem to shift around as you move. For an explanation of what is going on, see <ulink url="https://en.wikipedia.org/wiki/Moire_pattern"></ulink>. </para><orderedlist>
  
  <listitem><para>Open <literal>Moire.java</literal> and read the <literal>paint</literal> method. Draw a sketch of what you expect it to do. Now run it. Did you get what you expected? </para></listitem>
  
  <listitem><para>Modify the program so that the space between the circles is larger or smaller. See what happens to the image. </para></listitem>
  
  <listitem><para>Modify the program so that the circles are drawn in the center of the screen and concentric, as in <xref linkend="fig.moire" /> (left). The distance between the circles should be small enough that the Moiré interference is apparent. </para>
  
  <figure id="fig.moire" float="False">
    <title>Graphical patterns that can exhibit Moiré interference.</title>
     <mediaobject>
  <imageobject remap="includegraphics">
    <imagedata fileref="figs/moire.pdf"></imagedata>
  </imageobject>
</mediaobject></figure>
</listitem>
  
  <listitem><para>Write a method named <literal>radial</literal> that draws a radial set of line segments as shown in <xref linkend="fig.moire" /> (right), but they should be close enough together to create a Moiré pattern. </para></listitem>
  
  <listitem><para>Just about any kind of graphical pattern can generate Moiré-like interference patterns. Play around and see what you can create. </para></listitem>
  
</orderedlist>
</example> </para>
</sect1>
</appendix><appendix id="debugging">
  <title>Debugging</title><para><indexterm>
  <primary>debugging</primary>

</indexterm>Although there are debugging suggestions throughout the book, we thought it would be useful to say more in an appendix. If you are having a hard time debugging, you might want to review this appendix from time to time. </para><para>The best debugging strategy depends on what kind of error you have: </para><itemizedlist>
  
    <listitem><para><indexterm>
  <primary>compile-time error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>compile-time</secondary>
</indexterm><indexterm>
  <primary>syntax</primary>

</indexterm><emphasis role="bold">Compile-time errors</emphasis> indicate that there is something wrong with the syntax of the program. Example: omitting the semicolon at the end of a statement. </para></listitem>
  
    <listitem><para><indexterm>
  <primary>run-time error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>run-time</secondary>
</indexterm><indexterm>
  <primary>exception</primary>

</indexterm><emphasis role="bold">Run-time errors</emphasis> are produced if something goes wrong while the program is running. Example: an infinite recursion eventually causes a <literal>StackOverflowError</literal>. </para></listitem>
  
    <listitem><para><indexterm>
  <primary>logic error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>logic</secondary>
</indexterm><emphasis role="bold">Logic errors</emphasis> cause the program to do the wrong thing. Example: an expression may not be evaluated in the order you expect. </para></listitem>
  
</itemizedlist><para>The following sections are organized by error type; some techniques are useful for more than one type. </para><sect1 id="a0000013925" remap="section">
  <title>Compile-Time Errors</title>
    <para>The best kind of debugging is the kind you don’t have to do because you avoid making errors in the first place. Incremental development, which we presented in <xref linkend="distance" />, can help. The key is to start with a working program and add small amounts of code at a time. When there is an error, you will have a pretty good idea where it is. </para><para>Nevertheless, you might find yourself in one of the following situations. For each situation, we have some suggestions about how to proceed. </para><sect2 id="a0000013930" remap="subsection">
  <title>The compiler is spewing error messages.</title>
    <para><indexterm>
  <primary>compile</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>message</secondary>
</indexterm>If the compiler reports 100 error messages, that doesn’t mean there are 100 errors in your program. When the compiler encounters an error, it often gets thrown off track for a while. It tries to recover and pick up again after the first error, but sometimes it reports spurious errors. </para><para>Only the first error message is truly reliable. We suggest that you only fix one error at a time, and then recompile the program. You may find that one semicolon or brace “fixes” 100 errors. </para>
</sect2><sect2 id="a0000013934" remap="subsection">
  <title>I’m getting a weird compiler message, and it won’t go away.</title>
    <para>First of all, read the error message carefully. It may be written in terse jargon, but often there is a carefully hidden kernel of information. </para><para>If nothing else, the message will tell you where in the program the problem occurred. Actually, it tells you where the compiler was when it noticed a problem, which is not necessarily where the error is. Use the information the compiler gives you as a guideline, but if you don’t see an error where the compiler is pointing, broaden the search. </para><para>Generally the error will be prior to the location of the error message, but there are cases where it will be somewhere else entirely. For example, if you get an error message at a method invocation, the actual error may be in the method definition itself. </para><para>If you don’t find the error quickly, take a breath and look more broadly at the entire program. Make sure the program is indented properly; that makes it easier to spot syntax errors. </para><para><indexterm>
  <primary>syntax errors</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>syntax</secondary>
</indexterm>Now, start looking for common syntax errors: </para><orderedlist>
  
  <listitem><para>Check that all parentheses and brackets are balanced and properly nested. All method definitions should be nested within a class definition. All program statements should be within a method definition. </para></listitem>
  
  <listitem><para>Remember that uppercase letters are not the same as lowercase letters. </para></listitem>
  
  <listitem><para>Check for semicolons at the end of statements (and no semicolons after curly braces). </para><para><indexterm>
  <primary>quote mark</primary>

</indexterm></para></listitem>
  
  <listitem><para>Make sure that any strings in the code have matching quotation marks. Make sure that you use double quotes for strings and single quotes for characters. </para></listitem>
  
  <listitem><para>For each assignment statement, make sure that the type on the left is the same as the type on the right. Make sure that the expression on the left is a variable name or something else that you can assign a value to (like an element of an array). </para></listitem>
  
  <listitem><para>For each method invocation, make sure that the arguments you provide are in the right order and have the right type, and that the object you are invoking the method on is the right type. </para></listitem>
  
  <listitem><para>If you are invoking a value method, make sure you are doing something with the result. If you are invoking a void method, make sure you are <emphasis>not</emphasis> trying to do something with the result. </para></listitem>
  
  <listitem><para>If you are invoking an instance method, make sure you are invoking it on an object with the right type. If you are invoking a static method from outside the class where it is defined, make sure you specify the class name (using dot notation). </para></listitem>
  
  <listitem><para>Inside an instance method you can refer to the instance variables without specifying an object. If you try that in a static method—with or without <literal>this</literal>—you get a message like “non-static variable x cannot be referenced from a static context.” </para></listitem>
  
</orderedlist><para>If nothing works, move on to the next section... </para>
</sect2><sect2 id="a0000013967" remap="subsection">
  <title>I can’t get my program to compile no matter what I do.</title>
    <para>If the compiler says there is an error and you don’t see it, that might be because you and the compiler are not looking at the same code. Check your development environment to make sure the program you are editing is the program the compiler is compiling. </para><para>This situation is often the result of having multiple copies of the same program. You might be editing one version of the file, but compiling a different version. </para><para>If you are not sure, try putting an obvious and deliberate syntax error right at the beginning of the program. Now compile again. If the compiler doesn’t find the new error, there is probably something wrong with the way you set up the development environment. </para><para><indexterm>
  <primary>debugging</primary>
<secondary>by bisection</secondary>
</indexterm>If you have examined the code thoroughly, and you are sure the compiler is compiling the right source file, it is time for desperate measures: <emphasis role="bold">debugging by bisection</emphasis>. </para><itemizedlist>
  
    <listitem><para>Make a backup of the file you are working on. If you are working on <literal>Bob.java</literal>, make a copy called <literal>Bob.java.old</literal>. </para></listitem>
  
    <listitem><para>Delete about half the code from <literal>Bob.java</literal>. Try compiling again. </para><itemizedlist>
  
    <listitem><para>If the program compiles now, you know the error is in the code you deleted. Bring back about half of what you deleted and repeat. </para></listitem>
  
    <listitem><para>If the program still doesn’t compile, the error must be in the code that remains. Delete about half of the remaining code and repeat. </para></listitem>
  
</itemizedlist></listitem>
  
    <listitem><para>Once you have found and fixed the error, start bringing back the code you deleted, a little bit at a time. </para></listitem>
  
</itemizedlist><para>This process is ugly, but it goes faster than you might think, and it is very reliable. It works for other programming languages too! </para>
</sect2><sect2 id="a0000013996" remap="subsection">
  <title>I did what the compiler told me to do, but it still doesn’t work.</title>
    <para>Some error messages come with tidbits of advice, like “class Golfer must be declared abstract. It does not define int compareTo(java.lang.Object) from interface java.lang.Comparable.” It sounds like the compiler is telling you to declare <literal>Golfer</literal> as an <literal>abstract</literal> class, and if you are reading this book, you probably don’t know what that is or how to do it. </para><para>Fortunately, the compiler is wrong. The solution in this case is to make sure <literal>Golfer</literal> has a method called <literal>compareTo</literal> that takes an <literal>Object</literal> as a parameter. </para><para>Don’t let the compiler lead you by the nose. Error messages give you evidence that something is wrong, but the remedies they suggest are unreliable. </para>
</sect2>
</sect1><sect1 id="a0000014010" remap="section">
  <title>Run-Time Errors</title>
    <para>It’s not always clear what causes a run-time error, but you can often figure things out by adding print statements to your program. </para><sect2 id="a0000014012" remap="subsection">
  <title>My program hangs.</title>
    <para><indexterm>
  <primary>hanging</primary>

</indexterm><indexterm>
  <primary>infinite loop</primary>

</indexterm><indexterm>
  <primary>infinite recursion</primary>

</indexterm>If a program stops and seems to be doing nothing, we say it is “hanging”. Often that means it is caught in an infinite loop or an infinite recursion. </para><itemizedlist>
  
    <listitem><para>If there is a particular loop that you suspect is the problem, add a print statement immediately before the loop that says “entering the loop” and another immediately after that says “exiting the loop”. </para><para><indexterm>
  <primary>StackOverflowError</primary>

</indexterm>Run the program. If you get the first message and not the second, you know where the program is getting stuck. Go to the section titled “Infinite loop”.</para></listitem>
  
    <listitem><para>Most of the time an infinite recursion will cause the program to run for a while and then produce a <literal>StackOverflowError</literal>. If that happens, go to the section titled “Infinite recursion”.</para><para>If you are not getting a <literal>StackOverflowError</literal>, but you suspect there is a problem with a recursive method, you can still use the techniques in the infinite recursion section. </para></listitem>
  
    <listitem><para>If neither of the previous suggestions helps, you might not understand the flow of execution in your program. Go to the section titled “Flow of execution”.</para></listitem>
  
</itemizedlist><sect3 id="infloop" remap="subsubsection">
  <title>Infinite Loop</title><para>If you think you have an infinite loop and you know which loop it is, add a print statement at the end of the loop that displays the values of the variables in the condition, and the value of the condition. </para><para>For example: </para><programlisting language="java">
while (x &gt; 0 &amp;&amp; y &lt; 0) {
    // do something to x
    // do something to y

    System.out.println("x: " + x);
    System.out.println("y: " + y);
    System.out.println("condition: " + (x &gt; 0 &amp;&amp; y &lt; 0));
}</programlisting><para>Now when you run the program you see three lines of output for each time through the loop. The last time through the loop, the condition should be <literal>false</literal>. If the loop keeps going, you will see the values of <literal>x</literal> and <literal>y</literal>, and you might figure out why they are not getting updated correctly. </para>
</sect3><sect3 id="infrec" remap="subsubsection">
  <title>Infinite Recursion</title><para><indexterm>
  <primary>recursion</primary>
<secondary>infinite</secondary>
</indexterm><indexterm>
  <primary>infinite recursion</primary>

</indexterm>Most of the time, an infinite recursion will cause the program to throw a <literal>StackOverflowError</literal>. But if the program is slow, it may take a long time to fill the stack. </para><para>If you know which method is causing an infinite recursion, check that there is a base case. There should be some condition that makes the method return without making a recursive invocation. If not, you need to rethink the algorithm and identify a base case. </para><para>If there is a base case, but the program doesn’t seem to be reaching it, add a print statement at the beginning of the method that displays the parameters. Now when you run the program you see a few lines of output every time the method is invoked, and you can see the values of the parameters. If the parameters are not moving toward the base case, you might see why not. </para>
</sect3><sect3 id="flowexec" remap="subsubsection">
  <title>Flow of Execution</title><para><indexterm>
  <primary>flow of execution</primary>

</indexterm><indexterm>
  <primary>tracing</primary>

</indexterm>If you are not sure how the flow of execution is moving through your program, add print statements to the beginning of each method with a message like “entering method foo”, where <literal>foo</literal> is the name of the method. Now when you run the program, it displays a trace of each method as it is invoked. </para><para>You can also display the arguments each method receives. When you run the program, check whether the values are reasonable, and check for one of the most common errors—providing arguments in the wrong order. </para>
</sect3>
</sect2><sect2 id="a0000014058" remap="subsection">
  <title>When I run the program I get an exception.</title>
    <para><indexterm>
  <primary>exception</primary>

</indexterm><indexterm>
  <primary>stack trace</primary>

</indexterm>When an exception occurs, Java displays a message that includes the name of the exception, the line of the program where the exception occurred, and a “stack trace”. The stack trace includes the method that was running, the method that invoked it, the method that invoked that one, and so on. </para><para>The first step is to examine the place in the program where the error occurred and see if you can figure out what happened. </para><variablelist>
  <varlistentry>
    <term>NullPointerException:</term>
      <listitem><para><indexterm>
  <primary>NullPointerException</primary>

</indexterm>You tried to access an instance variable or invoke a method on an object that is currently <literal>null</literal>. You should figure out which variable is <literal>null</literal> and then figure out how it got to be that way. </para><para>Remember that when you declare a variable with an array type, its elements are initially <literal>null</literal> until you assign a value to them. For example, this code causes a <literal>NullPointerException</literal>: </para><programlisting language="java">
int[] array = new Point[5];
System.out.println(array[0].x);</programlisting></listitem>
  </varlistentry><varlistentry>
    <term>ArrayIndexOutOfBoundsException:</term>
      <listitem><para><indexterm>
  <primary>ArrayIndexOutOfBoundsException</primary>

</indexterm>The index you are using to access an array is either negative or greater than <literal>array.length - 1</literal>. If you can find the site where the problem is, add a print statement immediately before it to display the value of the index and the length of the array. Is the array the right size? Is the index the right value? </para><para>Now work your way backwards through the program and see where the array and the index come from. Find the nearest assignment statement and see if it is doing the right thing. If either one is a parameter, go to the place where the method is invoked and see where the values are coming from. </para></listitem>
  </varlistentry><varlistentry>
    <term>StackOverflowError:</term>
      <listitem><para><indexterm>
  <primary>StackOverflowError</primary>

</indexterm>See “Infinite recursion” on <xref linkend="infrec" />. </para></listitem>
  </varlistentry><varlistentry>
    <term>FileNotFoundException:</term>
      <listitem><para><indexterm>
  <primary>FileNotFoundException</primary>

</indexterm>This means Java didn’t find the file it was looking for. If you are using a project-based development environment like Eclipse, you might have to import the file into the project. Otherwise make sure the file exists and that the path is correct. This problem depends on your file system, so it can be hard to track down. </para></listitem>
  </varlistentry><varlistentry>
    <term>ArithmeticException:</term>
      <listitem><para><indexterm>
  <primary>ArithmeticException</primary>

</indexterm>Something went wrong during an arithmetic operation; for example, division by zero. </para></listitem>
  </varlistentry>
</variablelist>
</sect2><sect2 id="a0000014090" remap="subsection">
  <title>I added so many print statements I get inundated with output.</title>
    <para><indexterm>
  <primary>print statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>print</secondary>
</indexterm>One of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: either simplify the output, or simplify the program. </para><para>To simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand. As you develop a program, you should write code to generate concise, informative traces of what the program is doing. </para><para>To simplify the program, scale down the problem the program is working on. For example, if you are sorting an array, sort a <emphasis>small</emphasis> array. If the program takes input from the user, give it the simplest input that causes the error. </para><para><indexterm>
  <primary>nested</primary>

</indexterm>Also, clean up the code. Remove unnecessary or experimental parts, and reorganize the program to make it easier to read. For example, if you suspect that the error is in a deeply-nested part of the program, rewrite that part with a simpler structure. If you suspect a large method, split it into smaller methods and test them separately. </para><para>The process of finding the minimal test case often leads you to the bug. For example, if you find that a program works when the array has an even number of elements, but not when it has an odd number, that gives you a clue about what is going on. </para><para>Reorganizing the program can help you find subtle bugs. If you make a change that you think doesn’t affect the program, and it does, that can tip you off. </para>
</sect2>
</sect1><sect1 id="a0000014101" remap="section">
  <title>Logic Errors</title>
    <sect2 id="a0000014102" remap="subsection">
  <title>My program doesn’t work.</title>
    <para>Logic errors are hard to find because the compiler and interpreter provide no information about what is wrong. Only you know what the program is supposed to do, and only you know that it isn’t doing it. </para><para>The first step is to make a connection between the code and the behavior you get. You need a hypothesis about what the program is actually doing. Here are some questions to ask yourself: </para><itemizedlist>
  
    <listitem><para>Is there something the program was supposed to do, but doesn’t seem to be happening? Find the section of the code that performs that function, and make sure it is executing when you think it should. See “Flow of execution” on <xref linkend="flowexec" />. </para></listitem>
  
    <listitem><para>Is something happening that shouldn’t? Find code in your program that performs that function, and see if it is executing when it shouldn’t. </para></listitem>
  
    <listitem><para>Is a section of code producing an unexpected effect? Make sure you understand the code, especially if it invokes methods in the Java library. Read the documentation for those methods, and try them out with simple test cases. They might not do what you think they do. </para></listitem>
  
</itemizedlist><para>To program, you need a mental model of what your code does. If it doesn’t do what you expect, the problem might not actually be the program; it might be in your head. </para><para><indexterm>
  <primary>mental model</primary>

</indexterm>The best way to correct your mental model is to break the program into components (usually the classes and methods) and test them independently. Once you find the discrepancy between your model and reality, you can solve the problem. </para><para><indexterm>
  <primary>logic error</primary>

</indexterm><indexterm>
  <primary>error</primary>
<secondary>logic</secondary>
</indexterm>Here are some common logic errors to check for: </para><itemizedlist>
  
    <listitem><para>Remember that integer division always rounds toward zero. If you want fractions, use <literal>double</literal>. More generally, use integers for countable things and floating-point numbers for measurable things. </para></listitem>
  
    <listitem><para>Floating-point numbers are only approximate, so don’t rely on them to be perfectly accurate. You should probably never use the <literal>==</literal> operator with <literal>double</literal>s. Instead of writing <literal>if (d == 1.23)</literal>, do something like <literal>if (Math.abs(d - 1.23) &lt; .000001)</literal>. </para></listitem>
  
    <listitem><para>When you apply the equality operator (<literal>==</literal>) to objects, it checks whether they are identical. If you meant to check equivalence, you should use the <literal>equals</literal> method instead. </para></listitem>
  
    <listitem><para>By default for user-defined types, <literal>equals</literal> checks identity. If you want a different notion of equivalence, you have to override it. </para></listitem>
  
    <listitem><para>Inheritance can lead to subtle logic errors, because you can run inherited code without realizing it. See “Flow of execution” on <xref linkend="flowexec" />. </para></listitem>
  
</itemizedlist>
</sect2><sect2 id="a0000014150" remap="subsection">
  <title>I’ve got a big hairy expression and it doesn’t do what I expect.</title>
    <para><indexterm>
  <primary>expression</primary>
<secondary>big and hairy</secondary>
</indexterm>Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables. </para><programlisting language="java">
rect.setLocation(rect.getLocation().translate(
                 -rect.getWidth(), -rect.getHeight()));</programlisting><para>This example can be rewritten as: </para><programlisting language="java">
int dx = -rect.getWidth();
int dy = -rect.getHeight();
Point location = rect.getLocation();
Point newLocation = location.translate(dx, dy);
rect.setLocation(newLocation);</programlisting><para>The second version is easier to read, partly because the variable names provide additional documentation. It’s also easier to debug, because you can check the types of the temporary variables and display their values. </para><para><indexterm>
  <primary>temporary variable</primary>

</indexterm><indexterm>
  <primary>variable</primary>
<secondary>temporary</secondary>
</indexterm><indexterm>
  <primary>order of operations</primary>

</indexterm><indexterm>
  <primary>precedence</primary>

</indexterm>Another problem that can occur with big expressions is that the order of operations may not be what you expect. For example, to evaluate <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mfrac><mml:mi>x</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:mfrac></mml:math></inlineequation>, you might write: </para><programlisting language="java">
double y = x / 2 * Math.PI;</programlisting><para>That is not correct, because multiplication and division have the same precedence, and they are evaluated from left to right. This code computes <inlineequation><mml:math overflow="scroll" xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow><mml:mfrac><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mi>π</mml:mi></mml:mrow></mml:math></inlineequation>. </para><para>If you are not sure of the order of operations, check the documentation, or use parentheses to make it explicit. </para><programlisting language="java">
double y = x / (2 * Math.PI);</programlisting><para>This version is correct, and more readable for other people who haven’t memorized the order of operations. </para>
</sect2><sect2 id="a0000014174" remap="subsection">
  <title>My method doesn’t return what I expect.</title>
    <para><indexterm>
  <primary>return statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>return</secondary>
</indexterm>If you have a return statement with a complex expression, you don’t have a chance to display the value before returning. </para><programlisting language="java">
public Rectangle intersection(Rectangle a, Rectangle b) {
    return new Rectangle(
        Math.min(a.x, b.x), Math.min(a.y, b.y),
        Math.max(a.x + a.width, b.x + b.width)
            - Math.min(a.x, b.x)
        Math.max(a.y + a.height, b.y + b.height)
            - Math.min(a.y, b.y));
}</programlisting><para>Instead of writing everything in one statement, use temporary variables: </para><programlisting language="java">
public Rectangle intersection(Rectangle a, Rectangle b) {
    int x1 = Math.min(a.x, b.x);
    int y1 = Math.min(a.y, b.y);
    int x2 = Math.max(a.x + a.width, b.x + b.width);
    int y2 = Math.max(a.y + a.height, b.y + b.height);
    Rectangle rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);
    return rect;
}</programlisting><para>Now you have the opportunity to display any of the intermediate variables before returning. And by reusing <literal>x1</literal> and <literal>y1</literal>, you made the code smaller, too. </para>
</sect2><sect2 id="a0000014187" remap="subsection">
  <title>My print statement isn’t doing anything.</title>
    <para><indexterm>
  <primary>print statement</primary>

</indexterm><indexterm>
  <primary>statement</primary>
<secondary>print</secondary>
</indexterm>If you use the <literal>println</literal> method, the output is displayed immediately, but if you use <literal>print</literal> (at least in some environments), the output gets stored without being displayed until the next newline. If the program terminates without displaying a newline, you may never see the stored output. If you suspect that this is happening, change some or all of the <literal>print</literal> statements to <literal>println</literal>. </para>
</sect2><sect2 id="a0000014198" remap="subsection">
  <title>I’m really, really stuck and I need help.</title>
    <para>First, get away from the computer for a few minutes. Computers emit waves that affect the brain, causing the following symptoms: </para><itemizedlist>
  
    <listitem><para>Frustration and rage. </para></listitem>
  
    <listitem><para>Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backwards”). </para></listitem>
  
    <listitem><para>Sour grapes (“this program is lame anyway”). </para></listitem>
  
</itemizedlist><para>If you suffer from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are possible causes of that behavior? When was the last time you had a working program, and what did you do next? </para><para>Sometimes it just takes time to find a bug. People often find bugs when they let their mind wander. Good places to find bugs are buses, showers, and bed. </para>
</sect2><sect2 id="a0000014210" remap="subsection">
  <title>No, I really need help.</title>
    <para>It happens. Even the best programmers get stuck. Sometimes you need another pair of eyes. </para><para>Before you bring someone else in, make sure you have tried the techniques described in this appendix. </para><para>Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely. </para><para>When you bring someone in to help, give them the information they need: </para><itemizedlist>
  
    <listitem><para>What kind of bug is it? Compile-time, run-time, or logic? </para></listitem>
  
    <listitem><para>What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the test case that fails? </para></listitem>
  
    <listitem><para>If the bug occurs at compile time or run time, what is the error message, and what part of the program does it indicate? </para></listitem>
  
    <listitem><para>What have you tried, and what have you learned? </para></listitem>
  
</itemizedlist><para><indexterm>
  <primary>rubber duck</primary>

</indexterm><indexterm>
  <primary>debugging</primary>
<secondary>rubber duck</secondary>
</indexterm>By the time you explain the problem to someone, you might see the answer. This phenomenon is so common that some people recommend a debugging technique called “rubber ducking”. Here’s how it works: </para><orderedlist>
  
  <listitem><para>Buy a standard-issue rubber duck. </para></listitem>
  
  <listitem><para>When you are really stuck on a problem, put the rubber duck on the desk in front of you and say, “Rubber duck, I am stuck on a problem. Here’s what’s happening...” </para></listitem>
  
  <listitem><para>Explain the problem to the rubber duck. </para></listitem>
  
  <listitem><para>Discover the solution. </para></listitem>
  
  <listitem><para>Thank the rubber duck. </para></listitem>
  
</orderedlist><para>We’re not kidding, it works! See <ulink url="https://en.wikipedia.org/wiki/Rubber_duck_debugging"></ulink>. </para>
</sect2><sect2 id="a0000014241" remap="subsection">
  <title>I found the bug!</title>
    <para>When you find the bug, it is usually obvious how to fix it. But not always. Sometimes what seems to be a bug is really an indication that you don’t understand the program, or there is an error in your algorithm. In these cases, you might have to rethink the algorithm, or adjust your mental model. Take some time away from the computer to think, work through test cases by hand, or draw diagrams to represent the computation. </para><para>After you fix the bug, don’t just start in making new errors. Take a minute to think about what kind of bug it was, why you made the error, how the error manifested itself, and what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly. Or even better, you will learn to avoid that type of bug for good. </para></sect2>
</sect1>
</appendix>
<index></index>
</book>
