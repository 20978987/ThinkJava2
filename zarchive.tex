%%% Section 2.9
\section{Composition}

\index{composition}

So far we have looked at the elements of a programming language -- variables, expressions, and statements -- in isolation, without talking about how to put them together.

One of the most useful features of programming languages is their ability to take small building blocks and {\bf compose} them.
For example, we know how to multiply numbers and we know how to display values.
We can combine these operations into a single statement:

\begin{code}
System.out.println(17 * 3);
\end{code}

Any arithmetic expression can be used inside a print statement.
We've already seen one example:

\begin{code}
System.out.println(hour * 60 + minute);
\end{code}

You can also put arbitrary expressions on the right side of an assignment:

\begin{code}
int percentage;
percentage = (minute * 100) / 60;
\end{code}

The left side of an assignment must be a variable name, not an expression.
That's because the left side indicates where the result will be stored, and expressions do not represent storage locations.

\begin{code}
hour = minute + 1;  // correct
minute + 1 = hour;  // compiler error
\end{code}

\index{readability}

The ability to compose operations may not seem impressive now, but we will see examples later on that allow us to write complex computations neatly and concisely.
But don't get too carried away.
Large, complex expressions can be hard to read and debug.

%Before you get too carried away with composition, keep in mind that other people will be reading your source code.
%In practice, software developers spend the vast majority of their time {\em understanding} and {\em modifying} existing code.
%Thus it's far more important to write code that is readable than to write code that is (or appears to be) optimal.
%There is much beauty in simplicity.
%In general, each line of code should be a single step of the algorithm.


%%% Chapter 4 (commented out)
\begin{exercise}

What is the difference between a variable and a method?
In terms of their syntax, how does the Java compiler tell the difference between the two?

%A variable is a {\em location of data}, whereas a method is a {\em location of code}.
%In Java, methods always have parentheses, even if they have no arguments like \java{System.out.println()}.

\end{exercise}


%%% Chapter 4 (commented out)
%ABD: We don't need this anymore since we used this as an example
\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{time} when \java{main} invokes \java{printTime} with the arguments \java{11} and \java{59}.

\end{exercise}


%%% Chapter 8 (commented out)
% CSM: we now discuss binary search in Chapter 12
\begin{exercise}

In Section~\ref{traversal} we wrote a method called \java{search} that traverses an array and returns the index of a given value, or -1 if the value is not in the array.

If the elements of the array are sorted, we can make this method more efficient using a ``binary search''.
You can read about it at \url{https://en.wikipedia.org/wiki/Binary_search_algorithm}.

Write a method called \java{binarySearch} that implements this algorithm.
{\it Hint:} You might find it easier to write this method recursively.

\end{exercise}


%%% Chapter 12 (commented out)
% NOTE: this is not a very good exercise
\begin{exercise}

In Blackjack the object of the game is to get a collection of cards with a score of 21.
The score for a hand is the sum of scores for all cards.
The score for an ace is 1, for all face cards is ten, and for all other cards the score is the same as the rank.
For example, the hand (Ace, 10, Jack, 3) has a total score of 1 + 10 + 10 + 3 = 24.

Write a method called \java{handScore} that takes an array of cards as an argument and that returns the total score.

\end{exercise}


%%% Section 6.4
\section{Overloading}
\label{overloading}

You might have noticed that \java{circleArea} and \java{calculateArea} perform similar functions.
They both find the area of a circle, but they take different parameters.
For \java{calculateArea}, we have to provide the radius; for \java{circleArea} we provide two points.

\index{overload}

If two methods do the same thing, it is natural to give them the same name.
Having more than one method with the same name is called {\bf overloading}, and it is legal in Java as long as each version takes different parameters.
So we could rename \java{circleArea} to \java{calculateArea}:

\begin{code}
public static double calculateArea
        (double xc, double yc, double xp, double yp) {
    return calculateArea(distance(xc, yc, xp, yp));
}
\end{code}

Note that this new \java{calculateArea} method is {\em not} recursive.
When you invoke an overloaded method, Java knows which version you want by looking at the arguments that you provide.
If you write:

\begin{code}
double x = calculateArea(3.0);
\end{code}

Java looks for a method named \java{calculateArea} that takes one \java{double} as an argument, and so it uses the first version, which interprets the argument as a radius.
If you write:

\begin{code}
double y = calculateArea(1.0, 2.0, 4.0, 6.0);
\end{code}

Java uses the second version of \java{calculateArea}, which interprets the arguments as two points.
In this example, the second version actually invokes the first version.

Many Java methods are overloaded, meaning that there are different versions that accept different numbers or types of parameters.
For example, there are versions of \java{print} and \java{println} that accept a single parameter of any data type.
In the \java{Math} class, there is a version of \java{abs} that works on \java{double}s, and there is also a version for \java{int}s.

Although overloading is a useful feature, it should be used with caution.
You might get yourself nicely confused if you are trying to debug one version of a method while accidentally invoking a different one.


%%% Section 6.5
\section{Boolean methods}
\label{boolean}

\index{boolean}
\index{method!boolean}

Methods can return \java{boolean} values, just like any other type, which is often convenient for hiding tests inside methods.
For example:

\begin{code}
public static boolean isSingleDigit(int x) {
    if (x > -10 && x < 10) {
        return true;
    } else {
        return false;
    }
}
\end{code}

The name of this method is \java{isSingleDigit}.
It is common to give \java{boolean} methods names that sound like yes/no questions.
Since the return type is \java{boolean}, the return statement has to provide a boolean expression.

The code itself is straightforward, although it is longer than it needs to be.
Remember that the expression \java{x > -10 && x < 10} has type \java{boolean}, so there is nothing wrong with returning it directly (without the \java{if} statement):

\begin{code}
public static boolean isSingleDigit(int x) {
    return x > -10 && x < 10;
}
\end{code}

In \java{main}, you can invoke the method in the usual ways:

\begin{code}
System.out.println(isSingleDigit(2));
boolean bigFlag = !isSingleDigit(17);
\end{code}

The first line displays \java{true} because 2 is a single-digit number.
The second line sets \java{bigFlag} to \java{true}, because 17 is {\em not} a single-digit number.

Conditional statements often invoke \java{boolean} methods and use the result as the condition:

\begin{code}
if (isSingleDigit(z)) {
    System.out.println("z is small");
} else {
    System.out.println("z is big");
}
\end{code}

Examples like this one almost read like English:
``If is single digit z, print ... else print ...''.
