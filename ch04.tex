\chapter{Conditionals and logic}

\index{boolean}
\index{type!boolean}

The programs we've seen in previous chapters do pretty much the same thing every time, regardless of the input.
For more complex computations, programs usually react to the inputs, check for certain conditions, and generate appropriate results.

This chapter presents the features you need for programs to make decisions: a new data type called \java{boolean}, operators for expressing logic, and \java{if} statements.
We'll also take a look at the \java{Math} class, which provides methods for common mathematical operations.


\section{Relational operators}

\index{operator!relational}
\index{relational operator}
\index{comparison operator}

Java has six {\bf relational operators} that test the relationship between two values (i.e., whether they are equal, or whether one is greater than the other).
The following expressions show how they are used:

\begin{code}
x == y          // x is equal to y
x != y          // x is not equal to y
x > y           // x is greater than y
x < y           // x is less than y
x >= y          // x is greater than or equal to y
x <= y          // x is less than or equal to y
\end{code}

\index{Boole, George}

The result of a relational operator is one of two special values: \java{true} or \java{false}.
These values belong to the data type \java{boolean}, named after the mathematician George Boole.
He developed the branch of algebra for representing logic.

\index{assignment}
\index{operator!assignment}

You are probably familiar with these operations, but notice that the Java operators are different from the mathematical symbols like $=$, $\neq$, and $\geq$.
A common error is to use a single \java{=} instead of a double \java{==} when comparing values.
Remember that \java{=} is the {\em assignment} operator, and \java{==} is a {\em relational} operator.
In addition, the operators \java{=<} and \java{=>} do not exist.

The two sides of a relational operator have to be compatible.
For example, the expression \java{5 < "6"} is invalid because \java{5} is an \java{int} and \java{"6"} is a \java{String}.
When comparing values of different numeric types, Java applies the same conversion rules we saw previously with the assignment operator.
For example, when evaluating the expression \java{5 < 6.0}, Java automatically converts the \java{5} to \java{5.0}.


\section{The if-else statement}

\index{conditional statement}
\index{statement!conditional}
\index{if statement}
\index{statement!if}

To write useful programs, we almost always need to check conditions and react accordingly.
{\bf Conditional statements} give us this ability.
The simplest conditional statement in Java is the \java{if} statement:

\begin{code}
if (x > 0) {
    System.out.println("x is positive");
}
\end{code}

The expression in parentheses is called the condition.
If it is true, the statements in braces get executed.
If the condition is false, execution skips over that block of code.
The condition in parentheses can be any \java{boolean} expression.

\index{branch}
\index{statement!else}

A second form of conditional statement has two possibilities, indicated by \java{if} and \java{else}.
The possibilities are called {\bf branches}, and the condition determines which one gets executed:

\begin{code}
if (x % 2 == 0) {
    System.out.println("x is even");
} else {
    System.out.println("x is odd");
}
\end{code}

If the remainder when \java{x} is divided by 2 is zero, we know that \java{x} is even, and this fragment displays a message to that effect.
If the condition is false, the second print statement is executed instead.
Since the condition must be true or false, exactly one of the branches will run.

The braces are optional for branches that have only one statement.
So we could have written the previous example this way:

\begin{code}
if (x % 2 == 0)
    System.out.println("x is even");
else
    System.out.println("x is odd");
\end{code}

However, it's better to use braces -- even when they are optional -- to avoid making the mistake of adding statements to an \java{if} or \java{else} block and forgetting to add the braces.
This code is misleading because it's not indented correctly:

\begin{code}
if (x > 0)
    System.out.println("x is positive");
    System.out.println("x is not zero");
\end{code}

Since there are no braces, only the first \java{println} is part of the \java{if} statement.
Here is what the compiler actually sees:

\begin{code}
if (x > 0) {
    System.out.println("x is positive");
}
    System.out.println("x is not zero");
\end{code}

As a result, the second \java{println} runs no matter what.
Even experienced programmers make this mistake; search the web for Apple's ``goto fail'' bug.

\index{block}

In all previous examples, notice that there is no semicolon at the end of the \java{if} or \java{else} lines.
Instead, a new \textbf{block} should be created using curly braces.
A common mistake is to put a semicolon after the condition, like this:

\begin{code}
int x = 1;
if (x % 2 == 0); {  // incorrect semicolon
    System.out.println("x is even");
}
\end{code}

This code will compile, but the program will output \java{"x is even"} no matter what.
Here is the same incorrect code with better formatting:

\begin{code}
int x = 1;
if (x % 2 == 0)
    ;  // empty statement
{
    System.out.println("x is even");
}
\end{code}

Because of the semicolon, the \java{if} statement compiles as if there are no braces, and the subsequent block runs independently.
As a rule to remember, each line of Java code should end with a semicolon or brace -- but not both.


\section{Chaining and nesting}

\index{chaining}

Sometimes you want to check related conditions and choose one of several actions.
One way to do this is by {\bf chaining} a series of \java{if} and \java{else} statements:

\begin{code}
if (x > 0) {
    System.out.println("x is positive");
} else if (x < 0) {
    System.out.println("x is negative");
} else {
    System.out.println("x is zero");
}
\end{code}

These chains can be as long as you want, although they can be difficult to read if they get out of hand.
One way to make them easier to read is to use standard indentation, as demonstrated in these examples.
If you keep all the statements and braces lined up, you are less likely to make syntax errors.

Notice that the last branch is simply \java{else}, not \java{else if (x == 0)}.
At this point in the chain, we know that \java{x} is not positive and \java{x} is not negative.
So there is no need to test whether \java{x} is zero; there is no other possibility.

\index{nesting}

In addition to chaining, you can also make complex decisions by {\bf nesting} one conditional statement inside another.
We could have written the previous example as:

\begin{code}
if (x > 0) {
    System.out.println("x is positive");
} else {
    if (x < 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
}
\end{code}

The outer conditional has two branches.
The first branch contains a \java{print} statement, and the second branch contains another conditional statement, which has two branches of its own.
These two branches are also \java{print} statements, but they could have been conditional statements as well.

These kinds of nested structures are common, but they can become difficult to read very quickly.
Good indentation is essential to make the structure (or intended structure) apparent to the reader.


\section{Logical operators}

\index{logical operator}
\index{operator!logical}

Java also has three {\bf logical operators}: \java{&&}, \java{||}, and \java{!}, which respectively stand for {\em and}, {\em or}, and {\em not}.
The results of these operators are similar to their meanings in English.

For example, \java{x > 0 && x < 10} is true when \java{x} is both greater than zero {\em and} less than 10.
The expression \java{evenFlag || n \% 3 == 0} is true if either condition is true, that is, if \java{evenFlag} is true {\em or} the number \java{n} is divisible by 3.
Finally, the \java{!} operator inverts a boolean expression.
So \java{!evenFlag} is true if \java{evenFlag} is {\em not} true.

The \java{&&} operator can be used to simplify nested \java{if} statements.

\begin{code}
if (x == 0) {
    if (y == 0) {
        System.out.println("Both x and y are zero");
    }
}
\end{code}

The previous code can be rewritten with a single condition.

\begin{code}
if (x == 0 && y == 0) {
    System.out.println("Both x and y are zero");
}
\end{code}

Likewise, the \java{||} operator can simplify chained \java{if} statements.

\begin{code}
if (x == 0) {
    System.out.println("Either x or y is zero");
} else if (y == 0) {
    System.out.println("Either x or y is zero");
}
\end{code}

Since the branches are the same, there is no need to duplicate that code.

\begin{code}
if (x == 0 || y == 0) {
    System.out.println("Either x or y is zero");
}
\end{code}

Had the statements in the branches been different, we could not have combined them into one block.
But it's useful to explore different ways of representing the same logic, especially when it's complex.

\index{short circuit}

Logical operators evaluate the second expression only when necessary.
For example, \java{true || anything} is always true, so Java does not need to evaluate the expression \java{anything}.
Likewise, \java{false && anything} is always false.

Ignoring the second operand, when possible, is called {\bf short circuit} evaluation, by analogy with an electrical circuit.
Short circuit evaluation can save time, especially if \java{anything} takes a long time to evaluate.
It can also avoid unnecessary errors, if \java{anything} might fail.


\section{De Morgan's laws}

Sometimes you need to negate an expression containing relational and logical operators.
For example, to test if \java{x} and \java{y} are both nonzero, you could write:

\begin{code}
if (!(x == 0 || y == 0)) {
    System.out.println("Neither x nor y is zero");
}
\end{code}

\index{De Morgan's laws}

This condition is difficult to read because of the \java{!} and parentheses.
A better way to negate logic expressions is to apply {\bf De Morgan's laws}:

\begin{itemize}
\item \java{!(A && B)} ~is the same as~ \java{!A || !B}
\item \java{!(A || B)} ~is the same as~ \java{!A && !B}
\end{itemize}

Negating a logical expression is the same as negating each term and changing the operator.
The \java{!} operator takes precedence over \java{&&} and \java{||}, so you don't have to put parentheses around the individual terms \java{!A} and \java{!B}.

De Morgan's laws also apply to the relational operators.
In this case, negating each term means using the ``opposite'' relational operator.

\begin{itemize}
\item \java{!(x < 5 && y == 3)} ~is the same as~ \java{x >= 5 || y != 3}
\item \java{!(x >= 1 || y != 7)} ~is the same as~ \java{x < 1 && y == 7}
\end{itemize}

It may help to read these examples out loud in English.
For instance, ``If I don't want the case where $x$ is less than 5 and $y$ is 3, then I need $x$ to be greater than or equal to 5, or I need $y$ to be anything but 3.''

Returning to the previous example, here is the revised condition.

\begin{code}
if (x != 0 && y != 0) {
    System.out.println("Neither x nor y is zero");
}
\end{code}


\section{Boolean variables}

\index{expression!boolean}

To store a \java{true} or \java{false} value, you need a \java{boolean} variable.
You can declare and assign them like other variables.
The first line is a variable declaration, the second is an assignment, and the third is both:

\begin{code}
boolean flag;
flag = true;
boolean testResult = false;
\end{code}

\index{initialize}
\index{statement!initialization}

Since relational and logical operators evaluate to a \java{boolean} value, you can store the result of a comparison in a variable:

\begin{code}
boolean evenFlag = (n % 2 == 0);    // true if n is even
boolean positiveFlag = (x > 0);     // true if x is positive
\end{code}

\index{flag}

The parentheses are unnecessary, but they make the code easier to read.
A variable defined in this way is called a {\bf flag}, because it signals or ``flags'' the presence or absence of a condition.

You can use flag variables as part of a conditional statement:

\begin{code}
if (evenFlag) {
    System.out.println("n was even when I checked it");
}
\end{code}

Flags may not seem that useful at this point, but they will help simplify complex conditions later on.
Each part of a condition can be stored in a separate flag, and these flags can be combined with logical operators.

Notice that you don't have to write ~\java{if (evenFlag == true)}.
Since \java{evenFlag} is a \java{boolean}, it's already a condition.
Likewise, to check if a flag is \java{false}:

\begin{code}
if (!evenFlag) {
    System.out.println("n was odd when I checked it");
}
\end{code}


\section{Math methods}

In the next two sections, we'll take a break from conditions and logic and discuss other areas of mathematics in Java.

\index{expression}
\index{argument}

You have probably seen functions like $\sin$ and $\log$ learned to evaluate expressions like $\sin(\pi/2)$ and $\log(1/x)$.
First, you evaluate the expression in parentheses, which is called the {\bf argument} of the function.
Then you can evaluate the function itself, either by hand or by punching it into a calculator.

This process can be applied repeatedly to evaluate more complex expressions like $\log(1/\sin(\pi/2))$.
First we evaluate the argument of the innermost function, then evaluate the function itself, and so on.

\index{Math class}
\index{class!Math}

The Java library includes a \java{Math} class that provides common mathematical operations.
\java{Math} is in the \java{java.lang} package, so you don't have to import it.
%You can use, or {\bf invoke}, \java{Math} methods like this:

\begin{code}
double root = Math.sqrt(17.0);
double angle = 1.5;
double height = Math.sin(angle);
\end{code}

The first line sets \java{root} to the square root of 17.
The third line finds the sine of 1.5 (the value of \java{angle}).

\index{degrees}
\index{radians}
\index{pi}

Arguments of the trigonometric functions -- \java{sin}, \java{cos}, and \java{tan} -- should be in {\em radians}.
To convert from degrees to radians, you can divide by 180 and multiply by $\pi$.
Conveniently, the \java{Math} class provides a constant double named \java{PI} that contains an approximation of $\pi$:

\begin{code}
double degrees = 90;
double angle = degrees / 180.0 * Math.PI;
\end{code}

Notice that \java{PI} is in capital letters.
Java does not recognize \java{Pi}, \java{pi}, or \java{pie}.
Also, \java{PI} is the name of a variable, not a method, so it doesn't have parentheses.
The same is true for the constant \java{Math.E}, which approximates Euler's number.

Converting to and from radians is a common operation, so the \java{Math} class provides methods that do that for you.

\begin{code}
double radians = Math.toRadians(180.0);
double degrees = Math.toDegrees(Math.PI);
\end{code}

\index{long}
\index{type!long}

Another useful method is \java{round}, which rounds a floating-point value to the nearest integer and returns a \java{long}.
The following result is 63 (rounded up from 62.8319).

\begin{code}
long x = Math.round(Math.PI * 20.0);
\end{code}

A \java{long} is like an \java{int}, but bigger.
More specifically, an \java{int} uses 32 bits of memory; the largest value it can hold is $2^{31}-1$, which is about 2 billion.
A \java{long} uses 64 bits, so the largest value is $2^{63}-1$, which is about 9 quintillion.

Take a minute to read the documentation for these and other methods in the \java{Math} class.
The easiest way to find documentation for Java classes is to do a web search for ``Java'' and the name of the class.


\section{Composition}

\index{composition}
\index{expression}

Just as with mathematical functions, Java methods can be {\bf composed} to solve complex problems.
That means you can use one method as part of another.
In fact, you can use any expression as an argument to a method:

\begin{code}
double x = Math.cos(angle + Math.PI / 2.0);
\end{code}

This statement divides \java{Math.PI} by two, adds the result to \java{angle}, and computes the cosine of the sum.
You can also take the result of one method and pass it as an argument to another:

\begin{code}
double x = Math.exp(Math.log(10.0));
\end{code}

In Java, the \java{log} method always uses base $e$.
So this statement finds the log base $e$ of 10, and then raises $e$ to that power.
The result gets assigned to \java{x}.

Some math methods take more than one argument.
For example, \java{Math.pow} takes two arguments and raises the first to the power of the second.
This line of code assigns the value \java{1024.0} to the variable \java{x}:

\begin{code}
double x = Math.pow(2.0, 10.0);
\end{code}

When using \java{Math} methods, it is a common mistake to forget the word \java{Math}.
For example, if you write \java{pow(2.0, 10.0)}, you will get a compiler error:

\begin{stdout}
File: Test.java  [line: 5]
Error: cannot find symbol
  symbol:   method pow(double,double)
  location: class Test
\end{stdout}

The message ``cannot find symbol'' is confusing, but the last two lines provide a useful hint.
The compiler is looking for a method named \java{pow} in the class \java{Test}.
If you don't specify a class name when referring to a method, the compiler looks in the current class by default.




\section{Validating input}
\label{validate}

\index{validate}
\index{hacker}

One of the most important tasks in any computer program is to {\bf validate} input from the user.
People often make mistakes while typing, especially on smartphones, and incorrect inputs may cause your program to fail.
Even worse, someone (i.e., a {\bf hacker}) may intentionally try to break into your system by entering unexpected inputs.

Consider for example this program that prompts the user for a number and computes its logarithm:

\begin{code}
Scanner in = new Scanner(System.in);
System.out.print("Enter a number: ");
double x = in.nextDouble();
double y = Math.log(x);
System.out.println("The log is " + y);
\end{code}

In mathematics, the natural logarithm (base $e$) is undefined when $x < 0$.
The \java{Math.log} method will return {\bf NaN} (not a number) in this case.
Many users are confused when they see \java{NaN}; it often looks like a bug.
We can use an \java{if} statement to make the output more user friendly.

\begin{code}
if (x >= 0) {
    double y = Math.log(x);
    System.out.println("The log is " + y);
} else {
    System.out.println("The log is undefined");
}
\end{code}

This output is better now, but there is another problem.
What if the user doesn't enter a number at all?
What would happen if they typed the word ``hello'', either on accident or on purpose?

\index{exception!InputMismatch}
\index{InputMismatchException}

\begin{small}
\begin{stdout}
Exception in thread "main" java.util.InputMismatchException
	at java.util.Scanner.throwFor(Scanner.java:864)
	at java.util.Scanner.next(Scanner.java:1485)
	at java.util.Scanner.nextDouble(Scanner.java:2413)
	at Logarithm.main(Logarithm.java:8)
\end{stdout}
\end{small}

\index{run-time error}

We can prevent this potential run-time error by testing the input first.
The \java{Scanner} class provides \java{hasNextDouble}, which checks whether the next input can be interpreted as a \java{double}.
If so, we can use \java{nextDouble} and not worry about getting an exception.

\begin{code}
if (!in.hasNextDouble()) {
    String word = in.next();
    System.err.println(word + "is not a number");
    return;
}
\end{code}

\index{return}
\index{statement!return}

This example checks if the input is not a \java{double}, and if so, it displays an error message and quits.
The \java{return} statement allows you to terminate a method before you reach the end of it.
Returning from \java{main} terminates the program.

\index{next!Scanner}

In contrast to \java{in.nextLine}, which returns an entire line of input, the \java{in.next} method returns only the next token of input.
We use \java{in.next} to show the user exactly which word they typed was unexpected.


Notice the use of the \java{!} operator, instead of \java{in.hasNextDouble() == false}.
Since \java{hasNextDouble} returns a boolean result, there is no need to compare it to \java{false}; it is already a condition.

\index{System.err}

This example also uses \java{System.err}, which is an \java{OutputStream} for error messages and warnings.
Some development environments display output to \java{System.err} with a different color or in a separate window.

\section{Putting it all together}

In this chapter we have seen relational and logical operators, \java{if} statements, the \java{Math} class, and validating input.
The following program shows how the individual code examples in the last section fit together.

The programs we're writing are starting to get a little bit long.
In the next chapter, we'll learn how to break them down into multiple methods.

\begin{trinket}{Logarithm.java}
import java.util.Scanner;

/**
 * Demonstrates input validation.
 */
public class Logarithm {
    
    public static void main(String[] args) { 
        
        // prompt for input
        Scanner in = new Scanner(System.in);
        System.out.print("Enter a number: ");
        
        // check the format
        if (!in.hasNextDouble()) {
            String word = in.next();
            System.err.println(word + " is not a number");
            return;
        }
        
        // check the range
        double x = in.nextDouble();
        if (x >= 0) {
            double y = Math.log(x);
            System.out.println("The log of x is " + y);
        } else {
            System.out.println("The log of x is undefined");
        }
    }
}
\end{trinket}


\section{Vocabulary}

\begin{description}

\term{boolean}
A data type with only two values, \java{true} and \java{false}.

\index{operator!relational}
\term{relational operator}
An operator that compares two values and produces a \java{boolean} indicating the relationship between them.

\index{operator!logical}
\term{logical operator}
An operator that combines boolean values and produces a boolean value.

\term{short circuit}
A way of evaluating logical operators that only evaluates the second operand if necessary.

\term{De Morgan's laws}
Mathematical rules that show how to negate a logical expression.

\term{conditional statement}
A statement that uses a condition to determine which statements to execute.

\term{branch}
One of the alternative sets of statements inside a conditional statement.

\term{chaining}
A way of joining several conditional statements in sequence.

\term{nesting}
Putting a conditional statement inside one or both branches of another conditional statement.

\term{flag}
A variable (usually \java{boolean}) that represents a condition or status.

\term{recursion}
The process of invoking (and restarting) the same method that is currently executing.

\term{recursive}
A method that invokes itself, usually with different arguments.

\term{base case}
A condition that causes a recursive method {\em not} to make another recursive call.

\term{binary}
A system that uses only zeros and ones to represent numbers.
Also known as ``base 2''.

\end{description}


\section{Exercises}

The code for this chapter is in the {\tt ch04} directory of {\tt ThinkJava2Code}.
See page~\pageref{code} for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.

If you have not already read Appendix~\ref{debugger}, now might be a good time.
It describes the DrJava debugger, which is a useful tool for tracing the flow of execution.


\begin{exercise}

Logical operators can simplify nested conditional statements.
For example, can you rewrite this code using a single \java{if} statement?

\begin{code}
if (x > 0) {
    if (x < 10) {
        System.out.println("positive single digit number.");
    }
}
\end{code}

\end{exercise}


\begin{exercise}
For the following program:

\begin{enumerate}

\item Draw a stack diagram that shows the state of the program the {\it second} time \java{zoop} is invoked.

\item What is the complete output?

\end{enumerate}

\begin{code}
public static void zoop(String fred, int bob) {
    System.out.println(fred);
    if (bob == 5) {
        ping("not ");
    } else {
        System.out.println("!");
    }
}

public static void main(String[] args) {
    int bizz = 5;
    int buzz = 2;
    zoop("just for", bizz);
    clink(2 * buzz);
}
\end{code}

\begin{code}
public static void clink(int fork) {
    System.out.print("It's ");
    zoop("breakfast ", fork);
}

public static void ping(String strangStrung) {
    System.out.println("any " + strangStrung + "more ");
}
\end{code}
\end{exercise}


\begin{exercise}

Draw a stack diagram that shows the state of the program in Section~\ref{recursion} after \java{main} invokes \java{nLines} with the parameter \java{n == 4}, just before the last invocation of \java{nLines} returns.

\end{exercise}


\begin{exercise}

Fermat's Last Theorem says that there are no integers $a$, $b$, and $c$ such that $a^n + b^n = c^n$, except when $n \leq 2$.

Write a method named \java{checkFermat} that takes four integers as parameters -- \java{a}, \java{b}, \java{c} and \java{n} -- and checks to see if Fermat's theorem holds.
If $n$ is greater than 2 and $a^n + b^n = c^n$, the program should display ``Holy smokes, Fermat was wrong!''
Otherwise the program should display ``No, that doesn't work.''

{\it Hint:} You may want to use \java{Math.pow}.

\end{exercise}


\begin{exercise}

The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods.
Consider the first verse of the song ``99 Bottles of Beer'':

\begin{quote}
99 bottles of beer on the wall,\\
99 bottles of beer,\\
ya' take one down, ya' pass it around,\\
98 bottles of beer on the wall.
\end{quote}

Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:

\begin{quote}
No bottles of beer on the wall,\\
no bottles of beer,\\
ya' can't take one down, ya' can't pass it around,\\
'cause there are no more bottles of beer on the wall!
\end{quote}

And then the song (finally) ends.

Write a program that displays the entire lyrics of ``99 Bottles of Beer''.
Your program should include a recursive method that does the hard part, but you might want to write additional methods to separate other parts of the program.
As you develop your code, test it with a small number of verses, like \java{3}.

\end{exercise}


\begin{exercise}

This exercise reviews the flow of execution through a program with multiple methods.
Read the following code and answer the questions.

\begin{code}
public class Buzz {

    public static void baffle(String blimp) {
        System.out.println(blimp);
        zippo("ping", -5);
    }

    public static void zippo(String quince, int flag) {
        if (flag < 0) {
            System.out.println(quince + " zoop");
        } else {
            System.out.println("ik");
            baffle(quince);
            System.out.println("boo-wa-ha-ha");
        }
    }

    public static void main(String[] args) {
        zippo("rattle", 13);
    }

}
\end{code}

\begin{enumerate}

\item Write the number {\tt 1} next to the first line of code in this program that will execute.

\item Write the number {\tt 2} next to the second line of code, and so on until the end of the program.
If a line is executed more than once, it might end up with more than one number next to it.

\item What is the value of the parameter \java{blimp} when \java{baffle} gets invoked?

\item What is the output of this program?

\end{enumerate}

\end{exercise}


\begin{exercise}

Now that we have conditional statements, we can get back to the ``Guess My Number'' game from Exercise~\ref{guess}.

You should already have a program that chooses a random number, prompts the user to guess it, and displays the difference between the guess and the chosen number.

Adding a small amount of code at a time, and testing as you go, modify the program so it tells the user whether the guess is too high or too low, and then prompts the user for another guess.

The program should continue until the user gets it right.
{\it Hint:} Use two methods, and make one of them recursive.

\end{exercise}
